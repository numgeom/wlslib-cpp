// Copyright 2022 The NumGeom Group, Stony Brook University
// Main developers:
//     wlslib: Xiangmin Jiao, Qiao Chen, Jacob Jones
//     momp2cpp: Xiangmin Jiao, Qiao Chen
//
// wls_internal.cpp
//
// Code generation for function 'wls_internal'
//

// Include files
#include "wls_internal.h"
#include "coder_array.h"
#include "m2c_lib.h"
#include "wls_internal_types.h"
#include "wls_lapack.hpp"
#include <chrono>
#include <cmath>
#include <cstdio>
#include <stdexcept>

// Variable Definitions
namespace wls {
static const int8_T iv[27]{0, 0, 0, 0,  -4, 0, 0, 0, 3, 4, 0, 0, 0, 0,
                           0, 0, 0, -2, -3, 0, 0, 0, 2, 0, 0, 0, 0};

static const int8_T iv1[9]{2, 0, 0, 0, 3, 0, 0, 0, 4};

static const real_T dv[7]{333.33333333333331,
                          1000.0,
                          3333.3333333333335,
                          10000.0,
                          100000.0,
                          1.0E+6,
                          1.0E+7};

static const real_T dv1[9]{2.6, 2.0, 1.6, 1.6, 1.6, 1.5, 1.4, 1.3, 1.2};

static const int8_T iv2[9]{8, 9, 9, 10, 11, 11, 12, 12, 13};

static const int8_T iv3[9]{14, 15, 15, 16, 17, 17, 18, 18, 19};

static const int8_T iv4[27]{5, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 6,
                            7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 6, 7};

static const int8_T iv5[9]{5, 6, 8, 6, 7, 9, 8, 9, 10};

static const int8_T iv6[27]{5,  7, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 7,
                            10, 0, 0,  0, 0, 0, 0, 0, 0, 0, 5, 7, 10};

static const int8_T iv7[27]{2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3,
                            4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4};

} // namespace wls

// Function Declarations
namespace wls {
static inline void b_gen_vander(const ::coder::array<real_T, 2U> &us,
                                ::coder::SizeType npoints,
                                ::coder::SizeType degree, boolean_T unimono,
                                ::coder::array<real_T, 2U> &V);

static inline void b_gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                                   ::coder::SizeType npoints,
                                   ::coder::SizeType degree, boolean_T unimono,
                                   ::coder::array<real_T, 2U> &V);

static inline void b_gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                                   ::coder::SizeType npoints,
                                   ::coder::SizeType degree, boolean_T unimono,
                                   ::coder::array<real_T, 2U> &V);

static inline void b_wls_buhmann_weights(const ::coder::array<real_T, 2U> &us,
                                         ::coder::SizeType npoints,
                                         ::coder::SizeType degree,
                                         boolean_T unimono,
                                         ::coder::array<real_T, 1U> &ws);

static inline void b_wls_kernel(WlsObject *b_wls,
                                const ::coder::array<real_T, 2U> &eval_pnts,
                                const ::coder::array<real_T, 2U> &fs,
                                ::coder::SizeType nevpnts,
                                const ::coder::array<real_T, 2U> &varargin_1,
                                ::coder::array<real_T, 2U> &vdops,
                                ::coder::array<real_T, 2U> &results);

static inline void b_wls_kernel(WlsObject *b_wls,
                                const ::coder::array<real_T, 2U> &eval_pnts,
                                ::coder::SizeType nevpnts,
                                const ::coder::array<real_T, 2U> &varargin_1,
                                ::coder::array<real_T, 2U> &vdops);

static inline void b_wls_kernel(WlsObject *b_wls,
                                const ::coder::array<real_T, 2U> &eval_pnts,
                                const int8_T diff_idx_data[],
                                const ::coder::SizeType diff_idx_size[2],
                                ::coder::SizeType nevpnts,
                                const ::coder::array<real_T, 2U> &varargin_1,
                                ::coder::array<real_T, 2U> &vdops);

static inline void b_wls_kernel(WlsObject *b_wls,
                                const ::coder::array<real_T, 2U> &eval_pnts,
                                ::coder::array<real_T, 2U> &vdops);

static inline void b_wls_kernel(WlsObject *b_wls,
                                const ::coder::array<real_T, 2U> &eval_pnts,
                                const int8_T diff_idx_data[],
                                const ::coder::SizeType diff_idx_size[2],
                                ::coder::SizeType nevpnts,
                                ::coder::array<real_T, 2U> &vdops);

static inline void b_wls_kernel(
    WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
    const int8_T diff_idx_data[], const ::coder::SizeType diff_idx_size[2],
    const ::coder::array<real_T, 2U> &fs, ::coder::SizeType nevpnts,
    const ::coder::array<real_T, 2U> &varargin_1,
    ::coder::array<real_T, 2U> &vdops, ::coder::array<real_T, 2U> &results);

static inline void b_wls_kernel(WlsObject *b_wls,
                                const ::coder::array<real_T, 2U> &eval_pnts,
                                ::coder::SizeType nevpnts,
                                ::coder::array<real_T, 2U> &vdops);

static inline void b_wls_solve_sys(WlsObject *b_wls,
                                   const int8_T diff_idx_data[],
                                   const ::coder::SizeType diff_idx_size[2],
                                   ::coder::array<real_T, 2U> &vdops);

static inline void b_wls_solve_sys(WlsObject *b_wls,
                                   const int8_T diff_idx_data[],
                                   ::coder::SizeType diff_idx_size,
                                   ::coder::array<real_T, 2U> &vdops);

static inline void b_wls_solve_sys(WlsObject *b_wls,
                                   ::coder::array<real_T, 2U> &vdops);

static inline void b_wls_solve_sys(WlsObject *b_wls,
                                   const ::coder::array<real_T, 2U> &ws,
                                   ::coder::array<real_T, 2U> &vdops);

static inline void b_wls_update_rhs(WlsObject *b_wls,
                                    const int8_T diff_idx_data[],
                                    const ::coder::SizeType diff_idx_size[2]);

static inline void b_wls_update_rhs(WlsObject *b_wls,
                                    const int8_T diff_idx_data[],
                                    ::coder::SizeType diff_idx_size);

static inline void b_wls_update_rhs(WlsObject *b_wls,
                                    const int8_T diff_idx_data[],
                                    const ::coder::SizeType diff_idx_size[2],
                                    const ::coder::array<real_T, 2U> &ws);

static inline void b_wls_update_rhs(WlsObject *b_wls,
                                    const ::coder::array<real_T, 2U> &ws);

static inline void b_wls_update_rhs(WlsObject *b_wls);

static inline void b_wls_var_cdr(WlsObject *b_wls,
                                 const ::coder::array<real_T, 2U> &eval_pnts,
                                 ::coder::array<real_T, 2U> &vdops);

static inline void b_wls_var_uno(WlsObject *b_wls,
                                 const ::coder::array<real_T, 2U> &eval_pnts,
                                 ::coder::array<real_T, 2U> &vdops);

static inline void
c_gen_vander(const ::coder::array<real_T, 2U> &us, ::coder::SizeType npoints,
             ::coder::SizeType degree, ::coder::SizeType order,
             const ::coder::array<real_T, 1U> &weights, boolean_T unimono,
             ::coder::array<real_T, 2U> &V);

static inline void
c_gen_vander_2d(const ::coder::array<real_T, 2U> &us, ::coder::SizeType npoints,
                ::coder::SizeType degree, ::coder::SizeType order,
                const ::coder::array<real_T, 1U> &weights, boolean_T unimono,
                ::coder::array<real_T, 2U> &V);

static inline void
c_gen_vander_3d(const ::coder::array<real_T, 2U> &us, ::coder::SizeType npoints,
                ::coder::SizeType degree, ::coder::SizeType order,
                const ::coder::array<real_T, 1U> &weights, boolean_T unimono,
                ::coder::array<real_T, 2U> &V);

static inline void c_wls_kernel(WlsObject *b_wls,
                                const ::coder::array<real_T, 2U> &eval_pnts,
                                ::coder::SizeType nevpnts,
                                ::coder::array<real_T, 2U> &vdops);

static inline void c_wls_solve_sys(WlsObject *b_wls,
                                   ::coder::array<real_T, 2U> &vdops);

static inline void c_wls_solve_sys(WlsObject *b_wls,
                                   const int8_T diff_idx_data[],
                                   const ::coder::SizeType diff_idx_size[2],
                                   ::coder::array<real_T, 2U> &vdops);

static inline void c_wls_update_rhs(WlsObject *b_wls,
                                    const int8_T diff_idx_data[],
                                    const ::coder::SizeType diff_idx_size[2]);

static inline void c_wls_update_rhs(WlsObject *b_wls,
                                    const int8_T diff_idx_data[],
                                    ::coder::SizeType diff_idx_size);

static inline void c_wls_update_rhs(WlsObject *b_wls,
                                    const ::coder::array<real_T, 2U> &ws);

static inline void c_wls_update_rhs(WlsObject *b_wls,
                                    const int8_T diff_idx_data[],
                                    const ::coder::SizeType diff_idx_size[2],
                                    const ::coder::array<real_T, 2U> &ws);

static inline void c_wls_update_rhs(WlsObject *b_wls);

namespace coder {
static inline boolean_T isequal(const ::coder::array<real_T, 2U> &varargin_1);

static inline boolean_T isequal(const ::coder::array<real_T, 1U> &varargin_1);

} // namespace coder
static inline void d_gen_vander(const ::coder::array<real_T, 2U> &us,
                                ::coder::SizeType degree,
                                ::coder::array<real_T, 2U> &V);

static inline void d_gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                                   ::coder::SizeType degree,
                                   ::coder::array<real_T, 2U> &V);

static inline void d_gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                                   ::coder::SizeType degree,
                                   ::coder::array<real_T, 2U> &V);

static inline void d_wls_solve_sys(WlsObject *b_wls,
                                   ::coder::array<real_T, 2U> &vdops);

static inline void d_wls_solve_sys(WlsObject *b_wls,
                                   const int8_T diff_idx_data[],
                                   const ::coder::SizeType diff_idx_size[2],
                                   ::coder::array<real_T, 2U> &vdops);

static inline void d_wls_update_rhs(WlsObject *b_wls,
                                    const int8_T diff_idx_data[],
                                    const ::coder::SizeType diff_idx_size[2]);

static inline void d_wls_update_rhs(WlsObject *b_wls,
                                    const int8_T diff_idx_data[],
                                    const ::coder::SizeType diff_idx_size[2],
                                    const ::coder::array<real_T, 2U> &ws);

static inline void d_wls_update_rhs(WlsObject *b_wls);

static inline void
e_gen_vander(const ::coder::array<real_T, 2U> &us, ::coder::SizeType npoints,
             ::coder::SizeType degree, const ::coder::array<real_T, 2U> &hs_inv,
             boolean_T unimono, ::coder::array<real_T, 2U> &V);

static inline void e_gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                                   ::coder::SizeType npoints,
                                   ::coder::SizeType degree,
                                   const ::coder::array<real_T, 2U> &hs_inv,
                                   boolean_T unimono,
                                   ::coder::array<real_T, 2U> &V);

static inline void e_gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                                   ::coder::SizeType npoints,
                                   ::coder::SizeType degree,
                                   const ::coder::array<real_T, 2U> &hs_inv,
                                   boolean_T unimono,
                                   ::coder::array<real_T, 2U> &V);

static inline void e_wls_solve_sys(WlsObject *b_wls,
                                   ::coder::array<real_T, 2U> &vdops);

static inline void e_wls_update_rhs(WlsObject *b_wls);

static inline void e_wls_update_rhs(WlsObject *b_wls,
                                    const int8_T diff_idx_data[],
                                    const ::coder::SizeType diff_idx_size[2]);

static inline void
f_gen_vander(const ::coder::array<real_T, 2U> &us, ::coder::SizeType npoints,
             ::coder::SizeType degree, ::coder::SizeType order,
             const ::coder::array<real_T, 2U> &hs_inv, boolean_T unimono,
             ::coder::array<real_T, 2U> &V);

static inline void
f_gen_vander_2d(const ::coder::array<real_T, 2U> &us, ::coder::SizeType npoints,
                ::coder::SizeType degree, ::coder::SizeType order,
                const ::coder::array<real_T, 2U> &hs_inv, boolean_T unimono,
                ::coder::array<real_T, 2U> &V);

static inline void
f_gen_vander_3d(const ::coder::array<real_T, 2U> &us, ::coder::SizeType npoints,
                ::coder::SizeType degree, ::coder::SizeType order,
                const ::coder::array<real_T, 2U> &hs_inv, boolean_T unimono,
                ::coder::array<real_T, 2U> &V);

static inline real_T find_kth_shortest_dist(::coder::array<real_T, 1U> &arr,
                                            ::coder::SizeType k,
                                            ::coder::SizeType l,
                                            ::coder::SizeType r);

static inline void
g_gen_vander(const ::coder::array<real_T, 2U> &us, ::coder::SizeType npoints,
             ::coder::SizeType degree, const ::coder::array<real_T, 2U> &hs_inv,
             boolean_T unimono, ::coder::array<real_T, 2U> &V);

static inline void g_gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                                   ::coder::SizeType npoints,
                                   ::coder::SizeType degree,
                                   const ::coder::array<real_T, 2U> &hs_inv,
                                   boolean_T unimono,
                                   ::coder::array<real_T, 2U> &V);

static inline void g_gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                                   ::coder::SizeType npoints,
                                   ::coder::SizeType degree,
                                   const ::coder::array<real_T, 2U> &hs_inv,
                                   boolean_T unimono,
                                   ::coder::array<real_T, 2U> &V);

static inline void gen_vander(const ::coder::array<real_T, 2U> &us,
                              ::coder::SizeType npoints,
                              ::coder::SizeType degree,
                              const ::coder::array<real_T, 2U> &hs_inv,
                              boolean_T unimono, ::coder::array<real_T, 2U> &V);

static inline void gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                                 ::coder::SizeType npoints,
                                 ::coder::SizeType degree,
                                 const ::coder::array<real_T, 2U> &hs_inv,
                                 boolean_T unimono,
                                 ::coder::array<real_T, 2U> &V);

static inline void gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                                 ::coder::SizeType npoints,
                                 ::coder::SizeType degree,
                                 const ::coder::array<real_T, 2U> &hs_inv,
                                 boolean_T unimono,
                                 ::coder::array<real_T, 2U> &V);

static inline void
h_gen_vander(const ::coder::array<real_T, 2U> &us, ::coder::SizeType npoints,
             ::coder::SizeType degree, const ::coder::array<real_T, 2U> &hs_inv,
             boolean_T unimono, ::coder::array<real_T, 2U> &V);

static inline void h_gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                                   ::coder::SizeType npoints,
                                   ::coder::SizeType degree,
                                   const ::coder::array<real_T, 2U> &hs_inv,
                                   boolean_T unimono,
                                   ::coder::array<real_T, 2U> &V);

static inline void h_gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                                   ::coder::SizeType npoints,
                                   ::coder::SizeType degree,
                                   const ::coder::array<real_T, 2U> &hs_inv,
                                   boolean_T unimono,
                                   ::coder::array<real_T, 2U> &V);

static inline boolean_T onaxes(const ::coder::array<real_T, 2U> &us,
                               ::coder::SizeType npnts);

static inline void rrqr_factor(const ::coder::array<real_T, 2U> &A,
                               real_T thres, ::coder::SizeType rowoffset,
                               ::coder::SizeType coloffset, ::coder::SizeType m,
                               ::coder::SizeType n,
                               ::coder::array<real_T, 2U> &QR,
                               ::coder::array<int32_T, 1U> &p, int32_T *rank,
                               ::coder::array<real_T, 1U> &work);

static inline void rrqr_qmulti(const ::coder::array<real_T, 2U> &QR,
                               ::coder::SizeType m, ::coder::SizeType n,
                               ::coder::SizeType rank,
                               ::coder::array<real_T, 2U> &bs,
                               ::coder::SizeType nrhs,
                               ::coder::array<real_T, 1U> &work);

static inline void rrqr_rtsolve(const ::coder::array<real_T, 2U> &QR,
                                ::coder::SizeType n, ::coder::SizeType rank,
                                ::coder::array<real_T, 2U> &bs,
                                ::coder::SizeType nrhs);

static inline void
wls_buhmann_weights(const ::coder::array<real_T, 2U> &us,
                    ::coder::SizeType npoints, ::coder::SizeType degree,
                    boolean_T unimono,
                    const ::coder::array<real_T, 1U> &params_sh,
                    const ::coder::array<real_T, 2U> &params_pw,
                    ::coder::array<real_T, 1U> &ws);

static inline void
wls_eno_weights(const ::coder::array<real_T, 2U> &us, ::coder::SizeType npoints,
                ::coder::SizeType degree,
                const ::coder::array<real_T, 2U> &us_unscaled,
                const ::coder::array<real_T, 1U> &params_sh,
                const ::coder::array<real_T, 2U> &params_pw,
                ::coder::array<real_T, 1U> &ws);

static inline void wls_eval_ops(WlsObject *b_wls,
                                const ::coder::array<real_T, 2U> &vdops,
                                const ::coder::array<real_T, 2U> &fs,
                                ::coder::array<real_T, 2U> &results);

static inline void wls_invdist_weights(const ::coder::array<real_T, 2U> &us,
                                       ::coder::SizeType npoints,
                                       ::coder::SizeType degree,
                                       ::coder::array<real_T, 1U> &ws);

static inline void
wls_invdist_weights(const ::coder::array<real_T, 2U> &us,
                    ::coder::SizeType npoints, ::coder::SizeType degree,
                    const ::coder::array<real_T, 1U> &params_sh,
                    const ::coder::array<real_T, 2U> &params_pw,
                    ::coder::array<real_T, 1U> &ws);

static inline void wls_invdist_weights(const ::coder::array<real_T, 2U> &us,
                                       ::coder::SizeType npoints, real_T degree,
                                       real_T params_sh,
                                       ::coder::array<real_T, 1U> &ws);

static inline void wls_kernel(WlsObject *b_wls,
                              const ::coder::array<real_T, 2U> &eval_pnts,
                              ::coder::array<real_T, 2U> &vdops);

static inline void
wls_kernel(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
           const int8_T diff_idx_data[], ::coder::SizeType diff_idx_size,
           const ::coder::array<real_T, 2U> &fs, ::coder::SizeType nevpnts,
           const ::coder::array<real_T, 2U> &varargin_1,
           ::coder::array<real_T, 2U> &vdops,
           ::coder::array<real_T, 2U> &results);

static inline void
wls_kernel(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
           const int8_T diff_idx_data[], ::coder::SizeType diff_idx_size,
           ::coder::SizeType nevpnts, ::coder::array<real_T, 2U> &vdops);

static inline void wls_kernel(WlsObject *b_wls,
                              const ::coder::array<real_T, 2U> &eval_pnts,
                              const int8_T diff_idx_data[],
                              ::coder::SizeType diff_idx_size,
                              ::coder::SizeType nevpnts,
                              const ::coder::array<real_T, 2U> &varargin_1,
                              ::coder::array<real_T, 2U> &vdops);

static inline void wls_kernel(WlsObject *b_wls,
                              const ::coder::array<real_T, 2U> &eval_pnts,
                              ::coder::SizeType nevpnts,
                              ::coder::array<real_T, 2U> &vdops);

static inline void wls_kernel(
    WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
    const int8_T diff_idx_data[], const ::coder::SizeType diff_idx_size[2],
    const ::coder::array<real_T, 2U> &fs, ::coder::SizeType nevpnts,
    ::coder::array<real_T, 2U> &vdops, ::coder::array<real_T, 2U> &results);

static inline void wls_kernel(WlsObject *b_wls,
                              const ::coder::array<real_T, 2U> &eval_pnts,
                              const int8_T diff_idx_data[],
                              const ::coder::SizeType diff_idx_size[2],
                              const ::coder::array<real_T, 2U> &fs,
                              ::coder::array<real_T, 2U> &vdops,
                              ::coder::array<real_T, 2U> &results);

static inline void wls_kernel(WlsObject *b_wls,
                              const ::coder::array<real_T, 2U> &eval_pnts,
                              const int8_T diff_idx_data[],
                              const ::coder::SizeType diff_idx_size[2],
                              ::coder::array<real_T, 2U> &vdops);

static inline void wls_kernel(WlsObject *b_wls,
                              const ::coder::array<real_T, 2U> &eval_pnts,
                              const ::coder::array<real_T, 2U> &fs,
                              ::coder::SizeType nevpnts,
                              ::coder::array<real_T, 2U> &vdops,
                              ::coder::array<real_T, 2U> &results);

static inline void wls_kernel(WlsObject *b_wls,
                              const ::coder::array<real_T, 2U> &eval_pnts,
                              ::coder::SizeType nevpnts,
                              const ::coder::array<real_T, 2U> &varargin_1,
                              ::coder::array<real_T, 2U> &vdops);

static inline void wls_kernel(WlsObject *b_wls,
                              const ::coder::array<real_T, 2U> &eval_pnts,
                              const ::coder::array<real_T, 2U> &fs,
                              ::coder::SizeType nevpnts,
                              const ::coder::array<real_T, 2U> &varargin_1,
                              ::coder::array<real_T, 2U> &vdops,
                              ::coder::array<real_T, 2U> &results);

static inline void wls_kernel(WlsObject *b_wls,
                              const ::coder::array<real_T, 2U> &eval_pnts,
                              const ::coder::array<real_T, 2U> &fs,
                              ::coder::array<real_T, 2U> &vdops,
                              ::coder::array<real_T, 2U> &results);

static inline void
wls_kernel(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
           const int8_T diff_idx_data[], ::coder::SizeType diff_idx_size,
           const ::coder::array<real_T, 2U> &fs, ::coder::SizeType nevpnts,
           ::coder::array<real_T, 2U> &vdops,
           ::coder::array<real_T, 2U> &results);

static inline void wls_kernel(WlsObject *b_wls,
                              const ::coder::array<real_T, 2U> &eval_pnts,
                              const int8_T diff_idx_data[],
                              ::coder::SizeType diff_idx_size,
                              const ::coder::array<real_T, 2U> &fs,
                              ::coder::array<real_T, 2U> &vdops,
                              ::coder::array<real_T, 2U> &results);

static inline void wls_kernel(WlsObject *b_wls,
                              const ::coder::array<real_T, 2U> &eval_pnts,
                              const int8_T diff_idx_data[],
                              ::coder::SizeType diff_idx_size,
                              ::coder::array<real_T, 2U> &vdops);

static inline void wls_kernel(
    WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
    const int8_T diff_idx_data[], const ::coder::SizeType diff_idx_size[2],
    const ::coder::array<real_T, 2U> &fs, ::coder::SizeType nevpnts,
    const ::coder::array<real_T, 2U> &varargin_1,
    ::coder::array<real_T, 2U> &vdops, ::coder::array<real_T, 2U> &results);

static inline void wls_kernel(WlsObject *b_wls,
                              const ::coder::array<real_T, 2U> &eval_pnts,
                              const int8_T diff_idx_data[],
                              const ::coder::SizeType diff_idx_size[2],
                              ::coder::SizeType nevpnts,
                              ::coder::array<real_T, 2U> &vdops);

static inline void wls_kernel(WlsObject *b_wls,
                              const ::coder::array<real_T, 2U> &eval_pnts,
                              const int8_T diff_idx_data[],
                              const ::coder::SizeType diff_idx_size[2],
                              ::coder::SizeType nevpnts,
                              const ::coder::array<real_T, 2U> &varargin_1,
                              ::coder::array<real_T, 2U> &vdops);

static inline void wls_resize(WlsObject *b_wls, ::coder::SizeType dim,
                              ::coder::SizeType nstpnts,
                              ::coder::SizeType degree,
                              ::coder::SizeType order);

static inline void wls_solve_sys(WlsObject *b_wls,
                                 const ::coder::array<real_T, 2U> &ws,
                                 ::coder::array<real_T, 2U> &vdops);

static inline void wls_solve_sys(WlsObject *b_wls,
                                 ::coder::array<real_T, 2U> &vdops);

static inline void wls_solve_sys(WlsObject *b_wls, const int8_T diff_idx_data[],
                                 const ::coder::SizeType diff_idx_size[2],
                                 const ::coder::array<real_T, 2U> &ws,
                                 ::coder::array<real_T, 2U> &vdops);

static inline void wls_solve_sys(WlsObject *b_wls, const int8_T diff_idx_data[],
                                 ::coder::SizeType diff_idx_size,
                                 ::coder::array<real_T, 2U> &vdops);

static inline void wls_solve_sys(WlsObject *b_wls, const int8_T diff_idx_data[],
                                 const ::coder::SizeType diff_idx_size[2],
                                 ::coder::array<real_T, 2U> &vdops);

static inline void wls_solve_sys(WlsObject *b_wls, const int8_T diff_idx_data[],
                                 const ::coder::SizeType diff_idx_size[2],
                                 const ::coder::array<real_T, 1U> &ws,
                                 ::coder::array<real_T, 2U> &vdops);

static inline void wls_update_rhs(WlsObject *b_wls,
                                  const int8_T diff_idx_data[],
                                  ::coder::SizeType diff_idx_size,
                                  const ::coder::array<real_T, 2U> &ws);

static inline void wls_update_rhs(WlsObject *b_wls);

static inline void wls_update_rhs(WlsObject *b_wls,
                                  const int8_T diff_idx_data[],
                                  ::coder::SizeType diff_idx_size,
                                  const ::coder::array<real_T, 1U> &ws);

static inline void wls_update_rhs(WlsObject *b_wls,
                                  ::coder::SizeType diff_idx_size);

static inline void wls_update_rhs(WlsObject *b_wls,
                                  const int8_T diff_idx_data[],
                                  const ::coder::SizeType diff_idx_size[2]);

static inline void wls_update_rhs(WlsObject *b_wls,
                                  const int8_T diff_idx_data[],
                                  const ::coder::SizeType diff_idx_size[2],
                                  const ::coder::array<real_T, 1U> &ws);

static inline void wls_update_rhs(WlsObject *b_wls,
                                  const ::coder::array<real_T, 2U> &ws);

static inline void wls_update_rhs(WlsObject *b_wls,
                                  const int8_T diff_idx_data[],
                                  const ::coder::SizeType diff_idx_size[2],
                                  const ::coder::array<real_T, 2U> &ws);

static inline void wls_update_rhs(WlsObject *b_wls,
                                  const int8_T diff_idx_data[],
                                  ::coder::SizeType diff_idx_size);

static inline void wls_var_cdr(WlsObject *b_wls,
                               const ::coder::array<real_T, 2U> &eval_pnts,
                               const ::coder::array<real_T, 2U> &ws_lap,
                               const ::coder::array<real_T, 2U> &ws_grad,
                               ::coder::array<real_T, 2U> &vdops);

static inline void wls_var_cdr(WlsObject *b_wls,
                               const ::coder::array<real_T, 2U> &eval_pnts,
                               ::coder::array<real_T, 2U> &vdops);

static inline void wls_var_cdr(WlsObject *b_wls,
                               const ::coder::array<real_T, 2U> &eval_pnts,
                               const ::coder::array<real_T, 2U> &ws_lap,
                               ::coder::array<real_T, 2U> &vdops);

static inline void wls_var_cdr(WlsObject *b_wls,
                               const ::coder::array<real_T, 2U> &eval_pnts,
                               const ::coder::array<real_T, 2U> &ws_lap,
                               const ::coder::array<real_T, 2U> &fs,
                               ::coder::array<real_T, 2U> &vdops,
                               ::coder::array<real_T, 2U> &result);

static inline void wls_var_cdr(WlsObject *b_wls,
                               const ::coder::array<real_T, 2U> &eval_pnts,
                               const ::coder::array<real_T, 2U> &ws_lap,
                               const ::coder::array<real_T, 2U> &fs,
                               ::coder::SizeType nevpnts,
                               ::coder::array<real_T, 2U> &vdops,
                               ::coder::array<real_T, 2U> &result);

static inline void wls_var_cdr(WlsObject *b_wls,
                               const ::coder::array<real_T, 2U> &eval_pnts,
                               const ::coder::array<real_T, 2U> &ws_lap,
                               const ::coder::array<real_T, 2U> &ws_grad,
                               const ::coder::array<real_T, 2U> &fs,
                               ::coder::array<real_T, 2U> &vdops,
                               ::coder::array<real_T, 2U> &result);

static inline void wls_var_cdr(WlsObject *b_wls,
                               const ::coder::array<real_T, 2U> &eval_pnts,
                               const ::coder::array<real_T, 2U> &ws_lap,
                               const ::coder::array<real_T, 2U> &ws_grad,
                               const ::coder::array<real_T, 2U> &fs,
                               ::coder::SizeType nevpnts,
                               ::coder::array<real_T, 2U> &vdops,
                               ::coder::array<real_T, 2U> &result);

static inline void wls_var_uno(WlsObject *b_wls,
                               const ::coder::array<real_T, 2U> &eval_pnts,
                               const ::coder::array<real_T, 1U> &ws_graddiv,
                               const ::coder::array<real_T, 1U> &ws_lap,
                               const ::coder::array<real_T, 2U> &fs,
                               ::coder::SizeType nevpnts,
                               ::coder::array<real_T, 2U> &vdops,
                               ::coder::array<real_T, 2U> &result);

static inline void wls_var_uno(WlsObject *b_wls,
                               const ::coder::array<real_T, 2U> &eval_pnts,
                               const ::coder::array<real_T, 1U> &ws_graddiv,
                               const ::coder::array<real_T, 2U> &fs,
                               ::coder::SizeType nevpnts,
                               ::coder::array<real_T, 2U> &vdops,
                               ::coder::array<real_T, 2U> &result);

static inline void wls_var_uno(WlsObject *b_wls,
                               const ::coder::array<real_T, 2U> &eval_pnts,
                               const ::coder::array<real_T, 1U> &ws_graddiv,
                               const ::coder::array<real_T, 2U> &fs,
                               ::coder::array<real_T, 2U> &vdops,
                               ::coder::array<real_T, 2U> &result);

static inline void wls_var_uno(WlsObject *b_wls,
                               const ::coder::array<real_T, 2U> &eval_pnts,
                               const ::coder::array<real_T, 1U> &ws_graddiv,
                               const ::coder::array<real_T, 1U> &ws_lap,
                               const ::coder::array<real_T, 2U> &fs,
                               ::coder::array<real_T, 2U> &vdops,
                               ::coder::array<real_T, 2U> &result);

static inline void wls_var_uno(WlsObject *b_wls,
                               const ::coder::array<real_T, 2U> &eval_pnts,
                               ::coder::array<real_T, 2U> &vdops);

static inline void wls_var_uno(WlsObject *b_wls,
                               const ::coder::array<real_T, 2U> &eval_pnts,
                               const ::coder::array<real_T, 1U> &ws_graddiv,
                               const ::coder::array<real_T, 1U> &ws_lap,
                               ::coder::array<real_T, 2U> &vdops);

static inline void wls_var_uno(WlsObject *b_wls,
                               const ::coder::array<real_T, 2U> &eval_pnts,
                               const ::coder::array<real_T, 1U> &ws_graddiv,
                               ::coder::array<real_T, 2U> &vdops);

} // namespace wls

// Function Definitions
namespace wls {
static void b_gen_vander(const ::coder::array<real_T, 2U> &us,
                         ::coder::SizeType npoints, ::coder::SizeType degree,
                         boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  switch (us.size(1)) {
  case 1: {
    ::coder::SizeType b_npoints;
    ::coder::SizeType i;
    ::coder::SizeType i1;
    ::coder::SizeType i2;
    boolean_T b;
    boolean_T b1;
    b_npoints = npoints - 1;
    m2cAssert(us.size(1) == 1, "");
    //  Handle input arguments
    if (npoints == 0) {
      b_npoints = us.size(0) - 1;
    } else {
      m2cAssert(npoints <= us.size(0), "Input us is too small.");
    }
    m2cAssert(degree >= 0, "Degree must be nonnegative");
    //  Number of row blocks
    V.set_size(degree + 1, us.size(0));
    //  Compute rows corresponding to function values
    if (degree != 0) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      i = us.size(1) * us.size(0);
      i1 = 0;
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          i2 = us.size(1) * us.size(0) - 1;
          if (i1 > MAX_int32_T - us.size(1)) {
            i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i1 += us.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        V[iPnt] = 1.0;
        V[iPnt + V.size(1)] = us[i1];
      }
    } else {
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        V[iPnt] = 1.0;
      }
    }
    i = degree + 1;
    for (::coder::SizeType ii{2}; ii <= i; ii++) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      i1 = us.size(1) * us.size(0);
      i2 = 0;
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= i1)) {
          i2 = 0;
          b = true;
        } else if (b) {
          b = false;
          i2 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          ::coder::SizeType i3;
          i3 = us.size(1) * us.size(0) - 1;
          if (i2 > MAX_int32_T - us.size(1)) {
            i2 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i2 += us.size(1);
            if (i2 > i3) {
              i2 -= i3;
            }
          }
        }
        V[iPnt + V.size(1) * (ii - 1)] =
            V[iPnt + V.size(1) * (ii - 2)] * us[i2];
      }
    }
    //  Add row blocks corresponding to kth derivatives
  } break;
  case 2:
    b_gen_vander_2d(us, npoints, degree, unimono, V);
    break;
  default:
    b_gen_vander_3d(us, npoints, degree, unimono, V);
    break;
  }
}

static void b_gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                            ::coder::SizeType npoints, ::coder::SizeType degree,
                            boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  ::coder::SizeType c;
  ::coder::SizeType ret;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (unimono && (degree >= 0)) {
    degree = -degree;
  }
  //  Number of row blocks
  if (degree >= 0) {
    ret = (degree + 1) * (degree + 2) / 2;
    unimono = false;
  } else if (unimono) {
    ret = 1 - (degree << 1);
  } else {
    ret = (1 - degree) * (1 - degree);
  }
  //  Allocate storage for V
  V.set_size(ret, us.size(0));
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
    }
  } else {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 3;
  if (!unimono) {
    if (degree < 0) {
      ret = -degree;
    } else {
      ret = degree;
    }
    for (::coder::SizeType deg{2}; deg <= ret; deg++) {
      for (::coder::SizeType j{0}; j < deg; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - deg) - 1)] * us[us.size(1) * iPnt + 1];
      }
      c++;
    }
    //  Compute the bi-degree terms if degree<0
    ret = -degree;
    for (::coder::SizeType deg{ret}; deg >= 1; deg--) {
      for (::coder::SizeType k{0}; k < deg; k++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
        }
        c++;
      }
    }
  } else {
    if (degree < 0) {
      ret = -degree;
    } else {
      ret = degree;
    }
    for (::coder::SizeType deg{2}; deg <= ret; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 2)] * us[us.size(1) * iPnt];
        V[iPnt + V.size(1) * (c + 1)] =
            V[iPnt + V.size(1) * (c - 1)] * us[us.size(1) * iPnt + 1];
      }
      c += 2;
    }
  }
  //  compute higher order confluent Vandermonde matrix blocks incrementally
}

static void b_gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                            ::coder::SizeType npoints, ::coder::SizeType degree,
                            boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  ::coder::SizeType c;
  ::coder::SizeType d;
  ::coder::SizeType ret;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (unimono && (degree >= 0)) {
    degree = -degree;
  }
  if (degree >= 0) {
    ret = (degree + 1) * (degree + 2) * (degree + 3) / 6;
    unimono = false;
  } else if (unimono) {
    ret = 1 - 3 * degree;
  } else {
    ret = (1 - degree) * (1 - degree) * (1 - degree);
  }
  //  Allocate storage for V
  V.set_size(ret, us.size(0));
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
      V[iPnt + V.size(1) * 3] = us[us.size(1) * iPnt + 2];
    }
  } else {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 4;
  d = 3;
  if (!unimono) {
    ::coder::SizeType deg;
    ::coder::SizeType i;
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      //  Within each level, use convention of Pascal triangle with x^deg at
      for (::coder::SizeType j{0}; j < deg; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * us[us.size(1) * iPnt];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - d) - 1)] * us[us.size(1) * iPnt + 1];
      }
      c++;
      for (::coder::SizeType j{0}; j < d; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
              us[us.size(1) * iPnt + 2];
        }
        c++;
      }
      d = (d + deg) + 1;
    }
    //  Compute the tri-degree terms if degree<0
    if (degree < 0) {
      ::coder::SizeType cornerTriangle;
      ::coder::SizeType excess;
      ::coder::SizeType maxLayers;
      ::coder::SizeType nTermsInLayer;
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        ::coder::SizeType counterBottomRow;
        ::coder::SizeType gap;
        ::coder::SizeType nTermsInPrevLayer;
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 1;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType k{0}; k < deg; k++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[iPnt + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - nTermsInLayer)] *
                us[us.size(1) * iPnt + 1];
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        ret = ((degree + degree) + p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer;
        nTermsInLayer = d + 3 * (excess - cornerTriangle);
        gap = (nTermsInPrevLayer + counterBottomRow) - 1;
        ret = nTermsInLayer - counterBottomRow;
        for (::coder::SizeType j{0}; j <= ret; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[iPnt + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - gap)] * us[us.size(1) * iPnt + 2];
          }
          c++;
        }
      }
    }
  } else {
    ::coder::SizeType i;
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (::coder::SizeType deg{2}; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 3)] * us[us.size(1) * iPnt];
        V[iPnt + V.size(1) * (c + 1)] =
            V[iPnt + V.size(1) * (c - 2)] * us[us.size(1) * iPnt + 1];
        V[iPnt + V.size(1) * (c + 2)] =
            V[iPnt + V.size(1) * (c - 1)] * us[us.size(1) * iPnt + 2];
      }
      c += 3;
    }
  }
  m2cAssert(true, "");
}

static void b_wls_buhmann_weights(const ::coder::array<real_T, 2U> &us,
                                  ::coder::SizeType npoints,
                                  ::coder::SizeType degree, boolean_T unimono,
                                  ::coder::array<real_T, 1U> &ws)
{
  real_T d;
  real_T dist_k;
  real_T r;
  real_T r1;
  real_T r2;
  real_T rho;
  real_T sigma;
  ::coder::SizeType abs_degree;
  ::coder::SizeType i;
  if (degree == 0) {
    degree = 2;
  }
  if (degree < 0) {
    abs_degree = 1 - degree;
  } else {
    abs_degree = degree + 1;
  }
  //  Assign default rho
  if (abs_degree - 1 >= 9) {
    sigma = 1.2;
  } else {
    sigma = dv1[abs_degree - 2];
  }
  if (ws.size(0) == 0) {
    ws.set_size(npoints);
  } else {
    m2cAssert(ws.size(0) >= npoints,
              "length of ws cannot be smaller than npoints");
  }
  //  Compute rho to be sigma times the kth distance for k=ceil(1.5*ncoff)
  if (degree >= 0) {
    //  Compute 2-norm
    i = us.size(1);
    for (::coder::SizeType b_i{0}; b_i < npoints; b_i++) {
      d = us[us.size(1) * b_i];
      r2 = d * d;
      for (::coder::SizeType j{2}; j <= i; j++) {
        d = us[(j + us.size(1) * b_i) - 1];
        r2 += d * d;
      }
      ws[b_i] = std::sqrt(r2);
    }
  } else {
    //  Compute inf-norm for tensor-product
    i = us.size(1);
    for (::coder::SizeType b_i{0}; b_i < npoints; b_i++) {
      r = std::abs(us[us.size(1) * b_i]);
      for (::coder::SizeType j{2}; j <= i; j++) {
        r1 = std::abs(us[(j + us.size(1) * b_i) - 1]);
        if (r1 > r) {
          r = r1;
        }
      }
      ws[b_i] = r;
    }
  }
  if (us.size(1) == 1) {
    i = abs_degree;
  } else if (us.size(1) == 2) {
    if (unimono) {
      i = ((abs_degree - 1) << 1) + 1;
    } else if (degree < 0) {
      i = abs_degree * abs_degree;
    } else {
      i = (abs_degree + 1) * abs_degree / 2;
    }
  } else if (unimono) {
    i = 3 * (abs_degree - 1) + 1;
  } else if (degree < 0) {
    i = abs_degree * abs_degree * abs_degree;
  } else {
    i = (abs_degree + 2) * (abs_degree + 1) * abs_degree / 6;
  }
  dist_k = find_kth_shortest_dist(ws, (i * 3 + 1) / 2, 1, npoints);
  rho = sigma * dist_k;
  for (::coder::SizeType b_i{0}; b_i < npoints; b_i++) {
    if (degree > 0) {
      //  Compute 2-norm
      d = us[us.size(1) * b_i];
      r2 = d * d;
      i = us.size(1);
      for (::coder::SizeType j{2}; j <= i; j++) {
        d = us[(j + us.size(1) * b_i) - 1];
        r2 += d * d;
      }
      r = std::sqrt(r2);
    } else {
      //  Compute inf-norm for tensor-product
      r = std::abs(us[us.size(1) * b_i]);
      i = us.size(1);
      for (::coder::SizeType j{2}; j <= i; j++) {
        r1 = std::abs(us[(j + us.size(1) * b_i) - 1]);
        if (r1 > r) {
          r = r1;
        }
      }
    }
    if (r > rho) {
      ws[b_i] = 0.0;
    } else {
      real_T r_sqrt;
      r /= rho;
      r_sqrt = std::sqrt(r);
      ws[b_i] = r * r *
                    (r * r_sqrt *
                         (r_sqrt * (r_sqrt * 112.0 / 45.0 + -7.0) +
                          5.333333333333333) +
                     -0.93333333333333335) +
                0.1111111111111111;
    }
  }
}

static void b_wls_kernel(WlsObject *b_wls,
                         const ::coder::array<real_T, 2U> &eval_pnts,
                         const int8_T diff_idx_data[],
                         const ::coder::SizeType diff_idx_size[2],
                         ::coder::SizeType nevpnts,
                         const ::coder::array<real_T, 2U> &varargin_1,
                         ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, b_nevpnts, b_wls->degree, b_wls->hs_inv, b_wls->unimono,
             b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  c_wls_update_rhs(b_wls, diff_idx_data, diff_idx_size, varargin_1);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  wls_solve_sys(b_wls, diff_idx_data, diff_idx_size, varargin_1, vdops);
  //  Rearrange vdops using wls.V as work space
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

static void b_wls_kernel(WlsObject *b_wls,
                         const ::coder::array<real_T, 2U> &eval_pnts,
                         ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  nevpnts = eval_pnts.size(0);
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  b_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->unimono,
               b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  b_wls_update_rhs(b_wls);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  b_wls_solve_sys(b_wls, vdops);
  //  Rearrange vdops using wls.V as work space
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

static void b_wls_kernel(WlsObject *b_wls,
                         const ::coder::array<real_T, 2U> &eval_pnts,
                         ::coder::SizeType nevpnts,
                         const ::coder::array<real_T, 2U> &varargin_1,
                         ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  b_gen_vander(b_wls->us, b_nevpnts, b_wls->degree, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  c_wls_update_rhs(b_wls, varargin_1);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  wls_solve_sys(b_wls, varargin_1, vdops);
  //  Rearrange vdops using wls.V as work space
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

static void b_wls_kernel(WlsObject *b_wls,
                         const ::coder::array<real_T, 2U> &eval_pnts,
                         const ::coder::array<real_T, 2U> &fs,
                         ::coder::SizeType nevpnts,
                         const ::coder::array<real_T, 2U> &varargin_1,
                         ::coder::array<real_T, 2U> &vdops,
                         ::coder::array<real_T, 2U> &results)
{
  real_T timestamp;
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  b_gen_vander(b_wls->us, b_nevpnts, b_wls->degree, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  c_wls_update_rhs(b_wls, varargin_1);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  wls_solve_sys(b_wls, varargin_1, vdops);
  //  Rearrange vdops using wls.V as work space
  wls_eval_ops(b_wls, vdops, fs, results);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

static void b_wls_kernel(WlsObject *b_wls,
                         const ::coder::array<real_T, 2U> &eval_pnts,
                         const int8_T diff_idx_data[],
                         const ::coder::SizeType diff_idx_size[2],
                         ::coder::SizeType nevpnts,
                         ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, b_nevpnts, b_wls->degree, b_wls->hs_inv, b_wls->unimono,
             b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  d_wls_update_rhs(b_wls, diff_idx_data, diff_idx_size);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  d_wls_solve_sys(b_wls, diff_idx_data, diff_idx_size, vdops);
  //  Rearrange vdops using wls.V as work space
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

static void b_wls_kernel(
    WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
    const int8_T diff_idx_data[], const ::coder::SizeType diff_idx_size[2],
    const ::coder::array<real_T, 2U> &fs, ::coder::SizeType nevpnts,
    const ::coder::array<real_T, 2U> &varargin_1,
    ::coder::array<real_T, 2U> &vdops, ::coder::array<real_T, 2U> &results)
{
  real_T timestamp;
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, b_nevpnts, b_wls->degree, b_wls->hs_inv, b_wls->unimono,
             b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  c_wls_update_rhs(b_wls, diff_idx_data, diff_idx_size, varargin_1);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  wls_solve_sys(b_wls, diff_idx_data, diff_idx_size, varargin_1, vdops);
  //  Rearrange vdops using wls.V as work space
  wls_eval_ops(b_wls, vdops, fs, results);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

static void b_wls_kernel(WlsObject *b_wls,
                         const ::coder::array<real_T, 2U> &eval_pnts,
                         ::coder::SizeType nevpnts,
                         ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, b_nevpnts, b_wls->degree, b_wls->hs_inv, b_wls->unimono,
             b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  d_wls_update_rhs(b_wls);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  d_wls_solve_sys(b_wls, vdops);
  //  Rearrange vdops using wls.V as work space
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

static void b_wls_solve_sys(WlsObject *b_wls,
                            const ::coder::array<real_T, 2U> &ws,
                            ::coder::array<real_T, 2U> &vdops)
{
  ::coder::SizeType b_loop_ub;
  ::coder::SizeType i;
  ::coder::SizeType k;
  ::coder::SizeType loop_ub;
  ::coder::SizeType nRhs;
  ::coder::SizeType ndims;
  ::coder::SizeType nnzops;
  ::coder::SizeType nrows;
  ::coder::SizeType nrows_vdops;
  ::coder::SizeType row;
  int8_T x[3];
  boolean_T compressed;
  boolean_T exitg1;
  boolean_T y;
  nRhs = b_wls->rhs.size(0);
  compressed = false;
  //  Compress wls.rhs
  nnzops = 0;
  row = 1;
  for (::coder::SizeType j{0}; j < nRhs; j++) {
    k = 3 * (row - 1);
    x[0] = iv[k];
    x[1] = iv[k + 1];
    x[2] = iv[k + 2];
    y = false;
    k = 0;
    exitg1 = false;
    while ((!exitg1) && (k < 3)) {
      if (x[k] != 0) {
        y = true;
        exitg1 = true;
      } else {
        k++;
      }
    }
    if (y) {
      nnzops++;
      if (compressed) {
        i = b_wls->rhs.size(1);
        for (k = 0; k < i; k++) {
          b_wls->rhs[k + b_wls->rhs.size(1) * (nnzops - 1)] =
              b_wls->rhs[k + b_wls->rhs.size(1) * j];
        }
      }
    } else {
      compressed = true;
    }
    if (row < 9) {
      row++;
    } else {
      row = 1;
    }
  }
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      b_loop_ub = b_wls->QR.size(0);
      for (k = 0; k < b_loop_ub; k++) {
        b_wls->QRt[k + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * k];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  }
  k = b_wls->ncols;
  b_loop_ub = b_wls->nrows;
  if (k >= b_loop_ub) {
    nrows_vdops = k;
  } else {
    nrows_vdops = b_loop_ub;
  }
  vdops.set_size(nrows_vdops, nRhs);
  if (compressed) {
    vdops.set_size(nrows_vdops, nRhs);
    loop_ub = nRhs * nrows_vdops;
    for (i = 0; i < loop_ub; i++) {
      vdops[i] = 0.0;
    }
    //  Compress wls.rhs
    nnzops = -1;
    row = 1;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      k = 3 * (row - 1);
      x[0] = iv[k];
      x[1] = iv[k + 1];
      x[2] = iv[k + 2];
      y = false;
      k = 0;
      exitg1 = false;
      while ((!exitg1) && (k < 3)) {
        if (x[k] != 0) {
          y = true;
          exitg1 = true;
        } else {
          k++;
        }
      }
      if (y) {
        nnzops++;
        i = nrows_vdops - b_wls->interp0;
        for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
          vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
              b_wls->rhs[b_i + b_wls->rhs.size(1) * nnzops];
        }
      }
      if (row < 9) {
        row++;
      } else {
        row = 1;
      }
    }
  } else {
    //  Transpose the operator for row-major
    i = nrows_vdops - b_wls->interp0;
    for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
      for (::coder::SizeType j{0}; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (k = 0; k < nRhs; k++) {
      for (::coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    ::coder::SizeType iWeight;
    boolean_T b;
    //  In interp0 mode, set the first entry based on partition of unity
    iWeight = 1;
    b = true;
    i = 0;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      real_T s;
      real_T totalw;
      if (j >= 27) {
        i = 0;
        b = true;
      } else if (b) {
        b = false;
        i = j % 9 * 3 + j / 9;
      } else {
        i += 3;
        if (i > 26) {
          i -= 26;
        }
      }
      s = 0.0;
      k = b_wls->nstpnts;
      for (::coder::SizeType b_i{2}; b_i <= k; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      if ((iv[i] != 1) || coder::isequal(ws)) {
        totalw = 0.0;
      } else if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
        totalw = b_wls->nevpnts;
        //  Unit weights summed together
      } else {
        ::coder::SizeType iEval_ws;
        //  All weights summed together
        totalw = 0.0;
        iEval_ws = 0;
        k = b_wls->nevpnts;
        for (::coder::SizeType b_i{0}; b_i < k; b_i++) {
          totalw += ws[(iWeight + ws.size(1) * iEval_ws) - 1];
          iEval_ws += ws.size(0) > 1;
        }
        iWeight += iWeight < ws.size(1);
      }
      vdops[j] = totalw - s;
    }
  }
  ndims = b_wls->us.size(1);
  b_wls->V.set_size(vdops.size(0), vdops.size(1));
  loop_ub = vdops.size(1) * vdops.size(0);
  for (i = 0; i < loop_ub; i++) {
    b_wls->V[i] = vdops[i];
  }
  k = vdops.size(1) / b_wls->us.size(1);
  vdops.set_size(b_wls->nstpnts * b_wls->us.size(1), k);
  loop_ub = k * (b_wls->nstpnts * b_wls->us.size(1));
  for (i = 0; i < loop_ub; i++) {
    vdops[i] = 0.0;
  }
  for (::coder::SizeType b_i{0}; b_i < k; b_i++) {
    i = b_wls->nstpnts;
    for (::coder::SizeType p{0}; p < i; p++) {
      for (::coder::SizeType j{0}; j < ndims; j++) {
        vdops[b_i + vdops.size(1) * (p * ndims + j)] =
            b_wls->V[(static_cast<::coder::SizeType>(
                          static_cast<real_T>(ndims) *
                          ((static_cast<real_T>(b_i) + 1.0) - 1.0)) +
                      j) +
                     b_wls->V.size(1) * p];
      }
    }
  }
}

static void b_wls_solve_sys(WlsObject *b_wls, ::coder::array<real_T, 2U> &vdops)
{
  ::coder::SizeType b_loop_ub;
  ::coder::SizeType i;
  ::coder::SizeType loop_ub;
  ::coder::SizeType nRhs;
  ::coder::SizeType nrows;
  ::coder::SizeType nrows_vdops;
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      b_loop_ub = b_wls->QR.size(0);
      for (::coder::SizeType i1{0}; i1 < b_loop_ub; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  loop_ub = b_wls->ncols;
  b_loop_ub = b_wls->nrows;
  if (loop_ub >= b_loop_ub) {
    nrows_vdops = loop_ub;
  } else {
    nrows_vdops = b_loop_ub;
  }
  vdops.set_size(nrows_vdops, nRhs);
  //  Transpose the operator for row-major
  i = nrows_vdops - b_wls->interp0;
  for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (::coder::SizeType k{0}; k < nRhs; k++) {
      for (::coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      i = b_wls->nstpnts;
      for (::coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      vdops[j] = 1.0 - s;
    }
  }
}

static void b_wls_solve_sys(WlsObject *b_wls, const int8_T diff_idx_data[],
                            const ::coder::SizeType diff_idx_size[2],
                            ::coder::array<real_T, 2U> &vdops)
{
  ::coder::SizeType i;
  ::coder::SizeType k;
  ::coder::SizeType loop_ub;
  ::coder::SizeType nRhs;
  ::coder::SizeType nnzops;
  ::coder::SizeType nrows;
  ::coder::SizeType nrows_vdops;
  boolean_T compressed;
  boolean_T exitg1;
  boolean_T y;
  nRhs = b_wls->rhs.size(0);
  compressed = false;
  y = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k <= diff_idx_size[1] - 1)) {
    if (diff_idx_data[k] == 0) {
      y = false;
      exitg1 = true;
    } else {
      k++;
    }
  }
  if (!y) {
    //  Compress wls.rhs
    nnzops = 0;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      y = false;
      k = 0;
      exitg1 = false;
      while ((!exitg1) && (k <= diff_idx_size[1] - 1)) {
        if (diff_idx_data[k] != 0) {
          y = true;
          exitg1 = true;
        } else {
          k++;
        }
      }
      if (y) {
        nnzops++;
        if (compressed) {
          i = b_wls->rhs.size(1);
          for (k = 0; k < i; k++) {
            b_wls->rhs[k + b_wls->rhs.size(1) * (nnzops - 1)] =
                b_wls->rhs[k + b_wls->rhs.size(1) * j];
          }
        }
      } else {
        compressed = true;
      }
    }
  } else {
    nnzops = b_wls->rhs.size(0);
  }
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      k = b_wls->QR.size(0);
      for (::coder::SizeType i1{0}; i1 < k; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  }
  k = b_wls->ncols;
  loop_ub = b_wls->nrows;
  if (k >= loop_ub) {
    nrows_vdops = k;
  } else {
    nrows_vdops = loop_ub;
  }
  vdops.set_size(nrows_vdops, nRhs);
  if (compressed) {
    vdops.set_size(nrows_vdops, nRhs);
    loop_ub = nRhs * nrows_vdops;
    for (i = 0; i < loop_ub; i++) {
      vdops[i] = 0.0;
    }
    //  Compress wls.rhs
    nnzops = -1;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      y = false;
      k = 0;
      exitg1 = false;
      while ((!exitg1) && (k <= diff_idx_size[1] - 1)) {
        if (diff_idx_data[k] != 0) {
          y = true;
          exitg1 = true;
        } else {
          k++;
        }
      }
      if (y) {
        nnzops++;
        i = nrows_vdops - b_wls->interp0;
        for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
          vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
              b_wls->rhs[b_i + b_wls->rhs.size(1) * nnzops];
        }
      }
    }
  } else {
    //  Transpose the operator for row-major
    i = nrows_vdops - b_wls->interp0;
    for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
      for (::coder::SizeType j{0}; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (k = 0; k < nRhs; k++) {
      for (::coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      i = b_wls->nstpnts;
      for (::coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      vdops[j] = 0.0 - s;
    }
  }
}

static void b_wls_solve_sys(WlsObject *b_wls, const int8_T diff_idx_data[],
                            ::coder::SizeType diff_idx_size,
                            ::coder::array<real_T, 2U> &vdops)
{
  ::coder::SizeType i;
  ::coder::SizeType k;
  ::coder::SizeType loop_ub;
  ::coder::SizeType nRhs;
  ::coder::SizeType nnzops;
  ::coder::SizeType nrows;
  ::coder::SizeType nrows_vdops;
  boolean_T exitg1;
  boolean_T y;
  nRhs = b_wls->rhs.size(0) - 1;
  y = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k <= diff_idx_size - 1)) {
    if (diff_idx_data[k] == 0) {
      y = false;
      exitg1 = true;
    } else {
      k++;
    }
  }
  if (!y) {
    //  Compress wls.rhs
    nnzops = 0;
    for (::coder::SizeType j{0}; j <= nRhs; j++) {
      nnzops++;
    }
  } else {
    nnzops = b_wls->rhs.size(0);
  }
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    k = b_wls->QR.size(1);
    for (i = 0; i < k; i++) {
      loop_ub = b_wls->QR.size(0);
      for (::coder::SizeType i1{0}; i1 < loop_ub; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  }
  k = b_wls->ncols;
  loop_ub = b_wls->nrows;
  if (k >= loop_ub) {
    nrows_vdops = k;
  } else {
    nrows_vdops = loop_ub;
  }
  vdops.set_size(nrows_vdops, nRhs + 1);
  //  Transpose the operator for row-major
  i = nrows_vdops - b_wls->interp0;
  for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (::coder::SizeType j{0}; j <= nRhs; j++) {
      vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (k = 0; k <= nRhs; k++) {
      for (::coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    for (::coder::SizeType j{0}; j <= nRhs; j++) {
      real_T s;
      s = 0.0;
      i = b_wls->nstpnts;
      for (::coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      vdops[j] = 0.0 - s;
    }
  }
}

static void b_wls_update_rhs(WlsObject *b_wls, const int8_T diff_idx_data[],
                             const ::coder::SizeType diff_idx_size[2])
{
  ::coder::SizeType nevpnts;
  ::coder::SizeType u0;
  ::coder::SizeType u1;
  nevpnts = b_wls->nevpnts;
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(1, u0);
  for (u1 = 0; u1 < u0; u1++) {
    b_wls->rhs[u1] = 0.0;
  }
  //  Summing up rows in the differential operator
  u1 = diff_idx_size[1];
  for (::coder::SizeType jDiff{0}; jDiff < u1; jDiff++) {
    ::coder::SizeType offset;
    //  Loop through the operators
    offset = (diff_idx_data[jDiff] - 1) * b_wls->us.size(0);
    //  Sum up monomials weighted by weights for each component
    u0 = b_wls->ncols - b_wls->interp0;
    for (::coder::SizeType iMonomial{0}; iMonomial < u0; iMonomial++) {
      ::coder::SizeType j;
      j = b_wls->jpvt[iMonomial] + b_wls->interp0;
      for (::coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
        b_wls->rhs[iMonomial] =
            b_wls->rhs[iMonomial] +
            b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
      }
    }
  }
}

static void b_wls_update_rhs(WlsObject *b_wls,
                             const ::coder::array<real_T, 2U> &ws)
{
  ::coder::SizeType nevpnts;
  ::coder::SizeType u0;
  ::coder::SizeType u1;
  nevpnts = b_wls->nevpnts - 1;
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(9, u0);
  u0 *= 9;
  for (u1 = 0; u1 < u0; u1++) {
    b_wls->rhs[u1] = 0.0;
  }
  if (!coder::isequal(ws)) {
    ::coder::SizeType iWeight;
    ::coder::SizeType lenWs;
    ::coder::SizeType stride;
    if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
      lenWs = 1;
    } else {
      lenWs = ws.size(1);
    }
    stride = b_wls->us.size(0);
    //  Summing up rows in the differential operator
    iWeight = 0;
    for (::coder::SizeType jDiff{0}; jDiff < 3; jDiff++) {
      //  Loop through the operators
      for (::coder::SizeType iOp{0}; iOp < 9; iOp++) {
        int8_T i;
        //  Skip padded zeros in the differential operator
        i = iv[jDiff + 3 * iOp];
        if (i > 0) {
          ::coder::SizeType offset;
          offset = (i - 1) * stride;
          //  Sum up monomials weighted by weights for each component
          u1 = b_wls->ncols - b_wls->interp0;
          for (::coder::SizeType iMonomial{0}; iMonomial < u1; iMonomial++) {
            ::coder::SizeType j;
            j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
            if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
              for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                    b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                    b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
              }
            } else {
              ::coder::SizeType iEval_ws;
              iEval_ws = 0;
              for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                    b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                    ws[iWeight + ws.size(1) * iEval_ws] *
                        b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
                iEval_ws += ws.size(0) > 1;
              }
            }
          }
        } else if (i < 0) {
          ::coder::SizeType offset;
          offset = (-i - 1) * stride;
          //  Sum up monomials weighted by weights for each component
          u1 = b_wls->ncols - b_wls->interp0;
          for (::coder::SizeType iMonomial{0}; iMonomial < u1; iMonomial++) {
            ::coder::SizeType j;
            j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
            if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
              for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                    b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] -
                    b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
              }
            } else {
              ::coder::SizeType iEval_ws;
              iEval_ws = 0;
              for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                    b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] -
                    ws[iWeight + ws.size(1) * iEval_ws] *
                        b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
                iEval_ws += ws.size(0) > 1;
              }
            }
          }
        }
        if (iWeight + 1 == lenWs) {
          iWeight = 0;
        } else {
          iWeight++;
        }
      }
    }
  }
}

static void b_wls_update_rhs(WlsObject *b_wls, const int8_T diff_idx_data[],
                             const ::coder::SizeType diff_idx_size[2],
                             const ::coder::array<real_T, 2U> &ws)
{
  ::coder::SizeType nevpnts;
  nevpnts = b_wls->nevpnts - 1;
  if (!coder::isequal(ws)) {
    ::coder::SizeType i;
    ::coder::SizeType iWeight;
    ::coder::SizeType lenWs;
    if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
      lenWs = 1;
    } else {
      lenWs = ws.size(1);
    }
    //  Summing up rows in the differential operator
    iWeight = 1;
    i = diff_idx_size[1];
    for (::coder::SizeType jDiff{0}; jDiff < i; jDiff++) {
      ::coder::SizeType i1;
      ::coder::SizeType offset;
      //  Loop through the operators
      offset = (diff_idx_data[jDiff] - 1) * b_wls->us.size(0);
      //  Sum up monomials weighted by weights for each component
      i1 = b_wls->ncols - b_wls->interp0;
      for (::coder::SizeType iMonomial{0}; iMonomial < i1; iMonomial++) {
        ::coder::SizeType j;
        j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
        if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
          for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
            b_wls->rhs[iMonomial] =
                b_wls->rhs[iMonomial] +
                b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
          }
        } else {
          ::coder::SizeType iEval_ws;
          iEval_ws = 0;
          for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
            b_wls->rhs[iMonomial] =
                b_wls->rhs[iMonomial] +
                ws[(iWeight + ws.size(1) * iEval_ws) - 1] *
                    b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            iEval_ws += ws.size(0) > 1;
          }
        }
      }
      if (iWeight == lenWs) {
        iWeight = 1;
      } else {
        iWeight++;
      }
    }
  }
}

static void b_wls_update_rhs(WlsObject *b_wls)
{
  ::coder::SizeType nevpnts_tmp;
  ::coder::SizeType u0;
  ::coder::SizeType u1;
  nevpnts_tmp = b_wls->nevpnts;
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  b_wls->rhs.set_size(nevpnts_tmp, u1 - b_wls->interp0);
  //  Summing up rows in the differential operator
  u0 = b_wls->ncols - b_wls->interp0;
  for (::coder::SizeType iMonomial{0}; iMonomial < u0; iMonomial++) {
    ::coder::SizeType j;
    j = b_wls->jpvt[iMonomial] + b_wls->interp0;
    //  Do not sum if nargin<3
    for (::coder::SizeType iEval{0}; iEval < nevpnts_tmp; iEval++) {
      b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iEval] =
          b_wls->V[iEval + b_wls->V.size(1) * (j - 1)];
    }
  }
}

static void b_wls_update_rhs(WlsObject *b_wls, const int8_T diff_idx_data[],
                             ::coder::SizeType diff_idx_size)
{
  ::coder::SizeType nevpnts;
  ::coder::SizeType u0;
  ::coder::SizeType u1;
  nevpnts = b_wls->nevpnts;
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(diff_idx_size, u0);
  u0 *= diff_idx_size;
  for (u1 = 0; u1 < u0; u1++) {
    b_wls->rhs[u1] = 0.0;
  }
  //  Summing up rows in the differential operator
  for (::coder::SizeType iOp{0}; iOp < diff_idx_size; iOp++) {
    ::coder::SizeType offset;
    //  Skip padded zeros in the differential operator
    offset = (diff_idx_data[iOp] - 1) * b_wls->us.size(0);
    //  Sum up monomials weighted by weights for each component
    u1 = b_wls->ncols - b_wls->interp0;
    for (::coder::SizeType iMonomial{0}; iMonomial < u1; iMonomial++) {
      ::coder::SizeType j;
      j = b_wls->jpvt[iMonomial] + b_wls->interp0;
      for (::coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
        b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
            b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
      }
    }
  }
}

static void b_wls_var_cdr(WlsObject *b_wls,
                          const ::coder::array<real_T, 2U> &eval_pnts,
                          ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType lap_size[2];
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  int8_T lap_data[3];
  nevpnts = eval_pnts.size(0);
  //  The operators are row vectors, so they will be summed up before solve
  switch (b_wls->us.size(1)) {
  case 1:
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    break;
  case 2:
    lap_size[1] = 2;
    lap_size[0] = 1;
    lap_data[0] = 4;
    lap_data[1] = 5;
    break;
  default:
    lap_size[1] = 3;
    lap_size[0] = 1;
    lap_data[0] = 5;
    lap_data[1] = 6;
    lap_data[2] = 7;
    break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  h_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv,
               b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  e_wls_update_rhs(b_wls, lap_data, lap_size);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, vdops);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

static void b_wls_var_uno(WlsObject *b_wls,
                          const ::coder::array<real_T, 2U> &eval_pnts,
                          ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType func_size[2];
  ::coder::SizeType grad_div_size;
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  int8_T func_data[9];
  int8_T grad_div_data[9];
  nevpnts = eval_pnts.size(0);
  //  The rows in the operators will be summed up before for each point
  switch (b_wls->us.size(1)) {
  case 1:
    grad_div_size = 1;
    grad_div_data[0] = 3;
    func_size[1] = 1;
    func_size[0] = 1;
    func_data[0] = 1;
    break;
  case 2:
    grad_div_size = 4;
    grad_div_data[0] = 4;
    grad_div_data[1] = 5;
    grad_div_data[2] = 5;
    grad_div_data[3] = 6;
    func_size[1] = 2;
    func_size[0] = 2;
    func_data[0] = 1;
    func_data[1] = 0;
    func_data[2] = 0;
    func_data[3] = 1;
    break;
  default: {
    int8_T b_I[9];
    grad_div_size = 9;
    for (::coder::SizeType i{0}; i < 9; i++) {
      grad_div_data[i] = iv5[i];
      b_I[i] = 0;
    }
    b_I[0] = 1;
    b_I[4] = 1;
    b_I[8] = 1;
    func_size[1] = 3;
    func_size[0] = 3;
    for (::coder::SizeType i{0}; i < 9; i++) {
      func_data[i] = b_I[i];
    }
  } break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  g_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv,
               b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  b_wls_update_rhs(b_wls, grad_div_data, grad_div_size);
  //  grad-div
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, func_data, func_size, vdops);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

static void c_gen_vander(const ::coder::array<real_T, 2U> &us,
                         ::coder::SizeType npoints, ::coder::SizeType degree,
                         ::coder::SizeType order,
                         const ::coder::array<real_T, 1U> &weights,
                         boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  switch (us.size(1)) {
  case 1: {
    ::coder::SizeType V_tmp;
    ::coder::SizeType i;
    ::coder::SizeType i1;
    ::coder::SizeType nrblks;
    ::coder::SizeType r;
    ::coder::SizeType stride;
    boolean_T b;
    boolean_T b1;
    m2cAssert(us.size(1) == 1, "");
    //  Handle input arguments
    m2cAssert(npoints <= us.size(0), "Input us is too small.");
    m2cAssert(degree >= 0, "Degree must be nonnegative");
    if ((order < -4) || (order == -3)) {
      m2cErrMsgIdAndTxt("wlslib:WrongOrder",
                        "Order %d must be 0, 1, 2, -1, -2, or -4", (int)order);
    }
    stride = us.size(0);
    nrblks = order + 1;
    //  Number of row blocks
    switch (order) {
    case -1:
      nrblks = 2;
      break;
    case -2:
      nrblks = 3;
      break;
    case -4:
      nrblks = 4;
      break;
    }
    V.set_size(degree + 1, us.size(0) * nrblks);
    //  Compute rows corresponding to function values
    if (weights.size(0) == 0) {
      if (degree != 0) {
        b = true;
        b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
        i = us.size(1) * us.size(0);
        V_tmp = 0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          if (b1 || (iPnt >= i)) {
            V_tmp = 0;
            b = true;
          } else if (b) {
            b = false;
            V_tmp = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (V_tmp > MAX_int32_T - us.size(1)) {
              V_tmp = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
            } else {
              V_tmp += us.size(1);
              if (V_tmp > i1) {
                V_tmp -= i1;
              }
            }
          }
          V[iPnt] = 1.0;
          V[iPnt + V.size(1)] = us[V_tmp];
        }
      } else {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt] = 1.0;
        }
      }
    } else if (degree != 0) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      i = us.size(1) * us.size(0);
      V_tmp = 0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        if (b1 || (iPnt >= i)) {
          V_tmp = 0;
          b = true;
        } else if (b) {
          b = false;
          V_tmp = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          i1 = us.size(1) * us.size(0) - 1;
          if (V_tmp > MAX_int32_T - us.size(1)) {
            V_tmp = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            V_tmp += us.size(1);
            if (V_tmp > i1) {
              V_tmp -= i1;
            }
          }
        }
        V[iPnt] = weights[iPnt];
        V[iPnt + V.size(1)] = us[V_tmp] * weights[iPnt];
      }
    } else {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt] = weights[iPnt];
      }
    }
    i = degree + 1;
    for (::coder::SizeType ii{2}; ii <= i; ii++) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      V_tmp = us.size(1) * us.size(0);
      i1 = 0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        if (b1 || (iPnt >= V_tmp)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          ::coder::SizeType i2;
          i2 = us.size(1) * us.size(0) - 1;
          if (i1 > MAX_int32_T - us.size(1)) {
            i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i1 += us.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        V[iPnt + V.size(1) * (ii - 1)] =
            V[iPnt + V.size(1) * (ii - 2)] * us[i1];
      }
    }
    //  Add row blocks corresponding to kth derivatives
    r = us.size(0);
    if (order >= 0) {
      for (::coder::SizeType k{0}; k < order; k++) {
        for (::coder::SizeType j{0}; j <= k; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(r + iPnt) + V.size(1) * j] = 0.0;
          }
        }
        for (::coder::SizeType j{k + 1}; j <= degree; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V_tmp = r + iPnt;
            V[V_tmp + V.size(1) * j] =
                V[(V_tmp - stride) + V.size(1) * (j - 1)] *
                static_cast<real_T>(j);
          }
        }
        r += stride;
      }
    } else {
      //      computing negative orders
      if (-order > 2) {
        i = 2;
      } else {
        i = -order;
      }
      for (::coder::SizeType k{0}; k < i; k++) {
        for (::coder::SizeType j{0}; j <= k; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(r + iPnt) + V.size(1) * j] = 0.0;
          }
        }
        for (::coder::SizeType j{k + 1}; j <= degree; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V_tmp = r + iPnt;
            V[V_tmp + V.size(1) * j] =
                V[(V_tmp - stride) + V.size(1) * (j - 1)] *
                static_cast<real_T>(j);
          }
        }
        r += stride;
      }
      //      Calculate Biharmonic if order = -4
      if (order == -4) {
        for (::coder::SizeType j{0}; j < 4; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(r + iPnt) + V.size(1) * j] = 0.0;
          }
        }
        for (::coder::SizeType j{2}; j <= degree; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V_tmp = r + iPnt;
            V[V_tmp + V.size(1) * j] =
                V[(V_tmp - stride) + V.size(1) * (j - 2)] *
                static_cast<real_T>(j) * (static_cast<real_T>(j) - 1.0);
          }
        }
      }
    }
  } break;
  case 2:
    c_gen_vander_2d(us, npoints, degree, order, weights, unimono, V);
    break;
  default:
    c_gen_vander_3d(us, npoints, degree, order, weights, unimono, V);
    break;
  }
}

static void c_gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                            ::coder::SizeType npoints, ::coder::SizeType degree,
                            ::coder::SizeType order,
                            const ::coder::array<real_T, 1U> &weights,
                            boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  ::coder::SizeType c;
  ::coder::SizeType deg;
  ::coder::SizeType i;
  ::coder::SizeType nrblks;
  ::coder::SizeType ret;
  ::coder::SizeType stride;
  if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if ((order < -4) || (order == -3)) {
    m2cErrMsgIdAndTxt("wlslib:WrongOrder",
                      "Order %d must be 0, 1, 2, -1, -2, or -4", (int)order);
  }
  stride = us.size(0);
  if (unimono) {
    if ((order < -2) || (order > 1)) {
      m2cErrMsgIdAndTxt(
          "wlslib:WrongOrder",
          "For axes-aligned monomials, derivatives cannot have cross terms.");
    }
    if (degree >= 0) {
      degree = -degree;
    }
  }
  nrblks = (order + 1) * (order + 2) / 2;
  //  Number of row blocks
  switch (order) {
  case -1:
    nrblks = 3;
    break;
  case -2:
    nrblks = 5;
    break;
  case -4:
    if (degree > 0) {
      nrblks = 8;
    } else {
      nrblks = 11;
    }
    break;
  }
  if (degree >= 0) {
    ret = (degree + 1) * (degree + 2) / 2;
    unimono = false;
  } else if (unimono) {
    ret = 1 - (degree << 1);
  } else {
    ret = (1 - degree) * (1 - degree);
  }
  //  Allocate storage for V
  V.set_size(ret, us.size(0) * nrblks);
  //  compute 0th order generalized Vandermonde matrix
  if (weights.size(0) == 0) {
    if (degree != 0) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt] = 1.0;
        V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
        V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
      }
    } else {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt] = 1.0;
      }
    }
  } else if (degree != 0) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = weights[iPnt];
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt] * weights[iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1] * weights[iPnt];
    }
  } else {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = weights[iPnt];
    }
  }
  c = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType j{0}; j < deg; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - deg) - 1)] * us[us.size(1) * iPnt + 1];
      }
      c++;
    }
    //  Compute the bi-degree terms if degree<0
    i = -degree;
    for (deg = i; deg >= 1; deg--) {
      for (::coder::SizeType k{0}; k < deg; k++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
        }
        c++;
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 2)] * us[us.size(1) * iPnt];
        V[iPnt + V.size(1) * (c + 1)] =
            V[iPnt + V.size(1) * (c - 1)] * us[us.size(1) * iPnt + 1];
      }
      c += 2;
    }
  }
  //  compute higher order confluent Vandermonde matrix blocks incrementally
  if (order != 0) {
    real_T scaleu;
    real_T scalev;
    ::coder::SizeType offset;
    //  This is an optimized version of update_vander_ordern for first-order CVM
    m2cAssert(degree != 0, "");
    //  Compute derivative with respect to u
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[stride + iPnt] = 0.0;
      V[(stride + iPnt) + V.size(1)] = V[iPnt];
      V[(stride + iPnt) + V.size(1) * 2] = 0.0;
    }
    c = 3;
    if (!unimono) {
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      for (deg = 2; deg <= i; deg++) {
        scaleu = deg;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * static_cast<real_T>(deg);
        }
        c++;
        for (::coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu--;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - deg)] * scaleu;
          }
          c++;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      //  Compute the bi-degree terms if degree<0
      i = -degree;
      for (::coder::SizeType len{i}; len >= 0; len--) {
        scaleu = 1 - degree;
        for (::coder::SizeType k{0}; k < len; k++) {
          scaleu--;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - len)] * scaleu;
          }
          c++;
        }
      }
    } else {
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      for (deg = 2; deg <= i; deg++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - 2)] * static_cast<real_T>(deg);
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
      }
    }
    //  Compute derivative with respect to v
    offset = us.size(0) + us.size(0);
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      ret = offset + iPnt;
      V[ret] = 0.0;
      V[ret + V.size(1)] = 0.0;
      V[ret + V.size(1) * 2] = V[iPnt];
    }
    c = 3;
    if (!unimono) {
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      for (deg = 2; deg <= i; deg++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        for (::coder::SizeType j{0}; j < deg; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * ((c - deg) - 1)] *
                (static_cast<real_T>(j) + 1.0);
          }
          c++;
        }
      }
      //  Compute the bi-degree terms if degree<0
      ret = -degree;
      deg = -degree;
      for (::coder::SizeType len{ret}; len >= 0; len--) {
        deg++;
        scalev = (deg + degree) - 1;
        for (::coder::SizeType k{0}; k < len; k++) {
          scalev++;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * ((c - len) - 1)] * scalev;
          }
          c++;
        }
      }
    } else {
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      for (deg = 2; deg <= i; deg++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 1)] =
              V[iPnt + V.size(1) * (c - 1)] * static_cast<real_T>(deg);
        }
        c += 2;
      }
    }
    //      compute regular orders if order > 0
    if (order > 0) {
      for (::coder::SizeType dd{2}; dd <= order; dd++) {
        ::coder::SizeType i1;
        ::coder::SizeType i2;
        ::coder::SizeType offset_prev;
        ::coder::SizeType offset_tmp_tmp;
        //  Compute order-N CVM row blocks from order-(N-1) CVM.
        m2cAssert(degree != 0, "");
        offset_tmp_tmp = dd * (dd + 1) / 2;
        offset = offset_tmp_tmp * stride;
        offset_prev = (dd - 1) * dd / 2 * stride;
        //  Compute derivative with respect to u
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        i1 = -degree;
        for (::coder::SizeType b_i{0}; b_i < dd; b_i++) {
          //  Initialize block to zero
          i2 = offset + 1;
          ret = offset + npoints;
          for (::coder::SizeType col{0}; col < offset_tmp_tmp; col++) {
            for (::coder::SizeType row{i2}; row <= ret; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = offset_tmp_tmp;
          for (deg = dd; deg <= i; deg++) {
            scaleu = deg + 1;
            i2 = deg - 1;
            for (::coder::SizeType j{0}; j <= i2; j++) {
              scaleu--;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
              }
              c++;
            }
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          //  Compute the bi-degree terms if degree<0
          for (::coder::SizeType len{i1}; len >= 0; len--) {
            scaleu = 1 - degree;
            for (::coder::SizeType k{0}; k < len; k++) {
              scaleu--;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
              }
              c++;
            }
          }
          offset += stride;
          offset_prev += stride;
        }
        //  Compute derivative with respect to v
        i = offset + 1;
        i2 = offset + npoints;
        for (::coder::SizeType col{0}; col < offset_tmp_tmp; col++) {
          for (::coder::SizeType row{i}; row <= i2; row++) {
            V[(row + V.size(1) * col) - 1] = 0.0;
          }
        }
        c = offset_tmp_tmp;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = dd; deg <= i; deg++) {
          i2 = dd - 1;
          for (::coder::SizeType j{0}; j <= i2; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType j{dd}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[((offset_prev - stride) + iPnt) +
                    V.size(1) * ((c - deg) - 1)] *
                  static_cast<real_T>(j);
            }
            c++;
          }
        }
        //  Compute the bi-degree terms if degree<0
        deg = -degree;
        for (::coder::SizeType len{i1}; len >= 0; len--) {
          deg++;
          scalev = (deg + degree) - 1;
          for (::coder::SizeType k{0}; k < len; k++) {
            scalev++;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[((offset_prev - stride) + iPnt) +
                    V.size(1) * ((c - len) - 1)] *
                  scalev;
            }
            c++;
          }
        }
      }
    } else if (order < -1) {
      //          compute efficient laplacian and bi-laplacian
      switch (order) {
      case -2: {
        ::coder::SizeType i1;
        ::coder::SizeType offset_prev;
        //  Compute order-N CVM row blocks from order-(N-1) CVM.
        m2cAssert(degree != 0, "");
        offset = 3 * us.size(0);
        offset_prev = us.size(0);
        //  Compute derivative with respect to u
        i = offset + 1;
        i1 = offset + npoints;
        for (::coder::SizeType col{0}; col < 3; col++) {
          for (::coder::SizeType row{i}; row <= i1; row++) {
            V[(row + V.size(1) * col) - 1] = 0.0;
          }
        }
        c = 3;
        if (!unimono) {
          if (degree < 0) {
            i = -degree;
          } else {
            i = degree;
          }
          for (deg = 2; deg <= i; deg++) {
            scaleu = deg + 1;
            i1 = deg - 1;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              scaleu--;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
              }
              c++;
            }
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          //  Compute the bi-degree terms if degree<0
          i = -degree;
          for (::coder::SizeType len{i}; len >= 0; len--) {
            scaleu = 1 - degree;
            for (::coder::SizeType k{0}; k < len; k++) {
              scaleu--;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
              }
              c++;
            }
          }
        } else {
          if (degree < 0) {
            i = -degree;
          } else {
            i = degree;
          }
          for (deg = 2; deg <= i; deg++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(offset_prev + iPnt) + V.size(1) * (c - 2)] *
                  static_cast<real_T>(deg);
            }
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
            }
            c += 2;
          }
        }
        offset += us.size(0);
        offset_prev = us.size(0) + us.size(0);
        //  Compute derivative with respect to v
        if (!unimono) {
          offset_prev += us.size(0);
        }
        i = offset + 1;
        i1 = offset + npoints;
        for (::coder::SizeType col{0}; col < 3; col++) {
          for (::coder::SizeType row{i}; row <= i1; row++) {
            V[(row + V.size(1) * col) - 1] = 0.0;
          }
        }
        c = 3;
        if (!unimono) {
          if (degree < 0) {
            i = -degree;
          } else {
            i = degree;
          }
          for (deg = 2; deg <= i; deg++) {
            for (::coder::SizeType j{0}; j < 2; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            for (::coder::SizeType j{2}; j <= deg; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - deg) - 1)] *
                    static_cast<real_T>(j);
              }
              c++;
            }
          }
          //  Compute the bi-degree terms if degree<0
          ret = -degree;
          deg = -degree;
          for (::coder::SizeType len{ret}; len >= 0; len--) {
            deg++;
            scalev = (deg + degree) - 1;
            for (::coder::SizeType k{0}; k < len; k++) {
              scalev++;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - len) - 1)] *
                    scalev;
              }
              c++;
            }
          }
        } else {
          if (degree < 0) {
            i = -degree;
          } else {
            i = degree;
          }
          for (deg = 2; deg <= i; deg++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * (c + 1)] =
                  V[(offset_prev + iPnt) + V.size(1) * (c - 1)] *
                  static_cast<real_T>(deg);
            }
            c += 2;
          }
        }
      } break;
      case -4: {
        if (degree > 0) {
          ::coder::SizeType i1;
          ::coder::SizeType offset_prev;
          //  Compute order-N CVM row blocks from order-(N-1) CVM.
          m2cAssert(true, "");
          offset = 3 * us.size(0);
          //  Compute derivative with respect to u
          i = offset + 1;
          i1 = offset + npoints;
          for (::coder::SizeType col{0}; col < 3; col++) {
            for (::coder::SizeType row{i}; row <= i1; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 3;
          for (deg = 2; deg <= degree; deg++) {
            scaleu = deg + 1;
            i = deg - 1;
            for (::coder::SizeType j{0}; j <= i; j++) {
              scaleu--;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(us.size(0) + iPnt) + V.size(1) * (c - deg)] * scaleu;
              }
              c++;
            }
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          //  Compute the bi-degree terms if degree<0
          offset += us.size(0);
          //  Compute derivative with respect to v
          offset_prev = (us.size(0) + us.size(0)) + us.size(0);
          i = offset + 1;
          i1 = offset + npoints;
          for (::coder::SizeType col{0}; col < 3; col++) {
            for (::coder::SizeType row{i}; row <= i1; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 3;
          for (deg = 2; deg <= degree; deg++) {
            for (::coder::SizeType j{0}; j < 2; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            for (::coder::SizeType j{2}; j <= deg; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - deg) - 1)] *
                    static_cast<real_T>(j);
              }
              c++;
            }
          }
          //  Compute the bi-degree terms if degree<0
          offset = 5 * us.size(0);
          offset_prev = 3 * us.size(0);
          m2cAssert(degree >= 4, "");
          //  compute du^4 and du^2*dv^2
          for (::coder::SizeType terms{0}; terms < 2; terms++) {
            i = offset + 1;
            i1 = offset + npoints;
            for (::coder::SizeType col{0}; col < 10; col++) {
              for (::coder::SizeType row{i}; row <= i1; row++) {
                V[(row + V.size(1) * col) - 1] = 0.0;
              }
            }
            c = 10;
            for (deg = 4; deg <= degree; deg++) {
              scaleu = deg + 1;
              i = deg - 1;
              for (::coder::SizeType j{0}; j <= i; j++) {
                scaleu--;
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(offset + iPnt) + V.size(1) * c] =
                      V[(offset_prev + iPnt) +
                        V.size(1) * ((c - (deg << 1)) + 1)] *
                      scaleu * (scaleu - 1.0);
                }
                c++;
              }
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            offset += stride;
            offset_prev += stride;
          }
          //  compute dv^4
          i = offset + 1;
          i1 = offset + npoints;
          for (::coder::SizeType col{0}; col < 10; col++) {
            for (::coder::SizeType row{i}; row <= i1; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 10;
          for (deg = 4; deg <= degree; deg++) {
            for (::coder::SizeType j{0}; j < 4; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            for (::coder::SizeType j{4}; j <= deg; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - (deg << 1)) - 1)] *
                    static_cast<real_T>(j) * (static_cast<real_T>(j) - 1.0);
              }
              c++;
            }
          }
        } else {
          ::coder::SizeType i1;
          ::coder::SizeType i2;
          ::coder::SizeType offset_prev;
          //  Compute order-N CVM row blocks from order-(N-1) CVM.
          m2cAssert(degree != 0, "");
          offset = 3 * us.size(0);
          offset_prev = us.size(0);
          //  Compute derivative with respect to u
          if (degree < 0) {
            i = -degree;
          } else {
            i = 0;
          }
          i1 = -degree;
          //  Initialize block to zero
          i2 = offset + 1;
          ret = offset + npoints;
          for (::coder::SizeType col{0}; col < 3; col++) {
            for (::coder::SizeType row{i2}; row <= ret; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 3;
          for (deg = 2; deg <= i; deg++) {
            scaleu = deg + 1;
            i2 = deg - 1;
            for (::coder::SizeType j{0}; j <= i2; j++) {
              scaleu--;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
              }
              c++;
            }
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          //  Compute the bi-degree terms if degree<0
          for (::coder::SizeType len{i1}; len >= 0; len--) {
            scaleu = 1 - degree;
            for (::coder::SizeType k{0}; k < len; k++) {
              scaleu--;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
              }
              c++;
            }
          }
          offset += us.size(0);
          //  Compute derivative with respect to v
          offset_prev = (us.size(0) + us.size(0)) + us.size(0);
          i = offset + 1;
          i2 = offset + npoints;
          for (::coder::SizeType col{0}; col < 3; col++) {
            for (::coder::SizeType row{i}; row <= i2; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 3;
          if (degree < 0) {
            i = -degree;
          } else {
            i = 0;
          }
          for (deg = 2; deg <= i; deg++) {
            for (::coder::SizeType j{0}; j < 2; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            for (::coder::SizeType j{2}; j <= deg; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - deg) - 1)] *
                    static_cast<real_T>(j);
              }
              c++;
            }
          }
          //  Compute the bi-degree terms if degree<0
          deg = -degree;
          for (::coder::SizeType len{i1}; len >= 0; len--) {
            deg++;
            scalev = (deg + degree) - 1;
            for (::coder::SizeType k{0}; k < len; k++) {
              scalev++;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - len) - 1)] *
                    scalev;
              }
              c++;
            }
          }
          //  Compute order-N CVM row blocks from order-(N-1) CVM.
          m2cAssert(degree != 0, "");
          offset = 5 * us.size(0);
          offset_prev = 3 * us.size(0);
          //  Compute derivative with respect to u
          if (degree < 0) {
            i = -degree;
          } else {
            i = 0;
          }
          for (::coder::SizeType b_i{0}; b_i < 2; b_i++) {
            //  Initialize block to zero
            i2 = offset + 1;
            ret = offset + npoints;
            for (::coder::SizeType col{0}; col < 6; col++) {
              for (::coder::SizeType row{i2}; row <= ret; row++) {
                V[(row + V.size(1) * col) - 1] = 0.0;
              }
            }
            c = 6;
            for (deg = 3; deg <= i; deg++) {
              scaleu = deg + 1;
              i2 = deg - 1;
              for (::coder::SizeType j{0}; j <= i2; j++) {
                scaleu--;
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(offset + iPnt) + V.size(1) * c] =
                      V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
                }
                c++;
              }
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            //  Compute the bi-degree terms if degree<0
            for (::coder::SizeType len{i1}; len >= 0; len--) {
              scaleu = 1 - degree;
              for (::coder::SizeType k{0}; k < len; k++) {
                scaleu--;
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(offset + iPnt) + V.size(1) * c] =
                      V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
                }
                c++;
              }
            }
            offset += stride;
            offset_prev += stride;
          }
          //  Compute derivative with respect to v
          i = offset + 1;
          i2 = offset + npoints;
          for (::coder::SizeType col{0}; col < 6; col++) {
            for (::coder::SizeType row{i}; row <= i2; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 6;
          if (degree < 0) {
            i = -degree;
          } else {
            i = 0;
          }
          for (deg = 3; deg <= i; deg++) {
            for (::coder::SizeType j{0}; j < 3; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            for (::coder::SizeType j{3}; j <= deg; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - deg) - 1)] *
                    static_cast<real_T>(j);
              }
              c++;
            }
          }
          //  Compute the bi-degree terms if degree<0
          deg = -degree;
          for (::coder::SizeType len{i1}; len >= 0; len--) {
            deg++;
            scalev = (deg + degree) - 1;
            for (::coder::SizeType k{0}; k < len; k++) {
              scalev++;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - len) - 1)] *
                    scalev;
              }
              c++;
            }
          }
          //  Compute order-N CVM row blocks from order-(N-1) CVM.
          m2cAssert(degree != 0, "");
          offset = us.size(0) << 3;
          offset_prev = 5 * us.size(0);
          //  Compute derivative with respect to u
          if (degree < 0) {
            i = -degree;
          } else {
            i = 0;
          }
          for (::coder::SizeType b_i{0}; b_i < 2; b_i++) {
            //  Initialize block to zero
            i2 = offset + 1;
            ret = offset + npoints;
            for (::coder::SizeType col{0}; col < 10; col++) {
              for (::coder::SizeType row{i2}; row <= ret; row++) {
                V[(row + V.size(1) * col) - 1] = 0.0;
              }
            }
            c = 10;
            for (deg = 4; deg <= i; deg++) {
              scaleu = deg + 1;
              i2 = deg - 1;
              for (::coder::SizeType j{0}; j <= i2; j++) {
                scaleu--;
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(offset + iPnt) + V.size(1) * c] =
                      V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
                }
                c++;
              }
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            //  Compute the bi-degree terms if degree<0
            for (::coder::SizeType len{i1}; len >= 0; len--) {
              scaleu = 1 - degree;
              for (::coder::SizeType k{0}; k < len; k++) {
                scaleu--;
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(offset + iPnt) + V.size(1) * c] =
                      V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
                }
                c++;
              }
            }
            offset += stride;
            offset_prev += stride;
          }
          //  Compute derivative with respect to v
          offset_prev += us.size(0);
          i = offset + 1;
          i2 = offset + npoints;
          for (::coder::SizeType col{0}; col < 10; col++) {
            for (::coder::SizeType row{i}; row <= i2; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 10;
          if (degree < 0) {
            i = -degree;
          } else {
            i = 0;
          }
          for (deg = 4; deg <= i; deg++) {
            for (::coder::SizeType j{0}; j < 4; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            for (::coder::SizeType j{4}; j <= deg; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - deg) - 1)] *
                    static_cast<real_T>(j);
              }
              c++;
            }
          }
          //  Compute the bi-degree terms if degree<0
          deg = -degree;
          for (::coder::SizeType len{i1}; len >= 0; len--) {
            deg++;
            scalev = (deg + degree) - 1;
            for (::coder::SizeType k{0}; k < len; k++) {
              scalev++;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - len) - 1)] *
                    scalev;
              }
              c++;
            }
          }
        }
      } break;
      default:
        m2cAssert(false, "Order must be 0, 1, 2, -1, -2, or -4");
        break;
      }
    }
  }
}

static void c_gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                            ::coder::SizeType npoints, ::coder::SizeType degree,
                            ::coder::SizeType order,
                            const ::coder::array<real_T, 1U> &weights,
                            boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  ::coder::SizeType c;
  ::coder::SizeType cornerTriangle;
  ::coder::SizeType counterBottomRow;
  ::coder::SizeType d;
  ::coder::SizeType deg;
  ::coder::SizeType excess;
  ::coder::SizeType i;
  ::coder::SizeType i1;
  ::coder::SizeType maxLayers;
  ::coder::SizeType nTermsInLayer;
  ::coder::SizeType nTermsInPrevLayer;
  ::coder::SizeType nrblks;
  ::coder::SizeType ret;
  ::coder::SizeType stride;
  if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if ((order < -4) || (order == -3)) {
    m2cErrMsgIdAndTxt("wlslib:WrongOrder",
                      "Order %d must be 0, 1, 2, -1, -2, or -4", (int)order);
  }
  stride = us.size(0);
  if (unimono) {
    if ((order < -2) || (order > 1)) {
      m2cErrMsgIdAndTxt(
          "wlslib:WrongOrder",
          "For axes-aligned monomials, derivatives cannot have cross terms.");
    }
    if (degree >= 0) {
      degree = -degree;
    }
  }
  nrblks = (order + 1) * (order + 2) * (order + 3) / 6;
  switch (order) {
  case -1:
    nrblks = 4;
    break;
  case -2:
    nrblks = 7;
    break;
  case -4:
    if (degree > 0) {
      nrblks = 13;
    } else {
      nrblks = 19;
    }
    break;
  }
  if (degree >= 0) {
    ret = (degree + 1) * (degree + 2) * (degree + 3) / 6;
    unimono = false;
  } else if (unimono) {
    ret = 1 - 3 * degree;
  } else {
    ret = (1 - degree) * (1 - degree) * (1 - degree);
  }
  //  Allocate storage for V
  V.set_size(ret, us.size(0) * nrblks);
  //  compute 0th order generalized Vandermonde matrix
  if (weights.size(0) == 0) {
    if (degree != 0) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt] = 1.0;
        V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
        V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
        V[iPnt + V.size(1) * 3] = us[us.size(1) * iPnt + 2];
      }
    } else {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt] = 1.0;
      }
    }
  } else if (degree != 0) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = weights[iPnt];
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt] * weights[iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1] * weights[iPnt];
      V[iPnt + V.size(1) * 3] = us[us.size(1) * iPnt + 2] * weights[iPnt];
    }
  } else {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = weights[iPnt];
    }
  }
  c = 4;
  d = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      //  Within each level, use convention of Pascal triangle with x^deg at
      for (::coder::SizeType j{0}; j < deg; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * us[us.size(1) * iPnt];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - d) - 1)] * us[us.size(1) * iPnt + 1];
      }
      c++;
      for (::coder::SizeType j{0}; j < d; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
              us[us.size(1) * iPnt + 2];
        }
        c++;
      }
      d = (d + deg) + 1;
    }
    //  Compute the tri-degree terms if degree<0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        ::coder::SizeType gap;
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 1;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType k{0}; k < deg; k++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[iPnt + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - nTermsInLayer)] *
                us[us.size(1) * iPnt + 1];
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        ret = ((degree + degree) + p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer;
        nTermsInLayer = d + 3 * (excess - cornerTriangle);
        gap = (nTermsInPrevLayer + counterBottomRow) - 1;
        i1 = nTermsInLayer - counterBottomRow;
        for (::coder::SizeType j{0}; j <= i1; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[iPnt + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - gap)] * us[us.size(1) * iPnt + 2];
          }
          c++;
        }
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 3)] * us[us.size(1) * iPnt];
        V[iPnt + V.size(1) * (c + 1)] =
            V[iPnt + V.size(1) * (c - 2)] * us[us.size(1) * iPnt + 1];
        V[iPnt + V.size(1) * (c + 2)] =
            V[iPnt + V.size(1) * (c - 1)] * us[us.size(1) * iPnt + 2];
      }
      c += 3;
    }
  }
  m2cAssert(order <= 2, "");
  if (order != 0) {
    //      compute higher order confluent Vandermonde matrix blocks
    switch (order) {
    case 1: {
      ::coder::SizeType balance;
      ::coder::SizeType offset;
      //  Compute order-1 CVM row blocks from order-0 GVM.
      m2cAssert(degree != 0, "");
      // compute derivatives with respect to u
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[stride + iPnt] = 0.0;
        V[(stride + iPnt) + V.size(1)] = V[iPnt];
        V[(stride + iPnt) + V.size(1) * 2] = 0.0;
        V[(stride + iPnt) + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 3;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          real_T scaleu;
          scaleu = deg;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * static_cast<real_T>(deg);
          }
          c++;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            scaleu--;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (c - d)] * scaleu;
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] = 0.0;
          }
          for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * (c + 1)] =
                  V[(stride + iPnt) + V.size(1) * ((c - d) - deg)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
          }
          c += 2;
          d = (d + deg) + 1;
        }
        // tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 1;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(stride + iPnt) + V.size(1) * c] =
                    V[(stride + iPnt) + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt + 1];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = (nTermsInPrevLayer + counterBottomRow) - 1;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(stride + iPnt) + V.size(1) * c] =
                    V[(stride + iPnt) + V.size(1) * (c - balance)] *
                    us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - 3)] * static_cast<real_T>(deg);
          }
          c += 3;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c - 2)] = 0.0;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c - 1)] = 0.0;
          }
        }
      }
      // compute derivatives with respect to v
      offset = us.size(0) + us.size(0);
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = 0.0;
        V[ret + V.size(1) * 2] = V[iPnt];
        V[ret + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 4;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          real_T scalev;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = 1.0;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (c - d)] * scalev;
            }
            scalev++;
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * static_cast<real_T>(deg);
          }
          c++;
          for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] = V[ret + V.size(1) * ((c - d) - deg)] *
                                       us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] =
                    V[ret + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] = 0.0;
            V[ret + V.size(1) * (c + 1)] =
                V[iPnt + V.size(1) * (c - 2)] * static_cast<real_T>(deg);
            V[ret + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
      // compute derivatives with respect to w
      offset += us.size(0);
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = 0.0;
        V[ret + V.size(1) * 2] = 0.0;
        V[ret + V.size(1) * 3] = V[iPnt];
      }
      c = 4;
      d = 3;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
                    (static_cast<real_T>(k) + 1.0);
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            ::coder::SizeType degg;
            ::coder::SizeType x_tmp;
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ::coder::SizeType partition;
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[iPnt + V.size(1) * (c - balance)] *
                      static_cast<real_T>(k + 1);
                }
                c++;
              }
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] =
                V[iPnt + V.size(1) * (c - 1)] * static_cast<real_T>(deg);
            V[ret + V.size(1) * (c + 1)] = 0.0;
            V[ret + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
    } break;
    case 2: {
      real_T scaleu;
      real_T scalev;
      ::coder::SizeType balance;
      ::coder::SizeType degg;
      ::coder::SizeType offset;
      ::coder::SizeType partition;
      ::coder::SizeType x_tmp;
      //  Compute order-1 CVM row blocks from order-0 GVM.
      m2cAssert(degree != 0, "");
      // compute derivatives with respect to u
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[stride + iPnt] = 0.0;
        V[(stride + iPnt) + V.size(1)] = V[iPnt];
        V[(stride + iPnt) + V.size(1) * 2] = 0.0;
        V[(stride + iPnt) + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 3;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          scaleu = deg;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * static_cast<real_T>(deg);
          }
          c++;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            scaleu--;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (c - d)] * scaleu;
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] = 0.0;
          }
          for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * (c + 1)] =
                  V[(stride + iPnt) + V.size(1) * ((c - d) - deg)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
          }
          c += 2;
          d = (d + deg) + 1;
        }
        // tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 1;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(stride + iPnt) + V.size(1) * c] =
                    V[(stride + iPnt) + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt + 1];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = (nTermsInPrevLayer + counterBottomRow) - 1;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(stride + iPnt) + V.size(1) * c] =
                    V[(stride + iPnt) + V.size(1) * (c - balance)] *
                    us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - 3)] * static_cast<real_T>(deg);
          }
          c += 3;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c - 2)] = 0.0;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c - 1)] = 0.0;
          }
        }
      }
      // compute derivatives with respect to v
      offset = us.size(0) + us.size(0);
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = 0.0;
        V[ret + V.size(1) * 2] = V[iPnt];
        V[ret + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 4;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = 1.0;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (c - d)] * scalev;
            }
            scalev++;
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * static_cast<real_T>(deg);
          }
          c++;
          for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] = V[ret + V.size(1) * ((c - d) - deg)] *
                                       us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] =
                    V[ret + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] = 0.0;
            V[ret + V.size(1) * (c + 1)] =
                V[iPnt + V.size(1) * (c - 2)] * static_cast<real_T>(deg);
            V[ret + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
      // compute derivatives with respect to w
      offset += us.size(0);
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = 0.0;
        V[ret + V.size(1) * 2] = 0.0;
        V[ret + V.size(1) * 3] = V[iPnt];
      }
      c = 4;
      d = 3;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
                    (static_cast<real_T>(k) + 1.0);
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[iPnt + V.size(1) * (c - balance)] *
                      static_cast<real_T>(k + 1);
                }
                c++;
              }
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] =
                V[iPnt + V.size(1) * (c - 1)] * static_cast<real_T>(deg);
            V[ret + V.size(1) * (c + 1)] = 0.0;
            V[ret + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
      //  compute du^2
      offset = us.size(0) << 2;
      if (!unimono) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          V[ret] = 0.0;
          V[ret + V.size(1)] = 0.0;
          V[ret + V.size(1) * 2] = 0.0;
          V[ret + V.size(1) * 3] = 0.0;
          V[(offset + iPnt) + V.size(1) * 4] = 2.0 * V[iPnt];
          for (i = 0; i < 5; i++) {
            V[ret + V.size(1) * (i + 5)] = 0.0;
          }
        }
        c = 10;
        d = 6;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          scaleu = deg;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] *
                static_cast<real_T>(deg);
          }
          c++;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            scaleu--;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * (c + 1)] =
                  V[ret + V.size(1) * ((c - d) - deg)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
          }
          c += 2;
          d = (d + deg) + 1;
        }
        // compute tri degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 1;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] =
                    V[ret + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt + 1];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = (nTermsInPrevLayer + counterBottomRow) - 1;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        c = 4;
        for (::coder::SizeType col{0}; col < 4; col++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * col] = 0.0;
          }
        }
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * c] = V[(iPnt + stride) + V.size(1) * (c - 3)] *
                                     static_cast<real_T>(deg);
            V[ret + V.size(1) * (c + 1)] = 0.0;
            V[(offset + iPnt) + V.size(1) * (c + 2)] = 0.0;
          }
          c += 3;
        }
      }
      if (order > 0) {
        //      compute du*dv
        offset += us.size(0);
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          for (i = 0; i < 5; i++) {
            V[ret + V.size(1) * i] = 0.0;
          }
          V[ret + V.size(1) * 5] = V[iPnt];
          V[ret + V.size(1) * 6] = 0.0;
          V[ret + V.size(1) * 7] = 0.0;
          V[ret + V.size(1) * 8] = 0.0;
          V[ret + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 7;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = 1.0;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + stride) + V.size(1) * (c - d)] * scalev;
            }
            scalev++;
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] *
                static_cast<real_T>(deg);
          }
          c++;
          for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] = V[ret + V.size(1) * ((c - d) - deg)] *
                                       us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  implicitly calculating number of elements in corner Pascal
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((stride << 1) + iPnt) +
                      V.size(1) * (c - nTermsInLayer)] *
                    static_cast<real_T>(-degree - kdegree);
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      }
      //  compute dv^2
      offset += us.size(0);
      if (!unimono) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          for (i = 0; i < 6; i++) {
            V[ret + V.size(1) * i] = 0.0;
          }
          V[ret + V.size(1) * 6] = 2.0 * V[iPnt];
          V[ret + V.size(1) * 7] = 0.0;
          V[ret + V.size(1) * 8] = 0.0;
          V[ret + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 7;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = 1.0;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + (stride << 1)) + V.size(1) * (c - d)] * scalev;
            }
            scalev++;
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[((stride << 1) + iPnt) + V.size(1) * (c - d)] *
                static_cast<real_T>(deg);
          }
          c++;
          for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] = V[ret + V.size(1) * ((c - d) - deg)] *
                                       us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] =
                    V[ret + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        c = 4;
        for (::coder::SizeType col{0}; col < 5; col++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * col] = 0.0;
          }
        }
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 1)] =
                V[(iPnt + (stride << 1)) + V.size(1) * (c - 2)] *
                static_cast<real_T>(deg);
            V[ret + V.size(1) * (c + 2)] = 0.0;
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
      if (order > 0) {
        //      compute du*dw
        offset = (offset + us.size(0)) - 1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = (offset + iPnt) + 1;
          for (i = 0; i < 7; i++) {
            V[ret + V.size(1) * i] = 0.0;
          }
          V[ret + V.size(1) * 7] = V[iPnt];
          V[ret + V.size(1) * 8] = 0.0;
          V[ret + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] =
                    V[(iPnt + stride) + V.size(1) * (((c - d) - deg) - 1)] *
                    (static_cast<real_T>(k) + 1.0);
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i1 = 1 - degree;
          for (::coder::SizeType p{i1}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[((iPnt + offset) + V.size(1) * c) + 1] =
                      V[(iPnt + stride) + V.size(1) * (c - balance)] *
                      static_cast<real_T>(k + 1);
                }
                c++;
              }
            }
          }
        }
        //      compute dv*dw
        offset = (offset + us.size(0)) + 1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          for (i1 = 0; i1 < 8; i1++) {
            V[ret + V.size(1) * i1] = 0.0;
          }
          V[ret + V.size(1) * 8] = V[iPnt];
          V[ret + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(iPnt + (stride << 1)) +
                      V.size(1) * (((c - d) - deg) - 1)] *
                    (static_cast<real_T>(k) + 1.0);
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[(iPnt + (stride << 1)) + V.size(1) * (c - balance)] *
                      static_cast<real_T>(k + 1);
                }
                c++;
              }
            }
          }
        }
      }
      //  compute dw^2
      offset += us.size(0);
      if (!unimono) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          for (i = 0; i < 9; i++) {
            V[ret + V.size(1) * i] = 0.0;
          }
          V[ret + V.size(1) * 9] = 2.0 * V[iPnt];
        }
        c = 10;
        d = 6;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(iPnt + 3 * stride) + V.size(1) * (((c - d) - deg) - 1)] *
                    (static_cast<real_T>(k) + 1.0);
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[(iPnt + 3 * stride) + V.size(1) * (c - balance)] *
                      static_cast<real_T>(k + 1);
                }
                c++;
              }
            }
          }
        }
      } else {
        c = 4;
        for (::coder::SizeType col{0}; col < 6; col++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * col] = 0.0;
          }
        }
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] =
                V[(iPnt + 3 * stride) + V.size(1) * (c - 1)] *
                static_cast<real_T>(deg);
            V[ret + V.size(1) * (c + 1)] = 0.0;
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
    } break;
    case -1: {
      ::coder::SizeType balance;
      ::coder::SizeType offset;
      //  Compute order-1 CVM row blocks from order-0 GVM.
      m2cAssert(degree != 0, "");
      // compute derivatives with respect to u
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[stride + iPnt] = 0.0;
        V[(stride + iPnt) + V.size(1)] = V[iPnt];
        V[(stride + iPnt) + V.size(1) * 2] = 0.0;
        V[(stride + iPnt) + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 3;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          real_T scaleu;
          scaleu = deg;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * static_cast<real_T>(deg);
          }
          c++;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            scaleu--;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (c - d)] * scaleu;
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] = 0.0;
          }
          for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * (c + 1)] =
                  V[(stride + iPnt) + V.size(1) * ((c - d) - deg)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
          }
          c += 2;
          d = (d + deg) + 1;
        }
        // tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 1;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(stride + iPnt) + V.size(1) * c] =
                    V[(stride + iPnt) + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt + 1];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = (nTermsInPrevLayer + counterBottomRow) - 1;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(stride + iPnt) + V.size(1) * c] =
                    V[(stride + iPnt) + V.size(1) * (c - balance)] *
                    us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - 3)] * static_cast<real_T>(deg);
          }
          c += 3;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c - 2)] = 0.0;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c - 1)] = 0.0;
          }
        }
      }
      // compute derivatives with respect to v
      offset = us.size(0) + us.size(0);
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = 0.0;
        V[ret + V.size(1) * 2] = V[iPnt];
        V[ret + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 4;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          real_T scalev;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = 1.0;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (c - d)] * scalev;
            }
            scalev++;
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * static_cast<real_T>(deg);
          }
          c++;
          for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] = V[ret + V.size(1) * ((c - d) - deg)] *
                                       us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] =
                    V[ret + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] = 0.0;
            V[ret + V.size(1) * (c + 1)] =
                V[iPnt + V.size(1) * (c - 2)] * static_cast<real_T>(deg);
            V[ret + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
      // compute derivatives with respect to w
      offset += us.size(0);
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = 0.0;
        V[ret + V.size(1) * 2] = 0.0;
        V[ret + V.size(1) * 3] = V[iPnt];
      }
      c = 4;
      d = 3;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
                    (static_cast<real_T>(k) + 1.0);
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            ::coder::SizeType degg;
            ::coder::SizeType x_tmp;
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ::coder::SizeType partition;
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[iPnt + V.size(1) * (c - balance)] *
                      static_cast<real_T>(k + 1);
                }
                c++;
              }
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] =
                V[iPnt + V.size(1) * (c - 1)] * static_cast<real_T>(deg);
            V[ret + V.size(1) * (c + 1)] = 0.0;
            V[ret + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
    } break;
    case -2: {
      real_T scaleu;
      real_T scalev;
      ::coder::SizeType balance;
      ::coder::SizeType degg;
      ::coder::SizeType offset;
      ::coder::SizeType partition;
      ::coder::SizeType x_tmp;
      //  Compute order-1 CVM row blocks from order-0 GVM.
      m2cAssert(degree != 0, "");
      // compute derivatives with respect to u
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[stride + iPnt] = 0.0;
        V[(stride + iPnt) + V.size(1)] = V[iPnt];
        V[(stride + iPnt) + V.size(1) * 2] = 0.0;
        V[(stride + iPnt) + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 3;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          scaleu = deg;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * static_cast<real_T>(deg);
          }
          c++;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            scaleu--;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (c - d)] * scaleu;
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] = 0.0;
          }
          for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * (c + 1)] =
                  V[(stride + iPnt) + V.size(1) * ((c - d) - deg)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
          }
          c += 2;
          d = (d + deg) + 1;
        }
        // tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 1;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(stride + iPnt) + V.size(1) * c] =
                    V[(stride + iPnt) + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt + 1];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = (nTermsInPrevLayer + counterBottomRow) - 1;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(stride + iPnt) + V.size(1) * c] =
                    V[(stride + iPnt) + V.size(1) * (c - balance)] *
                    us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - 3)] * static_cast<real_T>(deg);
          }
          c += 3;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c - 2)] = 0.0;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c - 1)] = 0.0;
          }
        }
      }
      // compute derivatives with respect to v
      offset = us.size(0) + us.size(0);
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = 0.0;
        V[ret + V.size(1) * 2] = V[iPnt];
        V[ret + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 4;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = 1.0;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (c - d)] * scalev;
            }
            scalev++;
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * static_cast<real_T>(deg);
          }
          c++;
          for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] = V[ret + V.size(1) * ((c - d) - deg)] *
                                       us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] =
                    V[ret + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] = 0.0;
            V[ret + V.size(1) * (c + 1)] =
                V[iPnt + V.size(1) * (c - 2)] * static_cast<real_T>(deg);
            V[ret + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
      // compute derivatives with respect to w
      offset += us.size(0);
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = 0.0;
        V[ret + V.size(1) * 2] = 0.0;
        V[ret + V.size(1) * 3] = V[iPnt];
      }
      c = 4;
      d = 3;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
                    (static_cast<real_T>(k) + 1.0);
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[iPnt + V.size(1) * (c - balance)] *
                      static_cast<real_T>(k + 1);
                }
                c++;
              }
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] =
                V[iPnt + V.size(1) * (c - 1)] * static_cast<real_T>(deg);
            V[ret + V.size(1) * (c + 1)] = 0.0;
            V[ret + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
      //  compute du^2
      offset = us.size(0) << 2;
      if (!unimono) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          V[ret] = 0.0;
          V[ret + V.size(1)] = 0.0;
          V[ret + V.size(1) * 2] = 0.0;
          V[ret + V.size(1) * 3] = 0.0;
          V[(offset + iPnt) + V.size(1) * 4] = 2.0 * V[iPnt];
          for (i = 0; i < 5; i++) {
            V[ret + V.size(1) * (i + 5)] = 0.0;
          }
        }
        c = 10;
        d = 6;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          scaleu = deg;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] *
                static_cast<real_T>(deg);
          }
          c++;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            scaleu--;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * (c + 1)] =
                  V[ret + V.size(1) * ((c - d) - deg)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
          }
          c += 2;
          d = (d + deg) + 1;
        }
        // compute tri degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 1;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] =
                    V[ret + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt + 1];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = (nTermsInPrevLayer + counterBottomRow) - 1;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        c = 4;
        for (::coder::SizeType col{0}; col < 4; col++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * col] = 0.0;
          }
        }
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * c] = V[(iPnt + stride) + V.size(1) * (c - 3)] *
                                     static_cast<real_T>(deg);
            V[ret + V.size(1) * (c + 1)] = 0.0;
            V[(offset + iPnt) + V.size(1) * (c + 2)] = 0.0;
          }
          c += 3;
        }
      }
      if (order > 0) {
        //      compute du*dv
        offset += us.size(0);
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          for (i = 0; i < 5; i++) {
            V[ret + V.size(1) * i] = 0.0;
          }
          V[ret + V.size(1) * 5] = V[iPnt];
          V[ret + V.size(1) * 6] = 0.0;
          V[ret + V.size(1) * 7] = 0.0;
          V[ret + V.size(1) * 8] = 0.0;
          V[ret + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 7;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = 1.0;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + stride) + V.size(1) * (c - d)] * scalev;
            }
            scalev++;
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] *
                static_cast<real_T>(deg);
          }
          c++;
          for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] = V[ret + V.size(1) * ((c - d) - deg)] *
                                       us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  implicitly calculating number of elements in corner Pascal
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((stride << 1) + iPnt) +
                      V.size(1) * (c - nTermsInLayer)] *
                    static_cast<real_T>(-degree - kdegree);
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      }
      //  compute dv^2
      offset += us.size(0);
      if (!unimono) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          for (i = 0; i < 6; i++) {
            V[ret + V.size(1) * i] = 0.0;
          }
          V[ret + V.size(1) * 6] = 2.0 * V[iPnt];
          V[ret + V.size(1) * 7] = 0.0;
          V[ret + V.size(1) * 8] = 0.0;
          V[ret + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 7;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = 1.0;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + (stride << 1)) + V.size(1) * (c - d)] * scalev;
            }
            scalev++;
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[((stride << 1) + iPnt) + V.size(1) * (c - d)] *
                static_cast<real_T>(deg);
          }
          c++;
          for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] = V[ret + V.size(1) * ((c - d) - deg)] *
                                       us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] =
                    V[ret + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        c = 4;
        for (::coder::SizeType col{0}; col < 5; col++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * col] = 0.0;
          }
        }
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 1)] =
                V[(iPnt + (stride << 1)) + V.size(1) * (c - 2)] *
                static_cast<real_T>(deg);
            V[ret + V.size(1) * (c + 2)] = 0.0;
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
      if (order > 0) {
        //      compute du*dw
        offset = (offset + us.size(0)) - 1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = (offset + iPnt) + 1;
          for (i = 0; i < 7; i++) {
            V[ret + V.size(1) * i] = 0.0;
          }
          V[ret + V.size(1) * 7] = V[iPnt];
          V[ret + V.size(1) * 8] = 0.0;
          V[ret + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] =
                    V[(iPnt + stride) + V.size(1) * (((c - d) - deg) - 1)] *
                    (static_cast<real_T>(k) + 1.0);
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i1 = 1 - degree;
          for (::coder::SizeType p{i1}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[((iPnt + offset) + V.size(1) * c) + 1] =
                      V[(iPnt + stride) + V.size(1) * (c - balance)] *
                      static_cast<real_T>(k + 1);
                }
                c++;
              }
            }
          }
        }
        //      compute dv*dw
        offset = (offset + us.size(0)) + 1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          for (i1 = 0; i1 < 8; i1++) {
            V[ret + V.size(1) * i1] = 0.0;
          }
          V[ret + V.size(1) * 8] = V[iPnt];
          V[ret + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(iPnt + (stride << 1)) +
                      V.size(1) * (((c - d) - deg) - 1)] *
                    (static_cast<real_T>(k) + 1.0);
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[(iPnt + (stride << 1)) + V.size(1) * (c - balance)] *
                      static_cast<real_T>(k + 1);
                }
                c++;
              }
            }
          }
        }
      }
      //  compute dw^2
      offset += us.size(0);
      if (!unimono) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          for (i = 0; i < 9; i++) {
            V[ret + V.size(1) * i] = 0.0;
          }
          V[ret + V.size(1) * 9] = 2.0 * V[iPnt];
        }
        c = 10;
        d = 6;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(iPnt + 3 * stride) + V.size(1) * (((c - d) - deg) - 1)] *
                    (static_cast<real_T>(k) + 1.0);
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[(iPnt + 3 * stride) + V.size(1) * (c - balance)] *
                      static_cast<real_T>(k + 1);
                }
                c++;
              }
            }
          }
        }
      } else {
        c = 4;
        for (::coder::SizeType col{0}; col < 6; col++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * col] = 0.0;
          }
        }
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] =
                V[(iPnt + 3 * stride) + V.size(1) * (c - 1)] *
                static_cast<real_T>(deg);
            V[ret + V.size(1) * (c + 1)] = 0.0;
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
    } break;
    case -4: {
      real_T scaleu;
      real_T scalev;
      real_T uu4_tmp;
      ::coder::SizeType balance;
      ::coder::SizeType degg;
      ::coder::SizeType offset;
      ::coder::SizeType partition;
      ::coder::SizeType x_tmp;
      m2cAssert(degree > 0, "Biharmonic operator is only supported for "
                            "Pascal-tetrahedral monomials in 3D.");
      //  Compute order-1 CVM row blocks from order-0 GVM.
      m2cAssert(degree != 0, "");
      // compute derivatives with respect to u
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[stride + iPnt] = 0.0;
        V[(stride + iPnt) + V.size(1)] = V[iPnt];
        V[(stride + iPnt) + V.size(1) * 2] = 0.0;
        V[(stride + iPnt) + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 3;
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      for (deg = 2; deg <= i; deg++) {
        scaleu = deg;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * static_cast<real_T>(deg);
        }
        c++;
        for (::coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu--;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scaleu;
          }
          c++;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] = 0.0;
        }
        for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c + 1)] =
                V[(stride + iPnt) + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      // tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (::coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 1;
          // counter for the bottom row to be subtracted later
          for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * c] =
                  V[(stride + iPnt) + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt + 1];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          ret = (((p + degree) << 1) - p) - 1;
          if (ret < 0) {
            ret = 0;
          }
          excess += ret;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = (nTermsInPrevLayer + counterBottomRow) - 1;
          i1 = nTermsInLayer - counterBottomRow;
          for (::coder::SizeType j{0}; j <= i1; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * c] =
                  V[(stride + iPnt) + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to v
      offset = us.size(0) + us.size(0);
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = 0.0;
        V[ret + V.size(1) * 2] = V[iPnt];
        V[ret + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 4;
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      for (deg = 2; deg <= i; deg++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        scalev = 1.0;
        for (::coder::SizeType j{0}; j <= deg - 2; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scalev;
          }
          scalev++;
          c++;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * static_cast<real_T>(deg);
        }
        c++;
        for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * c] = V[ret + V.size(1) * ((c - d) - deg)] *
                                     us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        d = (d + deg) + 1;
      }
      // compute the tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d - 2;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (::coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] =
                  V[ret + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          ret = (((p + degree) << 1) - p) - 1;
          if (ret < 0) {
            ret = 0;
          }
          excess += ret;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer + 1;
          nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
          balance = nTermsInPrevLayer + counterBottomRow;
          i1 = nTermsInLayer - counterBottomRow;
          for (::coder::SizeType j{0}; j <= i1; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                       us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to w
      offset += us.size(0);
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = 0.0;
        V[ret + V.size(1) * 2] = 0.0;
        V[ret + V.size(1) * 3] = V[iPnt];
      }
      c = 4;
      d = 3;
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      for (deg = 2; deg <= i; deg++) {
        for (::coder::SizeType j{0}; j <= deg; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (::coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
                  (static_cast<real_T>(k) + 1.0);
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      // compute tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (::coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (::coder::SizeType k{0}; k < deg; k++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x_tmp = p + degree;
          ret = ((x_tmp << 1) - p) - 1;
          if (ret < 0) {
            ret = 0;
          }
          excess += ret;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = nTermsInPrevLayer + counterBottomRow;
          degg = -degree;
          for (::coder::SizeType k{0}; k < degg; k++) {
            ret = (x_tmp - k) - 1;
            if (ret < 0) {
              ret = -ret;
            }
            partition = -degree - ret;
            for (::coder::SizeType j{0}; j <= partition; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(iPnt + offset) + V.size(1) * c] =
                    V[iPnt + V.size(1) * (c - balance)] *
                    static_cast<real_T>(k + 1);
              }
              c++;
            }
          }
        }
      }
      //  compute du^2
      offset = us.size(0) << 2;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = 0.0;
        V[ret + V.size(1) * 2] = 0.0;
        V[ret + V.size(1) * 3] = 0.0;
        V[ret + V.size(1) * 4] = 2.0 * V[iPnt];
        for (i = 0; i < 5; i++) {
          V[ret + V.size(1) * (i + 5)] = 0.0;
        }
      }
      c = 10;
      d = 6;
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      for (deg = 3; deg <= i; deg++) {
        scaleu = deg;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + stride) + V.size(1) * (c - d)] *
              static_cast<real_T>(deg);
        }
        c++;
        for (::coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu--;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
          }
          c++;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 1)] =
                V[ret + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      // compute tri degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (::coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 1;
          // counter for the bottom row to be subtracted later
          for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] =
                  V[ret + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt + 1];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          ret = (((p + degree) << 1) - p) - 1;
          if (ret < 0) {
            ret = 0;
          }
          excess += ret;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = (nTermsInPrevLayer + counterBottomRow) - 1;
          i1 = nTermsInLayer - counterBottomRow;
          for (::coder::SizeType j{0}; j <= i1; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                       us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      if (order > 0) {
        //      compute du*dv
        offset += us.size(0);
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          for (i = 0; i < 5; i++) {
            V[ret + V.size(1) * i] = 0.0;
          }
          V[ret + V.size(1) * 5] = V[iPnt];
          V[ret + V.size(1) * 6] = 0.0;
          V[ret + V.size(1) * 7] = 0.0;
          V[ret + V.size(1) * 8] = 0.0;
          V[ret + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 7;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = 1.0;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + stride) + V.size(1) * (c - d)] * scalev;
            }
            scalev++;
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] *
                static_cast<real_T>(deg);
          }
          c++;
          for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] = V[ret + V.size(1) * ((c - d) - deg)] *
                                       us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  implicitly calculating number of elements in corner Pascal
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((stride << 1) + iPnt) +
                      V.size(1) * (c - nTermsInLayer)] *
                    static_cast<real_T>(-degree - kdegree);
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      }
      //  compute dv^2
      offset += us.size(0);
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        for (i = 0; i < 6; i++) {
          V[ret + V.size(1) * i] = 0.0;
        }
        V[ret + V.size(1) * 6] = 2.0 * V[iPnt];
        V[ret + V.size(1) * 7] = 0.0;
        V[ret + V.size(1) * 8] = 0.0;
        V[ret + V.size(1) * 9] = 0.0;
      }
      c = 10;
      d = 7;
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      for (deg = 3; deg <= i; deg++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        scalev = 1.0;
        for (::coder::SizeType j{0}; j <= deg - 2; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + (stride << 1)) + V.size(1) * (c - d)] * scalev;
          }
          scalev++;
          c++;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((stride << 1) + iPnt) + V.size(1) * (c - d)] *
              static_cast<real_T>(deg);
        }
        c++;
        for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * c] = V[ret + V.size(1) * ((c - d) - deg)] *
                                     us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        d = (d + deg) + 1;
      }
      // compute the tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d - 2;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (::coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] =
                  V[ret + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          ret = (((p + degree) << 1) - p) - 1;
          if (ret < 0) {
            ret = 0;
          }
          excess += ret;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer + 1;
          nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
          balance = nTermsInPrevLayer + counterBottomRow;
          i1 = nTermsInLayer - counterBottomRow;
          for (::coder::SizeType j{0}; j <= i1; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                       us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      if (order > 0) {
        //      compute du*dw
        offset = (offset + us.size(0)) - 1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = (offset + iPnt) + 1;
          for (i = 0; i < 7; i++) {
            V[ret + V.size(1) * i] = 0.0;
          }
          V[ret + V.size(1) * 7] = V[iPnt];
          V[ret + V.size(1) * 8] = 0.0;
          V[ret + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] =
                    V[(iPnt + stride) + V.size(1) * (((c - d) - deg) - 1)] *
                    (static_cast<real_T>(k) + 1.0);
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i1 = 1 - degree;
          for (::coder::SizeType p{i1}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[((iPnt + offset) + V.size(1) * c) + 1] =
                      V[(iPnt + stride) + V.size(1) * (c - balance)] *
                      static_cast<real_T>(k + 1);
                }
                c++;
              }
            }
          }
        }
        //      compute dv*dw
        offset = (offset + us.size(0)) + 1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          for (i1 = 0; i1 < 8; i1++) {
            V[ret + V.size(1) * i1] = 0.0;
          }
          V[ret + V.size(1) * 8] = V[iPnt];
          V[ret + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(iPnt + (stride << 1)) +
                      V.size(1) * (((c - d) - deg) - 1)] *
                    (static_cast<real_T>(k) + 1.0);
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[(iPnt + (stride << 1)) + V.size(1) * (c - balance)] *
                      static_cast<real_T>(k + 1);
                }
                c++;
              }
            }
          }
        }
      }
      //  compute dw^2
      offset += us.size(0);
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        for (i = 0; i < 9; i++) {
          V[ret + V.size(1) * i] = 0.0;
        }
        V[ret + V.size(1) * 9] = 2.0 * V[iPnt];
      }
      c = 10;
      d = 6;
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      for (deg = 3; deg <= i; deg++) {
        for (::coder::SizeType j{0}; j <= deg; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (::coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + 3 * stride) + V.size(1) * (((c - d) - deg) - 1)] *
                  (static_cast<real_T>(k) + 1.0);
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      // compute tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (::coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (::coder::SizeType k{0}; k < deg; k++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x_tmp = p + degree;
          ret = ((x_tmp << 1) - p) - 1;
          if (ret < 0) {
            ret = 0;
          }
          excess += ret;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = nTermsInPrevLayer + counterBottomRow;
          degg = -degree;
          for (::coder::SizeType k{0}; k < degg; k++) {
            ret = (x_tmp - k) - 1;
            if (ret < 0) {
              ret = -ret;
            }
            partition = -degree - ret;
            for (::coder::SizeType j{0}; j <= partition; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(iPnt + offset) + V.size(1) * c] =
                    V[(iPnt + 3 * stride) + V.size(1) * (c - balance)] *
                    static_cast<real_T>(k + 1);
              }
              c++;
            }
          }
        }
      }
      //  compute du^4
      offset = us.size(0) * 7;
      uu4_tmp = 24.0 * std::pow(1.0, 4.0);
      for (::coder::SizeType b_i{0}; b_i < 35; b_i++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
        }
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * 20] = uu4_tmp * V[iPnt];
      }
      c = 35;
      d = 15;
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      for (deg = 5; deg <= i; deg++) {
        scaleu = deg;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + (stride << 2)) + V.size(1) * ((c - (d << 1)) + deg)] *
              static_cast<real_T>(deg) * (static_cast<real_T>(deg) - 1.0);
        }
        c++;
        for (::coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu--;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + (stride << 2)) + V.size(1) * ((c - (d << 1)) + deg)] *
                scaleu * (scaleu - 1.0);
          }
          c++;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 1)] =
                V[ret + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      //  compute du^2dv^2
      offset = us.size(0) << 3;
      for (::coder::SizeType b_i{0}; b_i < 35; b_i++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
        }
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * 22] = 4.0 * V[iPnt];
      }
      c = 35;
      d = 15;
      for (deg = 5; deg <= i; deg++) {
        scaleu = deg;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + 5 * stride) + V.size(1) * ((c - (d << 1)) + deg)] *
              static_cast<real_T>(deg) * (static_cast<real_T>(deg) - 1.0);
        }
        c++;
        for (::coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu--;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + 5 * stride) + V.size(1) * ((c - (d << 1)) + deg)] *
                scaleu * (scaleu - 1.0);
          }
          c++;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 1)] =
                V[ret + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      //  compute dv^4
      offset = us.size(0) * 9;
      for (::coder::SizeType b_i{0}; b_i < 35; b_i++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
        }
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * 24] = uu4_tmp * V[iPnt];
      }
      c = 34;
      d = 15;
      for (deg = 5; deg <= degree; deg++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        scalev = 1.0;
        for (::coder::SizeType j{0}; j <= deg - 2; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * (c + 2)] =
                V[(iPnt + 5 * stride) + V.size(1) * ((c - (d << 1)) + deg)] *
                scalev * (scalev - 1.0);
          }
          scalev++;
          c++;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 2)] =
              V[(5 * stride + iPnt) + V.size(1) * ((c - (d << 1)) + deg)] *
              static_cast<real_T>(deg) * (static_cast<real_T>(deg) - 1.0);
        }
        c += 3;
        for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * c] =
                V[ret + V.size(1) * (((c - d) - deg) - 1)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        d = (d + deg) + 1;
      }
      //  compute du^2*dw^2
      offset += us.size(0);
      for (::coder::SizeType b_i{0}; b_i < 35; b_i++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
        }
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * 29] = 4.0 * V[iPnt];
      }
      c = 35;
      d = 15;
      for (deg = 5; deg <= i; deg++) {
        for (::coder::SizeType j{0}; j <= deg; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (::coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + (stride << 2)) +
                    V.size(1) * (((c - (d << 1)) - deg) - 1)] *
                  (static_cast<real_T>(k) + 1.0) *
                  ((static_cast<real_T>(k) + 1.0) - 1.0);
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      //  compute dv^2*dw^2
      offset += us.size(0);
      for (::coder::SizeType b_i{0}; b_i < 35; b_i++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
        }
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * 31] = 4.0 * V[iPnt];
      }
      c = 35;
      d = 15;
      for (deg = 5; deg <= i; deg++) {
        for (::coder::SizeType j{0}; j <= deg; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (::coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + 5 * stride) +
                    V.size(1) * (((c - (d << 1)) - deg) - 1)] *
                  (static_cast<real_T>(k) + 1.0) *
                  ((static_cast<real_T>(k) + 1.0) - 1.0);
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      //  compute dw^4
      offset += us.size(0);
      for (::coder::SizeType b_i{0}; b_i < 35; b_i++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
        }
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * 34] = uu4_tmp * V[iPnt];
      }
      c = 35;
      d = 15;
      for (deg = 5; deg <= i; deg++) {
        for (::coder::SizeType j{0}; j <= deg; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (::coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + 6 * stride) +
                    V.size(1) * (((c - (d << 1)) - deg) - 1)] *
                  (static_cast<real_T>(k) + 1.0) *
                  ((static_cast<real_T>(k) + 1.0) - 1.0);
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
    } break;
    default:
      m2cAssert(false, "Order must be 0, 1, 2, -1, -2, or -4.");
      break;
    }
  }
}

static void c_wls_kernel(WlsObject *b_wls,
                         const ::coder::array<real_T, 2U> &eval_pnts,
                         ::coder::SizeType nevpnts,
                         ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  b_gen_vander(b_wls->us, b_nevpnts, b_wls->degree, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  e_wls_update_rhs(b_wls);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  e_wls_solve_sys(b_wls, vdops);
  //  Rearrange vdops using wls.V as work space
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

static void c_wls_solve_sys(WlsObject *b_wls, const int8_T diff_idx_data[],
                            const ::coder::SizeType diff_idx_size[2],
                            ::coder::array<real_T, 2U> &vdops)
{
  ::coder::SizeType b_loop_ub;
  ::coder::SizeType i;
  ::coder::SizeType i1;
  ::coder::SizeType k;
  ::coder::SizeType loop_ub;
  ::coder::SizeType nRhs;
  ::coder::SizeType nnzops;
  ::coder::SizeType nrows;
  ::coder::SizeType nrows_vdops;
  ::coder::SizeType row;
  int8_T tmp_data[9];
  int8_T diff_idx_idx_0;
  boolean_T compressed;
  boolean_T exitg1;
  boolean_T y;
  nRhs = b_wls->rhs.size(0);
  compressed = false;
  diff_idx_idx_0 = static_cast<int8_T>(diff_idx_size[0] * diff_idx_size[1]);
  i = 0;
  i1 = 0;
  for (k = 0; k < diff_idx_idx_0; k++) {
    tmp_data[k] = diff_idx_data[i1 + diff_idx_size[1] * i];
    i++;
    if (i > diff_idx_size[0] - 1) {
      i = 0;
      i1++;
    }
  }
  y = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k <= diff_idx_idx_0 - 1)) {
    if (tmp_data[k] == 0) {
      y = false;
      exitg1 = true;
    } else {
      k++;
    }
  }
  if (!y) {
    //  Compress wls.rhs
    nnzops = 0;
    row = 1;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      y = false;
      k = 0;
      exitg1 = false;
      while ((!exitg1) && (k <= diff_idx_size[1] - 1)) {
        if (diff_idx_data[k + diff_idx_size[1] * (row - 1)] != 0) {
          y = true;
          exitg1 = true;
        } else {
          k++;
        }
      }
      if (y) {
        nnzops++;
        if (compressed) {
          i = b_wls->rhs.size(1);
          for (k = 0; k < i; k++) {
            b_wls->rhs[k + b_wls->rhs.size(1) * (nnzops - 1)] =
                b_wls->rhs[k + b_wls->rhs.size(1) * j];
          }
        }
      } else {
        compressed = true;
      }
      if (row < diff_idx_size[0]) {
        row++;
      } else {
        row = 1;
      }
    }
  } else {
    nnzops = b_wls->rhs.size(0);
  }
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      b_loop_ub = b_wls->QR.size(0);
      for (i1 = 0; i1 < b_loop_ub; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  }
  b_loop_ub = b_wls->ncols;
  k = b_wls->nrows;
  if (b_loop_ub >= k) {
    nrows_vdops = b_loop_ub;
  } else {
    nrows_vdops = k;
  }
  vdops.set_size(nrows_vdops, nRhs);
  if (compressed) {
    vdops.set_size(nrows_vdops, nRhs);
    loop_ub = nRhs * nrows_vdops;
    for (i = 0; i < loop_ub; i++) {
      vdops[i] = 0.0;
    }
    //  Compress wls.rhs
    nnzops = -1;
    row = 1;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      y = false;
      k = 0;
      exitg1 = false;
      while ((!exitg1) && (k <= diff_idx_size[1] - 1)) {
        if (diff_idx_data[k + diff_idx_size[1] * (row - 1)] != 0) {
          y = true;
          exitg1 = true;
        } else {
          k++;
        }
      }
      if (y) {
        nnzops++;
        i = nrows_vdops - b_wls->interp0;
        for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
          vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
              b_wls->rhs[b_i + b_wls->rhs.size(1) * nnzops];
        }
      }
      if (row < diff_idx_size[0]) {
        row++;
      } else {
        row = 1;
      }
    }
  } else {
    //  Transpose the operator for row-major
    i = nrows_vdops - b_wls->interp0;
    for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
      for (::coder::SizeType j{0}; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (k = 0; k < nRhs; k++) {
      for (::coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      i = b_wls->nstpnts;
      for (::coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      vdops[j] = 0.0 - s;
    }
  }
  if ((diff_idx_size[0] > 1) && (diff_idx_size[1] > 1)) {
    ::coder::SizeType ndims;
    ndims = b_wls->us.size(1);
    b_wls->V.set_size(vdops.size(0), vdops.size(1));
    loop_ub = vdops.size(1) * vdops.size(0);
    for (i = 0; i < loop_ub; i++) {
      b_wls->V[i] = vdops[i];
    }
    k = vdops.size(1) / b_wls->us.size(1);
    vdops.set_size(b_wls->nstpnts * b_wls->us.size(1), k);
    loop_ub = k * (b_wls->nstpnts * b_wls->us.size(1));
    for (i = 0; i < loop_ub; i++) {
      vdops[i] = 0.0;
    }
    for (::coder::SizeType b_i{0}; b_i < k; b_i++) {
      i = b_wls->nstpnts;
      for (::coder::SizeType p{0}; p < i; p++) {
        for (::coder::SizeType j{0}; j < ndims; j++) {
          vdops[b_i + vdops.size(1) * (p * ndims + j)] =
              b_wls->V[(static_cast<::coder::SizeType>(
                            static_cast<real_T>(ndims) *
                            ((static_cast<real_T>(b_i) + 1.0) - 1.0)) +
                        j) +
                       b_wls->V.size(1) * p];
        }
      }
    }
  }
}

static void c_wls_solve_sys(WlsObject *b_wls, ::coder::array<real_T, 2U> &vdops)
{
  ::coder::SizeType b_loop_ub;
  ::coder::SizeType i;
  ::coder::SizeType loop_ub;
  ::coder::SizeType nRhs;
  ::coder::SizeType nrows;
  ::coder::SizeType nrows_vdops;
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      b_loop_ub = b_wls->QR.size(0);
      for (::coder::SizeType i1{0}; i1 < b_loop_ub; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  loop_ub = b_wls->ncols;
  b_loop_ub = b_wls->nrows;
  if (loop_ub >= b_loop_ub) {
    nrows_vdops = loop_ub;
  } else {
    nrows_vdops = b_loop_ub;
  }
  vdops.set_size(nrows_vdops, nRhs);
  //  Transpose the operator for row-major
  i = nrows_vdops - b_wls->interp0;
  for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (::coder::SizeType k{0}; k < nRhs; k++) {
      for (::coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      i = b_wls->nstpnts;
      for (::coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      vdops[0] = 0.0 - s;
    }
  }
}

static void c_wls_update_rhs(WlsObject *b_wls, const int8_T diff_idx_data[],
                             ::coder::SizeType diff_idx_size)
{
  ::coder::SizeType nevpnts;
  ::coder::SizeType u0;
  ::coder::SizeType u1;
  nevpnts = b_wls->nevpnts;
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(diff_idx_size, u0);
  u0 *= diff_idx_size;
  for (u1 = 0; u1 < u0; u1++) {
    b_wls->rhs[u1] = 0.0;
  }
  //  Summing up rows in the differential operator
  for (::coder::SizeType iOp{0}; iOp < diff_idx_size; iOp++) {
    ::coder::SizeType offset;
    //  Skip padded zeros in the differential operator
    offset = (diff_idx_data[iOp] - 1) * b_wls->us.size(0);
    //  Sum up monomials weighted by weights for each component
    u1 = b_wls->ncols - b_wls->interp0;
    for (::coder::SizeType iMonomial{0}; iMonomial < u1; iMonomial++) {
      ::coder::SizeType j;
      j = b_wls->jpvt[iMonomial] + b_wls->interp0;
      for (::coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
        b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
            b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
      }
    }
  }
}

static void c_wls_update_rhs(WlsObject *b_wls, const int8_T diff_idx_data[],
                             const ::coder::SizeType diff_idx_size[2])
{
  ::coder::SizeType i;
  ::coder::SizeType nDiff;
  ::coder::SizeType nevpnts;
  ::coder::SizeType stride;
  nevpnts = b_wls->nevpnts - 1;
  nDiff = diff_idx_size[0];
  stride = b_wls->us.size(0);
  //  Summing up rows in the differential operator
  i = diff_idx_size[1];
  for (::coder::SizeType jDiff{0}; jDiff < i; jDiff++) {
    //  Loop through the operators
    for (::coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
      int8_T i1;
      //  Skip padded zeros in the differential operator
      i1 = diff_idx_data[jDiff + diff_idx_size[1] * iOp];
      if (i1 > 0) {
        ::coder::SizeType i2;
        ::coder::SizeType offset;
        offset = (i1 - 1) * stride;
        //  Sum up monomials weighted by weights for each component
        i2 = b_wls->ncols - b_wls->interp0;
        for (::coder::SizeType iMonomial{0}; iMonomial < i2; iMonomial++) {
          ::coder::SizeType j;
          j = b_wls->jpvt[iMonomial] + b_wls->interp0;
          for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                -b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
          }
        }
      } else if (i1 < 0) {
        ::coder::SizeType i2;
        ::coder::SizeType offset;
        offset = (static_cast<int8_T>(-i1) - 1) * stride;
        //  Sum up monomials weighted by weights for each component
        i2 = b_wls->ncols - b_wls->interp0;
        for (::coder::SizeType iMonomial{0}; iMonomial < i2; iMonomial++) {
          ::coder::SizeType j;
          j = b_wls->jpvt[iMonomial] + b_wls->interp0;
          for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] -
                (-b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)]);
          }
        }
      }
    }
  }
}

static void c_wls_update_rhs(WlsObject *b_wls)
{
  ::coder::SizeType u0;
  ::coder::SizeType u1;
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(1, u0);
  for (u1 = 0; u1 < u0; u1++) {
    b_wls->rhs[u1] = 0.0;
  }
}

static void c_wls_update_rhs(WlsObject *b_wls, const int8_T diff_idx_data[],
                             const ::coder::SizeType diff_idx_size[2],
                             const ::coder::array<real_T, 2U> &ws)
{
  ::coder::SizeType nDiff;
  ::coder::SizeType nevpnts;
  ::coder::SizeType u0;
  ::coder::SizeType u1;
  nevpnts = b_wls->nevpnts - 1;
  nDiff = diff_idx_size[0];
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(diff_idx_size[0], u0);
  u0 *= diff_idx_size[0];
  for (u1 = 0; u1 < u0; u1++) {
    b_wls->rhs[u1] = 0.0;
  }
  if (!coder::isequal(ws)) {
    ::coder::SizeType iWeight;
    ::coder::SizeType lenWs;
    if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
      lenWs = 1;
    } else {
      lenWs = ws.size(1);
    }
    //  Summing up rows in the differential operator
    iWeight = 1;
    u1 = diff_idx_size[1];
    for (::coder::SizeType jDiff{0}; jDiff < u1; jDiff++) {
      //  Loop through the operators
      for (::coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
        int8_T i;
        //  Skip padded zeros in the differential operator
        i = diff_idx_data[jDiff + diff_idx_size[1] * iOp];
        if (i > 0) {
          ::coder::SizeType offset;
          offset = (i - 1) * b_wls->us.size(0);
          //  Sum up monomials weighted by weights for each component
          u0 = b_wls->ncols - b_wls->interp0;
          for (::coder::SizeType iMonomial{0}; iMonomial < u0; iMonomial++) {
            ::coder::SizeType j;
            j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
            if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
              for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                    b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                    b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
              }
            } else {
              ::coder::SizeType iEval_ws;
              iEval_ws = 0;
              for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                    b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                    ws[(iWeight + ws.size(1) * iEval_ws) - 1] *
                        b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
                iEval_ws += ws.size(0) > 1;
              }
            }
          }
        }
        if (iWeight == lenWs) {
          iWeight = 1;
        } else {
          iWeight++;
        }
      }
    }
  }
}

static void c_wls_update_rhs(WlsObject *b_wls,
                             const ::coder::array<real_T, 2U> &ws)
{
  ::coder::SizeType nevpnts;
  ::coder::SizeType u0;
  ::coder::SizeType u1;
  nevpnts = b_wls->nevpnts - 1;
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(1, u0);
  for (u1 = 0; u1 < u0; u1++) {
    b_wls->rhs[u1] = 0.0;
  }
  if (!coder::isequal(ws)) {
    //  Summing up rows in the differential operator
    u1 = b_wls->ncols - b_wls->interp0;
    for (::coder::SizeType iMonomial{0}; iMonomial < u1; iMonomial++) {
      ::coder::SizeType j;
      j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
      if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
        for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial] =
              b_wls->rhs[iMonomial] + b_wls->V[iEval + b_wls->V.size(1) * j];
        }
      } else {
        ::coder::SizeType iEval_ws;
        iEval_ws = 0;
        for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial] = b_wls->rhs[iMonomial] +
                                  ws[ws.size(1) * iEval_ws] *
                                      b_wls->V[iEval + b_wls->V.size(1) * j];
          iEval_ws += ws.size(0) > 1;
        }
      }
    }
  }
}

namespace coder {
static boolean_T isequal(const ::coder::array<real_T, 1U> &varargin_1)
{
  boolean_T p;
  p = varargin_1.size(0) == 1;
  if (p && (varargin_1.size(0) != 0)) {
    ::coder::SizeType k;
    boolean_T exitg1;
    p = true;
    k = 0;
    exitg1 = false;
    while ((!exitg1) && (k <= varargin_1.size(0) - 1)) {
      if (varargin_1[0] != 0.0) {
        p = false;
        exitg1 = true;
      } else {
        k++;
      }
    }
  }
  return p;
}

static boolean_T isequal(const ::coder::array<real_T, 2U> &varargin_1)
{
  boolean_T p;
  p = false;
  if ((varargin_1.size(0) == 1) && (varargin_1.size(1) == 1)) {
    p = true;
  }
  if (p && ((varargin_1.size(0) != 0) && (varargin_1.size(1) != 0))) {
    ::coder::SizeType k;
    boolean_T exitg1;
    p = true;
    k = 0;
    exitg1 = false;
    while ((!exitg1) && (k <= varargin_1.size(0) - 1)) {
      ::coder::SizeType b_k;
      boolean_T exitg2;
      b_k = 0;
      exitg2 = false;
      while ((!exitg2) && (b_k <= varargin_1.size(1) - 1)) {
        if (varargin_1[0] != 0.0) {
          p = false;
          exitg2 = true;
        } else {
          b_k++;
        }
      }
      if (!p) {
        exitg1 = true;
      } else {
        k++;
      }
    }
  }
  return p;
}

} // namespace coder
static void d_gen_vander(const ::coder::array<real_T, 2U> &us,
                         ::coder::SizeType degree,
                         ::coder::array<real_T, 2U> &V)
{
  switch (us.size(1)) {
  case 1: {
    ::coder::SizeType i;
    m2cAssert(us.size(1) == 1, "");
    //  Handle input arguments
    //  Number of row blocks
    V.set_size(degree + 1, 1);
    //  Compute rows corresponding to function values
    V[0] = 1.0;
    V[V.size(1)] = us[0];
    i = degree + 1;
    for (::coder::SizeType ii{2}; ii <= i; ii++) {
      V[V.size(1) * (ii - 1)] = V[V.size(1) * (ii - 2)] * us[0];
    }
    //  Add row blocks corresponding to kth derivatives
  } break;
  case 2:
    d_gen_vander_2d(us, degree, V);
    break;
  default:
    d_gen_vander_3d(us, degree, V);
    break;
  }
}

static void d_gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                            ::coder::SizeType degree,
                            ::coder::array<real_T, 2U> &V)
{
  ::coder::SizeType c;
  ::coder::SizeType i;
  V.set_size((degree + 1) * (degree + 2) / 2, 1);
  //  compute 0th order generalized Vandermonde matrix
  V[V.size(1) * 2] = us[1];
  V[V.size(1)] = us[0];
  V[0] = 1.0;
  c = 3;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (::coder::SizeType deg{2}; deg <= i; deg++) {
    for (::coder::SizeType j{0}; j < deg; j++) {
      V[V.size(1) * c] = V[V.size(1) * (c - deg)] * us[0];
      c++;
    }
    V[V.size(1) * c] = V[V.size(1) * ((c - deg) - 1)] * us[1];
    c++;
  }
  //  Compute the bi-degree terms if degree<0
}

static void d_gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                            ::coder::SizeType degree,
                            ::coder::array<real_T, 2U> &V)
{
  ::coder::SizeType c;
  ::coder::SizeType d;
  ::coder::SizeType i;
  V.set_size((degree + 1) * (degree + 2) * (degree + 3) / 6, 1);
  //  compute 0th order generalized Vandermonde matrix
  V[V.size(1) * 3] = us[2];
  V[V.size(1) * 2] = us[1];
  V[V.size(1)] = us[0];
  V[0] = 1.0;
  c = 4;
  d = 4;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (::coder::SizeType deg{2}; deg <= i; deg++) {
    //  Within each level, use convention of Pascal triangle with x^deg at peak
    for (::coder::SizeType j{0}; j < deg; j++) {
      V[V.size(1) * c] = V[V.size(1) * ((c - d) + 1)] * us[0];
      c++;
    }
    V[V.size(1) * c] = V[V.size(1) * (c - d)] * us[1];
    c++;
    for (::coder::SizeType j{0}; j <= d - 2; j++) {
      V[V.size(1) * c] = V[V.size(1) * ((c - d) - deg)] * us[2];
      c++;
    }
    d = (d + deg) + 1;
  }
  //  Compute the tri-degree terms if degree<0
  m2cAssert(true, "");
}

static void d_wls_solve_sys(WlsObject *b_wls, const int8_T diff_idx_data[],
                            const ::coder::SizeType diff_idx_size[2],
                            ::coder::array<real_T, 2U> &vdops)
{
  ::coder::SizeType b_loop_ub;
  ::coder::SizeType diff_idx_idx_0_tmp;
  ::coder::SizeType i;
  ::coder::SizeType i1;
  ::coder::SizeType k;
  ::coder::SizeType loop_ub;
  ::coder::SizeType nRhs;
  ::coder::SizeType nnzops;
  ::coder::SizeType nrows;
  ::coder::SizeType nrows_vdops;
  ::coder::SizeType row;
  int8_T tmp_data[9];
  int8_T diff_idx_idx_0;
  boolean_T compressed;
  boolean_T exitg1;
  boolean_T y;
  nRhs = b_wls->rhs.size(0);
  compressed = false;
  diff_idx_idx_0_tmp = diff_idx_size[0] * diff_idx_size[1];
  diff_idx_idx_0 = static_cast<int8_T>(diff_idx_idx_0_tmp);
  i = 0;
  i1 = 0;
  for (k = 0; k < diff_idx_idx_0; k++) {
    tmp_data[k] = diff_idx_data[i1 + diff_idx_size[1] * i];
    i++;
    if (i > diff_idx_size[0] - 1) {
      i = 0;
      i1++;
    }
  }
  y = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k <= static_cast<int8_T>(diff_idx_idx_0_tmp) - 1)) {
    if (tmp_data[k] == 0) {
      y = false;
      exitg1 = true;
    } else {
      k++;
    }
  }
  if (!y) {
    //  Compress wls.rhs
    nnzops = 0;
    row = 1;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      y = false;
      k = 0;
      exitg1 = false;
      while ((!exitg1) && (k <= diff_idx_size[1] - 1)) {
        if (diff_idx_data[k + diff_idx_size[1] * (row - 1)] != 0) {
          y = true;
          exitg1 = true;
        } else {
          k++;
        }
      }
      if (y) {
        nnzops++;
        if (compressed) {
          i = b_wls->rhs.size(1);
          for (k = 0; k < i; k++) {
            b_wls->rhs[k + b_wls->rhs.size(1) * (nnzops - 1)] =
                b_wls->rhs[k + b_wls->rhs.size(1) * j];
          }
        }
      } else {
        compressed = true;
      }
      if (row < diff_idx_size[0]) {
        row++;
      } else {
        row = 1;
      }
    }
  } else {
    nnzops = b_wls->rhs.size(0);
  }
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      b_loop_ub = b_wls->QR.size(0);
      for (i1 = 0; i1 < b_loop_ub; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  }
  b_loop_ub = b_wls->ncols;
  k = b_wls->nrows;
  if (b_loop_ub >= k) {
    nrows_vdops = b_loop_ub;
  } else {
    nrows_vdops = k;
  }
  vdops.set_size(nrows_vdops, nRhs);
  if (compressed) {
    vdops.set_size(nrows_vdops, nRhs);
    loop_ub = nRhs * nrows_vdops;
    for (i = 0; i < loop_ub; i++) {
      vdops[i] = 0.0;
    }
    //  Compress wls.rhs
    nnzops = -1;
    row = 1;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      y = false;
      k = 0;
      exitg1 = false;
      while ((!exitg1) && (k <= diff_idx_size[1] - 1)) {
        if (diff_idx_data[k + diff_idx_size[1] * (row - 1)] != 0) {
          y = true;
          exitg1 = true;
        } else {
          k++;
        }
      }
      if (y) {
        nnzops++;
        i = nrows_vdops - b_wls->interp0;
        for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
          vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
              b_wls->rhs[b_i + b_wls->rhs.size(1) * nnzops];
        }
      }
      if (row < diff_idx_size[0]) {
        row++;
      } else {
        row = 1;
      }
    }
  } else {
    //  Transpose the operator for row-major
    i = nrows_vdops - b_wls->interp0;
    for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
      for (::coder::SizeType j{0}; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (k = 0; k < nRhs; k++) {
      for (::coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    boolean_T b;
    boolean_T b1;
    //  In interp0 mode, set the first entry based on partition of unity
    b = true;
    b1 = (diff_idx_size[1] <= 0) || (diff_idx_size[0] <= 0);
    i = 0;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      real_T s;
      real_T totalw;
      if (b1 || (j >= diff_idx_idx_0_tmp)) {
        i = 0;
        b = true;
      } else if (b) {
        b = false;
        i = j % diff_idx_size[0] * diff_idx_size[1] + j / diff_idx_size[0];
      } else if (i > MAX_int32_T - diff_idx_size[1]) {
        i = j % diff_idx_size[0] * diff_idx_size[1] + j / diff_idx_size[0];
      } else {
        i += diff_idx_size[1];
        if (i > diff_idx_idx_0_tmp - 1) {
          i = (i - diff_idx_idx_0_tmp) + 1;
        }
      }
      s = 0.0;
      i1 = b_wls->nstpnts;
      for (::coder::SizeType b_i{2}; b_i <= i1; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      if (diff_idx_data[i] != 1) {
        totalw = 0.0;
      } else {
        //  All weights summed together
        totalw = 0.0;
        i1 = b_wls->nevpnts;
        for (::coder::SizeType b_i{0}; b_i < i1; b_i++) {
          totalw++;
        }
      }
      vdops[j] = totalw - s;
    }
  }
  if ((diff_idx_size[0] > 1) && (diff_idx_size[1] > 1)) {
    ::coder::SizeType ndims;
    ndims = b_wls->us.size(1);
    b_wls->V.set_size(vdops.size(0), vdops.size(1));
    loop_ub = vdops.size(1) * vdops.size(0);
    for (i = 0; i < loop_ub; i++) {
      b_wls->V[i] = vdops[i];
    }
    k = vdops.size(1) / b_wls->us.size(1);
    vdops.set_size(b_wls->nstpnts * b_wls->us.size(1), k);
    loop_ub = k * (b_wls->nstpnts * b_wls->us.size(1));
    for (i = 0; i < loop_ub; i++) {
      vdops[i] = 0.0;
    }
    for (::coder::SizeType b_i{0}; b_i < k; b_i++) {
      i = b_wls->nstpnts;
      for (::coder::SizeType p{0}; p < i; p++) {
        for (::coder::SizeType j{0}; j < ndims; j++) {
          vdops[b_i + vdops.size(1) * (p * ndims + j)] =
              b_wls->V[(static_cast<::coder::SizeType>(
                            static_cast<real_T>(ndims) *
                            ((static_cast<real_T>(b_i) + 1.0) - 1.0)) +
                        j) +
                       b_wls->V.size(1) * p];
        }
      }
    }
  }
}

static void d_wls_solve_sys(WlsObject *b_wls, ::coder::array<real_T, 2U> &vdops)
{
  ::coder::SizeType b_loop_ub;
  ::coder::SizeType i;
  ::coder::SizeType k;
  ::coder::SizeType loop_ub;
  ::coder::SizeType nRhs;
  ::coder::SizeType ndims;
  ::coder::SizeType nnzops;
  ::coder::SizeType nrows;
  ::coder::SizeType nrows_vdops;
  ::coder::SizeType row;
  int8_T x[3];
  boolean_T compressed;
  boolean_T exitg1;
  boolean_T y;
  nRhs = b_wls->rhs.size(0);
  compressed = false;
  //  Compress wls.rhs
  nnzops = 0;
  row = 1;
  for (::coder::SizeType j{0}; j < nRhs; j++) {
    k = 3 * (row - 1);
    x[0] = iv[k];
    x[1] = iv[k + 1];
    x[2] = iv[k + 2];
    y = false;
    k = 0;
    exitg1 = false;
    while ((!exitg1) && (k < 3)) {
      if (x[k] != 0) {
        y = true;
        exitg1 = true;
      } else {
        k++;
      }
    }
    if (y) {
      nnzops++;
      if (compressed) {
        i = b_wls->rhs.size(1);
        for (k = 0; k < i; k++) {
          b_wls->rhs[k + b_wls->rhs.size(1) * (nnzops - 1)] =
              b_wls->rhs[k + b_wls->rhs.size(1) * j];
        }
      }
    } else {
      compressed = true;
    }
    if (row < 9) {
      row++;
    } else {
      row = 1;
    }
  }
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      b_loop_ub = b_wls->QR.size(0);
      for (k = 0; k < b_loop_ub; k++) {
        b_wls->QRt[k + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * k];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  }
  k = b_wls->ncols;
  b_loop_ub = b_wls->nrows;
  if (k >= b_loop_ub) {
    nrows_vdops = k;
  } else {
    nrows_vdops = b_loop_ub;
  }
  vdops.set_size(nrows_vdops, nRhs);
  if (compressed) {
    vdops.set_size(nrows_vdops, nRhs);
    loop_ub = nRhs * nrows_vdops;
    for (i = 0; i < loop_ub; i++) {
      vdops[i] = 0.0;
    }
    //  Compress wls.rhs
    nnzops = -1;
    row = 1;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      k = 3 * (row - 1);
      x[0] = iv[k];
      x[1] = iv[k + 1];
      x[2] = iv[k + 2];
      y = false;
      k = 0;
      exitg1 = false;
      while ((!exitg1) && (k < 3)) {
        if (x[k] != 0) {
          y = true;
          exitg1 = true;
        } else {
          k++;
        }
      }
      if (y) {
        nnzops++;
        i = nrows_vdops - b_wls->interp0;
        for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
          vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
              b_wls->rhs[b_i + b_wls->rhs.size(1) * nnzops];
        }
      }
      if (row < 9) {
        row++;
      } else {
        row = 1;
      }
    }
  } else {
    //  Transpose the operator for row-major
    i = nrows_vdops - b_wls->interp0;
    for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
      for (::coder::SizeType j{0}; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (k = 0; k < nRhs; k++) {
      for (::coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    boolean_T b;
    //  In interp0 mode, set the first entry based on partition of unity
    b = true;
    i = 0;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      real_T s;
      ::coder::SizeType totalw;
      if (j >= 27) {
        i = 0;
        b = true;
      } else if (b) {
        b = false;
        i = j % 9 * 3 + j / 9;
      } else {
        i += 3;
        if (i > 26) {
          i -= 26;
        }
      }
      s = 0.0;
      k = b_wls->nstpnts;
      for (::coder::SizeType b_i{2}; b_i <= k; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      if (iv[i] != 1) {
        totalw = 0;
      } else {
        totalw = b_wls->nevpnts;
        //  Unit weights summed together
      }
      vdops[j] = static_cast<real_T>(totalw) - s;
    }
  }
  ndims = b_wls->us.size(1);
  b_wls->V.set_size(vdops.size(0), vdops.size(1));
  loop_ub = vdops.size(1) * vdops.size(0);
  for (i = 0; i < loop_ub; i++) {
    b_wls->V[i] = vdops[i];
  }
  k = vdops.size(1) / b_wls->us.size(1);
  vdops.set_size(b_wls->nstpnts * b_wls->us.size(1), k);
  loop_ub = k * (b_wls->nstpnts * b_wls->us.size(1));
  for (i = 0; i < loop_ub; i++) {
    vdops[i] = 0.0;
  }
  for (::coder::SizeType b_i{0}; b_i < k; b_i++) {
    i = b_wls->nstpnts;
    for (::coder::SizeType p{0}; p < i; p++) {
      for (::coder::SizeType j{0}; j < ndims; j++) {
        vdops[b_i + vdops.size(1) * (p * ndims + j)] =
            b_wls->V[(static_cast<::coder::SizeType>(
                          static_cast<real_T>(ndims) *
                          ((static_cast<real_T>(b_i) + 1.0) - 1.0)) +
                      j) +
                     b_wls->V.size(1) * p];
      }
    }
  }
}

static void d_wls_update_rhs(WlsObject *b_wls)
{
  ::coder::SizeType nevpnts;
  ::coder::SizeType stride;
  ::coder::SizeType u0;
  ::coder::SizeType u1;
  nevpnts = b_wls->nevpnts - 1;
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(9, u0);
  u0 *= 9;
  for (u1 = 0; u1 < u0; u1++) {
    b_wls->rhs[u1] = 0.0;
  }
  stride = b_wls->us.size(0);
  //  Summing up rows in the differential operator
  for (::coder::SizeType jDiff{0}; jDiff < 3; jDiff++) {
    //  Loop through the operators
    for (::coder::SizeType iOp{0}; iOp < 9; iOp++) {
      int8_T i;
      //  Skip padded zeros in the differential operator
      i = iv[jDiff + 3 * iOp];
      if (i > 0) {
        ::coder::SizeType offset;
        offset = (i - 1) * stride;
        //  Sum up monomials weighted by weights for each component
        u1 = b_wls->ncols - b_wls->interp0;
        for (::coder::SizeType iMonomial{0}; iMonomial < u1; iMonomial++) {
          ::coder::SizeType j;
          j = b_wls->jpvt[iMonomial] + b_wls->interp0;
          for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
          }
        }
      } else if (i < 0) {
        ::coder::SizeType offset;
        offset = (-i - 1) * stride;
        //  Sum up monomials weighted by weights for each component
        u1 = b_wls->ncols - b_wls->interp0;
        for (::coder::SizeType iMonomial{0}; iMonomial < u1; iMonomial++) {
          ::coder::SizeType j;
          j = b_wls->jpvt[iMonomial] + b_wls->interp0;
          for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] -
                b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
          }
        }
      }
    }
  }
}

static void d_wls_update_rhs(WlsObject *b_wls, const int8_T diff_idx_data[],
                             const ::coder::SizeType diff_idx_size[2])
{
  ::coder::SizeType nDiff;
  ::coder::SizeType nevpnts;
  ::coder::SizeType u0;
  ::coder::SizeType u1;
  nevpnts = b_wls->nevpnts;
  nDiff = diff_idx_size[0];
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(diff_idx_size[0], u0);
  u0 *= diff_idx_size[0];
  for (u1 = 0; u1 < u0; u1++) {
    b_wls->rhs[u1] = 0.0;
  }
  //  Summing up rows in the differential operator
  u1 = diff_idx_size[1];
  for (::coder::SizeType jDiff{0}; jDiff < u1; jDiff++) {
    //  Loop through the operators
    for (::coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
      int8_T i;
      //  Skip padded zeros in the differential operator
      i = diff_idx_data[jDiff + diff_idx_size[1] * iOp];
      if (i > 0) {
        ::coder::SizeType offset;
        offset = (i - 1) * b_wls->us.size(0);
        //  Sum up monomials weighted by weights for each component
        u0 = b_wls->ncols - b_wls->interp0;
        for (::coder::SizeType iMonomial{0}; iMonomial < u0; iMonomial++) {
          ::coder::SizeType j;
          j = b_wls->jpvt[iMonomial] + b_wls->interp0;
          for (::coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
          }
        }
      }
    }
  }
}

static void d_wls_update_rhs(WlsObject *b_wls, const int8_T diff_idx_data[],
                             const ::coder::SizeType diff_idx_size[2],
                             const ::coder::array<real_T, 2U> &ws)
{
  ::coder::SizeType nDiff;
  ::coder::SizeType nevpnts;
  nevpnts = b_wls->nevpnts - 1;
  nDiff = diff_idx_size[0];
  if (!coder::isequal(ws)) {
    ::coder::SizeType i;
    ::coder::SizeType iWeight;
    ::coder::SizeType lenWs;
    ::coder::SizeType stride;
    if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
      lenWs = 1;
    } else {
      lenWs = ws.size(1);
    }
    stride = b_wls->us.size(0);
    //  Summing up rows in the differential operator
    iWeight = 0;
    i = diff_idx_size[1];
    for (::coder::SizeType jDiff{0}; jDiff < i; jDiff++) {
      //  Loop through the operators
      for (::coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
        int8_T i1;
        //  Skip padded zeros in the differential operator
        i1 = diff_idx_data[jDiff + diff_idx_size[1] * iOp];
        if (i1 > 0) {
          ::coder::SizeType i2;
          ::coder::SizeType offset;
          offset = (i1 - 1) * stride;
          //  Sum up monomials weighted by weights for each component
          i2 = b_wls->ncols - b_wls->interp0;
          for (::coder::SizeType iMonomial{0}; iMonomial < i2; iMonomial++) {
            ::coder::SizeType j;
            j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
            if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
              for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                    b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                    b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
              }
            } else {
              ::coder::SizeType iEval_ws;
              iEval_ws = 0;
              for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                    b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                    ws[iWeight + ws.size(1) * iEval_ws] *
                        b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
                iEval_ws += ws.size(0) > 1;
              }
            }
          }
        } else if (i1 < 0) {
          ::coder::SizeType i2;
          ::coder::SizeType offset;
          offset = (static_cast<int8_T>(-i1) - 1) * stride;
          //  Sum up monomials weighted by weights for each component
          i2 = b_wls->ncols - b_wls->interp0;
          for (::coder::SizeType iMonomial{0}; iMonomial < i2; iMonomial++) {
            ::coder::SizeType j;
            j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
            if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
              for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                    b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] -
                    b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
              }
            } else {
              ::coder::SizeType iEval_ws;
              iEval_ws = 0;
              for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                    b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] -
                    ws[iWeight + ws.size(1) * iEval_ws] *
                        b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
                iEval_ws += ws.size(0) > 1;
              }
            }
          }
        }
        if (iWeight + 1 == lenWs) {
          iWeight = 0;
        } else {
          iWeight++;
        }
      }
    }
  }
}

static void e_gen_vander(const ::coder::array<real_T, 2U> &us,
                         ::coder::SizeType npoints, ::coder::SizeType degree,
                         const ::coder::array<real_T, 2U> &hs_inv,
                         boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  switch (us.size(1)) {
  case 1: {
    real_T h_inv_;
    real_T s;
    ::coder::SizeType V_tmp;
    ::coder::SizeType b_npoints;
    ::coder::SizeType i;
    ::coder::SizeType i1;
    ::coder::SizeType r;
    ::coder::SizeType stride;
    boolean_T b;
    boolean_T b1;
    b_npoints = npoints - 1;
    m2cAssert(us.size(1) == 1, "");
    //  Handle input arguments
    if (npoints == 0) {
      b_npoints = us.size(0) - 1;
    } else {
      m2cAssert(npoints <= us.size(0), "Input us is too small.");
    }
    m2cAssert(degree >= 0, "Degree must be nonnegative");
    if (hs_inv.size(1) == 0) {
      h_inv_ = 1.0;
    } else {
      h_inv_ = hs_inv[0];
    }
    stride = us.size(0);
    //  Number of row blocks
    V.set_size(degree + 1, us.size(0) << 2);
    //  Compute rows corresponding to function values
    if (degree != 0) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      V_tmp = us.size(1) * us.size(0);
      i = 0;
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= V_tmp)) {
          i = 0;
          b = true;
        } else if (b) {
          b = false;
          i = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          i1 = us.size(1) * us.size(0) - 1;
          if (i > MAX_int32_T - us.size(1)) {
            i = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i += us.size(1);
            if (i > i1) {
              i -= i1;
            }
          }
        }
        V[iPnt] = 1.0;
        V[iPnt + V.size(1)] = us[i];
      }
    } else {
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        V[iPnt] = 1.0;
      }
    }
    V_tmp = degree + 1;
    for (::coder::SizeType ii{2}; ii <= V_tmp; ii++) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      i = us.size(1) * us.size(0);
      i1 = 0;
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          ::coder::SizeType i2;
          i2 = us.size(1) * us.size(0) - 1;
          if (i1 > MAX_int32_T - us.size(1)) {
            i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i1 += us.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        V[iPnt + V.size(1) * (ii - 1)] =
            V[iPnt + V.size(1) * (ii - 2)] * us[i1];
      }
    }
    //  Add row blocks corresponding to kth derivatives
    r = us.size(0);
    //      computing negative orders
    for (::coder::SizeType k{0}; k < 2; k++) {
      for (::coder::SizeType j{0}; j <= k; j++) {
        for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
          V[(r + iPnt) + V.size(1) * j] = 0.0;
        }
      }
      for (::coder::SizeType j{k + 1}; j <= degree; j++) {
        s = h_inv_ * static_cast<real_T>(j);
        for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
          V_tmp = r + iPnt;
          V[V_tmp + V.size(1) * j] =
              V[(V_tmp - stride) + V.size(1) * (j - 1)] * s;
        }
      }
      r += stride;
    }
    //      Calculate Biharmonic if order = -4
    for (::coder::SizeType j{0}; j < 4; j++) {
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        V[(r + iPnt) + V.size(1) * j] = 0.0;
      }
    }
    for (::coder::SizeType j{2}; j <= degree; j++) {
      s = h_inv_ * static_cast<real_T>(j);
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        V_tmp = r + iPnt;
        V[V_tmp + V.size(1) * j] =
            V[(V_tmp - stride) + V.size(1) * (j - 2)] * s * (s - 1.0);
      }
    }
  } break;
  case 2:
    e_gen_vander_2d(us, npoints, degree, hs_inv, unimono, V);
    break;
  default:
    e_gen_vander_3d(us, npoints, degree, hs_inv, unimono, V);
    break;
  }
}

static void e_gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                            ::coder::SizeType npoints, ::coder::SizeType degree,
                            const ::coder::array<real_T, 2U> &hs_inv,
                            boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  real_T hs_inv__idx_0;
  real_T hs_inv__idx_1;
  real_T scaleu;
  real_T scalev;
  ::coder::SizeType b_degree;
  ::coder::SizeType c;
  ::coder::SizeType deg;
  ::coder::SizeType i;
  ::coder::SizeType offset;
  ::coder::SizeType ret;
  ::coder::SizeType stride;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (hs_inv.size(1) == 0) {
    hs_inv__idx_0 = 1.0;
    hs_inv__idx_1 = 1.0;
  } else {
    hs_inv__idx_0 = hs_inv[0];
    hs_inv__idx_1 = hs_inv[1];
  }
  stride = us.size(0);
  if (unimono) {
    m2cErrMsgIdAndTxt(
        "wlslib:WrongOrder",
        "For axes-aligned monomials, derivatives cannot have cross terms.");
    if (degree >= 0) {
      degree = -degree;
    }
  }
  //  Number of row blocks
  if (degree >= 0) {
    ret = (degree + 1) * (degree + 2) / 2;
    unimono = false;
  } else if (unimono) {
    ret = 1 - (degree << 1);
  } else {
    ret = (1 - degree) * (1 - degree);
  }
  //  Allocate storage for V
  if (degree > 0) {
    b_degree = 8;
  } else {
    b_degree = 11;
  }
  V.set_size(ret, us.size(0) * b_degree);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
    }
  } else {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType j{0}; j < deg; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - deg) - 1)] * us[us.size(1) * iPnt + 1];
      }
      c++;
    }
    //  Compute the bi-degree terms if degree<0
    i = -degree;
    for (deg = i; deg >= 1; deg--) {
      for (::coder::SizeType k{0}; k < deg; k++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
        }
        c++;
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 2)] * us[us.size(1) * iPnt];
        V[iPnt + V.size(1) * (c + 1)] =
            V[iPnt + V.size(1) * (c - 1)] * us[us.size(1) * iPnt + 1];
      }
      c += 2;
    }
  }
  //  compute higher order confluent Vandermonde matrix blocks incrementally
  m2cAssert(degree != 0, "");
  //  Compute derivative with respect to u
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = stride + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = V[iPnt] * hs_inv__idx_0;
    V[ret + V.size(1) * 2] = 0.0;
  }
  c = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scaleu = static_cast<real_T>(deg) * hs_inv__idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * scaleu;
      }
      c++;
      for (::coder::SizeType j{0}; j <= deg - 2; j++) {
        scaleu -= hs_inv__idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * scaleu;
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    //  Compute the bi-degree terms if degree<0
    i = -degree;
    for (::coder::SizeType len{i}; len >= 0; len--) {
      scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
      for (::coder::SizeType k{0}; k < len; k++) {
        scaleu -= hs_inv__idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - len)] * scaleu;
        }
        c++;
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scaleu = static_cast<real_T>(deg) * hs_inv__idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 2)] * scaleu;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
      }
      c += 2;
    }
  }
  //  Compute derivative with respect to v
  offset = us.size(0) + us.size(0);
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = offset + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = 0.0;
    V[ret + V.size(1) * 2] = V[iPnt] * hs_inv__idx_1;
  }
  c = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
      for (::coder::SizeType j{0}; j < deg; j++) {
        scalev = (static_cast<real_T>(j) + 1.0) * hs_inv__idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * ((c - deg) - 1)] * scalev;
        }
        c++;
      }
    }
    //  Compute the bi-degree terms if degree<0
    ret = -degree;
    deg = -degree;
    for (::coder::SizeType len{ret}; len >= 0; len--) {
      deg++;
      scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
      for (::coder::SizeType k{0}; k < len; k++) {
        scalev += hs_inv__idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * ((c - len) - 1)] * scalev;
        }
        c++;
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      scalev = static_cast<real_T>(deg) * hs_inv__idx_1;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * (c + 1)] =
            V[iPnt + V.size(1) * (c - 1)] * scalev;
      }
      c += 2;
    }
  }
  //      compute regular orders if order > 0
  if (degree > 0) {
    ::coder::SizeType i1;
    ::coder::SizeType offset_prev;
    //  Compute order-N CVM row blocks from order-(N-1) CVM.
    m2cAssert(true, "");
    offset = 3 * us.size(0);
    //  Compute derivative with respect to u
    i = offset + 1;
    i1 = offset + npoints;
    for (::coder::SizeType col{0}; col < 3; col++) {
      for (::coder::SizeType row{i}; row <= i1; row++) {
        V[(row + V.size(1) * col) - 1] = 0.0;
      }
    }
    c = 3;
    for (deg = 2; deg <= degree; deg++) {
      scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
      i = deg - 1;
      for (::coder::SizeType j{0}; j <= i; j++) {
        scaleu -= hs_inv__idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(us.size(0) + iPnt) + V.size(1) * (c - deg)] * scaleu;
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    //  Compute the bi-degree terms if degree<0
    offset += us.size(0);
    //  Compute derivative with respect to v
    offset_prev = (us.size(0) + us.size(0)) + us.size(0);
    i = offset + 1;
    i1 = offset + npoints;
    for (::coder::SizeType col{0}; col < 3; col++) {
      for (::coder::SizeType row{i}; row <= i1; row++) {
        V[(row + V.size(1) * col) - 1] = 0.0;
      }
    }
    c = 3;
    for (deg = 2; deg <= degree; deg++) {
      for (::coder::SizeType j{0}; j < 2; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      for (::coder::SizeType j{2}; j <= deg; j++) {
        scalev = static_cast<real_T>(j) * hs_inv__idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - deg) - 1)] *
              scalev;
        }
        c++;
      }
    }
    //  Compute the bi-degree terms if degree<0
    offset = 5 * us.size(0);
    offset_prev = 3 * us.size(0);
    m2cAssert(degree >= 4, "");
    //  compute du^4 and du^2*dv^2
    for (::coder::SizeType terms{0}; terms < 2; terms++) {
      i = offset + 1;
      i1 = offset + npoints;
      for (::coder::SizeType col{0}; col < 10; col++) {
        for (::coder::SizeType row{i}; row <= i1; row++) {
          V[(row + V.size(1) * col) - 1] = 0.0;
        }
      }
      c = 10;
      for (deg = 4; deg <= degree; deg++) {
        scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
        i = deg - 1;
        for (::coder::SizeType j{0}; j <= i; j++) {
          scaleu -= hs_inv__idx_0;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(offset_prev + iPnt) + V.size(1) * ((c - (deg << 1)) + 1)] *
                scaleu * (scaleu - hs_inv__idx_0);
          }
          c++;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      offset += stride;
      offset_prev += stride;
    }
    //  compute dv^4
    i = offset + 1;
    i1 = offset + npoints;
    for (::coder::SizeType col{0}; col < 10; col++) {
      for (::coder::SizeType row{i}; row <= i1; row++) {
        V[(row + V.size(1) * col) - 1] = 0.0;
      }
    }
    c = 10;
    for (deg = 4; deg <= degree; deg++) {
      for (::coder::SizeType j{0}; j < 4; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      for (::coder::SizeType j{4}; j <= deg; j++) {
        scalev = static_cast<real_T>(j) * (hs_inv__idx_1 * hs_inv__idx_1);
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((offset_prev - stride) + iPnt) +
                V.size(1) * ((c - (deg << 1)) - 1)] *
              scalev * (static_cast<real_T>(j) - 1.0);
        }
        c++;
      }
    }
  } else {
    ::coder::SizeType i1;
    ::coder::SizeType offset_prev;
    //  Compute order-N CVM row blocks from order-(N-1) CVM.
    m2cAssert(degree != 0, "");
    offset = 3 * us.size(0);
    offset_prev = us.size(0);
    //  Compute derivative with respect to u
    if (degree < 0) {
      i = -degree;
    } else {
      i = 0;
    }
    i1 = -degree;
    //  Initialize block to zero
    b_degree = offset + 1;
    ret = offset + npoints;
    for (::coder::SizeType col{0}; col < 3; col++) {
      for (::coder::SizeType row{b_degree}; row <= ret; row++) {
        V[(row + V.size(1) * col) - 1] = 0.0;
      }
    }
    c = 3;
    for (deg = 2; deg <= i; deg++) {
      scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
      b_degree = deg - 1;
      for (::coder::SizeType j{0}; j <= b_degree; j++) {
        scaleu -= hs_inv__idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    //  Compute the bi-degree terms if degree<0
    for (::coder::SizeType len{i1}; len >= 0; len--) {
      scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
      for (::coder::SizeType k{0}; k < len; k++) {
        scaleu -= hs_inv__idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
        }
        c++;
      }
    }
    offset += us.size(0);
    //  Compute derivative with respect to v
    offset_prev = (us.size(0) + us.size(0)) + us.size(0);
    i = offset + 1;
    b_degree = offset + npoints;
    for (::coder::SizeType col{0}; col < 3; col++) {
      for (::coder::SizeType row{i}; row <= b_degree; row++) {
        V[(row + V.size(1) * col) - 1] = 0.0;
      }
    }
    c = 3;
    if (degree < 0) {
      i = -degree;
    } else {
      i = 0;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType j{0}; j < 2; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      for (::coder::SizeType j{2}; j <= deg; j++) {
        scalev = static_cast<real_T>(j) * hs_inv__idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - deg) - 1)] *
              scalev;
        }
        c++;
      }
    }
    //  Compute the bi-degree terms if degree<0
    deg = -degree;
    for (::coder::SizeType len{i1}; len >= 0; len--) {
      deg++;
      scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
      for (::coder::SizeType k{0}; k < len; k++) {
        scalev += hs_inv__idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - len) - 1)] *
              scalev;
        }
        c++;
      }
    }
    //  Compute order-N CVM row blocks from order-(N-1) CVM.
    m2cAssert(degree != 0, "");
    offset = 5 * us.size(0);
    offset_prev = 3 * us.size(0);
    //  Compute derivative with respect to u
    if (degree < 0) {
      i = -degree;
    } else {
      i = 0;
    }
    for (::coder::SizeType b_i{0}; b_i < 2; b_i++) {
      //  Initialize block to zero
      b_degree = offset + 1;
      ret = offset + npoints;
      for (::coder::SizeType col{0}; col < 6; col++) {
        for (::coder::SizeType row{b_degree}; row <= ret; row++) {
          V[(row + V.size(1) * col) - 1] = 0.0;
        }
      }
      c = 6;
      for (deg = 3; deg <= i; deg++) {
        scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
        b_degree = deg - 1;
        for (::coder::SizeType j{0}; j <= b_degree; j++) {
          scaleu -= hs_inv__idx_0;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
          }
          c++;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      //  Compute the bi-degree terms if degree<0
      for (::coder::SizeType len{i1}; len >= 0; len--) {
        scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
        for (::coder::SizeType k{0}; k < len; k++) {
          scaleu -= hs_inv__idx_0;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
          }
          c++;
        }
      }
      offset += stride;
      offset_prev += stride;
    }
    //  Compute derivative with respect to v
    i = offset + 1;
    b_degree = offset + npoints;
    for (::coder::SizeType col{0}; col < 6; col++) {
      for (::coder::SizeType row{i}; row <= b_degree; row++) {
        V[(row + V.size(1) * col) - 1] = 0.0;
      }
    }
    c = 6;
    if (degree < 0) {
      i = -degree;
    } else {
      i = 0;
    }
    for (deg = 3; deg <= i; deg++) {
      for (::coder::SizeType j{0}; j < 3; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      for (::coder::SizeType j{3}; j <= deg; j++) {
        scalev = static_cast<real_T>(j) * hs_inv__idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - deg) - 1)] *
              scalev;
        }
        c++;
      }
    }
    //  Compute the bi-degree terms if degree<0
    deg = -degree;
    for (::coder::SizeType len{i1}; len >= 0; len--) {
      deg++;
      scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
      for (::coder::SizeType k{0}; k < len; k++) {
        scalev += hs_inv__idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - len) - 1)] *
              scalev;
        }
        c++;
      }
    }
    //  Compute order-N CVM row blocks from order-(N-1) CVM.
    m2cAssert(degree != 0, "");
    offset = us.size(0) << 3;
    offset_prev = 5 * us.size(0);
    //  Compute derivative with respect to u
    if (degree < 0) {
      i = -degree;
    } else {
      i = 0;
    }
    for (::coder::SizeType b_i{0}; b_i < 2; b_i++) {
      //  Initialize block to zero
      b_degree = offset + 1;
      ret = offset + npoints;
      for (::coder::SizeType col{0}; col < 10; col++) {
        for (::coder::SizeType row{b_degree}; row <= ret; row++) {
          V[(row + V.size(1) * col) - 1] = 0.0;
        }
      }
      c = 10;
      for (deg = 4; deg <= i; deg++) {
        scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
        b_degree = deg - 1;
        for (::coder::SizeType j{0}; j <= b_degree; j++) {
          scaleu -= hs_inv__idx_0;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
          }
          c++;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      //  Compute the bi-degree terms if degree<0
      for (::coder::SizeType len{i1}; len >= 0; len--) {
        scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
        for (::coder::SizeType k{0}; k < len; k++) {
          scaleu -= hs_inv__idx_0;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
          }
          c++;
        }
      }
      offset += stride;
      offset_prev += stride;
    }
    //  Compute derivative with respect to v
    offset_prev += us.size(0);
    i = offset + 1;
    b_degree = offset + npoints;
    for (::coder::SizeType col{0}; col < 10; col++) {
      for (::coder::SizeType row{i}; row <= b_degree; row++) {
        V[(row + V.size(1) * col) - 1] = 0.0;
      }
    }
    c = 10;
    if (degree < 0) {
      i = -degree;
    } else {
      i = 0;
    }
    for (deg = 4; deg <= i; deg++) {
      for (::coder::SizeType j{0}; j < 4; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      for (::coder::SizeType j{4}; j <= deg; j++) {
        scalev = static_cast<real_T>(j) * hs_inv__idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - deg) - 1)] *
              scalev;
        }
        c++;
      }
    }
    //  Compute the bi-degree terms if degree<0
    deg = -degree;
    for (::coder::SizeType len{i1}; len >= 0; len--) {
      deg++;
      scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
      for (::coder::SizeType k{0}; k < len; k++) {
        scalev += hs_inv__idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - len) - 1)] *
              scalev;
        }
        c++;
      }
    }
  }
}

static void e_gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                            ::coder::SizeType npoints, ::coder::SizeType degree,
                            const ::coder::array<real_T, 2U> &hs_inv,
                            boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  real_T b_u2v2_tmp;
  real_T hs_inv_idx_0;
  real_T hs_inv_idx_1;
  real_T hs_inv_idx_2;
  real_T scaleu;
  real_T scalev;
  real_T scalew;
  real_T u2v2;
  real_T u2v2_tmp;
  real_T u2w2;
  real_T u2w2_tmp;
  real_T uu2;
  real_T uu4;
  real_T v2w2;
  real_T v4;
  real_T vv2;
  real_T ww2;
  real_T ww4;
  ::coder::SizeType b_degree;
  ::coder::SizeType balance;
  ::coder::SizeType c;
  ::coder::SizeType cornerTriangle;
  ::coder::SizeType counterBottomRow;
  ::coder::SizeType d;
  ::coder::SizeType deg;
  ::coder::SizeType degg;
  ::coder::SizeType excess;
  ::coder::SizeType i;
  ::coder::SizeType maxLayers;
  ::coder::SizeType nTermsInLayer;
  ::coder::SizeType nTermsInPrevLayer;
  ::coder::SizeType offset;
  ::coder::SizeType partition;
  ::coder::SizeType ret;
  ::coder::SizeType stride;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (hs_inv.size(1) == 0) {
    hs_inv_idx_0 = 1.0;
    hs_inv_idx_1 = 1.0;
    hs_inv_idx_2 = 1.0;
  } else {
    hs_inv_idx_0 = hs_inv[0];
    hs_inv_idx_1 = hs_inv[1];
    hs_inv_idx_2 = hs_inv[2];
  }
  stride = us.size(0);
  if (unimono) {
    m2cErrMsgIdAndTxt(
        "wlslib:WrongOrder",
        "For axes-aligned monomials, derivatives cannot have cross terms.");
    if (degree >= 0) {
      degree = -degree;
    }
  }
  if (degree >= 0) {
    ret = (degree + 1) * (degree + 2) * (degree + 3) / 6;
    unimono = false;
  } else if (unimono) {
    ret = 1 - 3 * degree;
  } else {
    ret = (1 - degree) * (1 - degree) * (1 - degree);
  }
  //  Allocate storage for V
  if (degree > 0) {
    b_degree = 13;
  } else {
    b_degree = 19;
  }
  V.set_size(ret, us.size(0) * b_degree);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
      V[iPnt + V.size(1) * 3] = us[us.size(1) * iPnt + 2];
    }
  } else {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 4;
  d = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      //  Within each level, use convention of Pascal triangle with x^deg at
      for (::coder::SizeType j{0}; j < deg; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * us[us.size(1) * iPnt];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - d) - 1)] * us[us.size(1) * iPnt + 1];
      }
      c++;
      for (::coder::SizeType j{0}; j < d; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
              us[us.size(1) * iPnt + 2];
        }
        c++;
      }
      d = (d + deg) + 1;
    }
    //  Compute the tri-degree terms if degree<0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        ::coder::SizeType gap;
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 1;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType k{0}; k < deg; k++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[iPnt + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - nTermsInLayer)] *
                us[us.size(1) * iPnt + 1];
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        ret = ((degree + degree) + p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer;
        nTermsInLayer = d + 3 * (excess - cornerTriangle);
        gap = (nTermsInPrevLayer + counterBottomRow) - 1;
        b_degree = nTermsInLayer - counterBottomRow;
        for (::coder::SizeType j{0}; j <= b_degree; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[iPnt + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - gap)] * us[us.size(1) * iPnt + 2];
          }
          c++;
        }
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 3)] * us[us.size(1) * iPnt];
        V[iPnt + V.size(1) * (c + 1)] =
            V[iPnt + V.size(1) * (c - 2)] * us[us.size(1) * iPnt + 1];
        V[iPnt + V.size(1) * (c + 2)] =
            V[iPnt + V.size(1) * (c - 1)] * us[us.size(1) * iPnt + 2];
      }
      c += 3;
    }
  }
  m2cAssert(true, "");
  //      compute higher order confluent Vandermonde matrix blocks
  m2cAssert(degree > 0, "Biharmonic operator is only supported for "
                        "Pascal-tetrahedral monomials in 3D.");
  //  Compute order-1 CVM row blocks from order-0 GVM.
  m2cAssert(degree != 0, "");
  // compute derivatives with respect to u
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = stride + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = V[iPnt] * hs_inv_idx_0;
    V[ret + V.size(1) * 2] = 0.0;
    V[ret + V.size(1) * 3] = 0.0;
  }
  c = 4;
  d = 3;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 2; deg <= i; deg++) {
    scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] =
          V[iPnt + V.size(1) * (c - d)] * scaleu;
    }
    c++;
    for (::coder::SizeType j{0}; j <= deg - 2; j++) {
      scaleu -= hs_inv_idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * scaleu;
      }
      c++;
    }
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] = 0.0;
    }
    for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = stride + iPnt;
        V[ret + V.size(1) * (c + 1)] =
            V[ret + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
    }
    c += 2;
    d = (d + deg) + 1;
  }
  // tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (::coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 1;
      // counter for the bottom row to be subtracted later
      for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = stride + iPnt;
          V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - nTermsInLayer)] *
                                   us[us.size(1) * iPnt + 1];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      ret = (((p + degree) << 1) - p) - 1;
      if (ret < 0) {
        ret = 0;
      }
      excess += ret;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = (nTermsInPrevLayer + counterBottomRow) - 1;
      b_degree = nTermsInLayer - counterBottomRow;
      for (::coder::SizeType j{0}; j <= b_degree; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = stride + iPnt;
          V[ret + V.size(1) * c] =
              V[ret + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  // compute derivatives with respect to v
  offset = us.size(0) + us.size(0);
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = offset + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = 0.0;
    V[ret + V.size(1) * 2] = V[iPnt] * hs_inv_idx_1;
    V[ret + V.size(1) * 3] = 0.0;
  }
  c = 4;
  d = 4;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 2; deg <= i; deg++) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    scalev = hs_inv_idx_1;
    for (::coder::SizeType j{0}; j <= deg - 2; j++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * scalev;
      }
      scalev += hs_inv_idx_1;
      c++;
    }
    scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] =
          V[iPnt + V.size(1) * (c - d)] * scalev;
    }
    c++;
    for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret + V.size(1) * c] =
            V[ret + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    d = (d + deg) + 1;
  }
  // compute the tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d - 2;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (::coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          V[ret + V.size(1) * c] =
              V[ret + V.size(1) * (c - nTermsInLayer)] * us[us.size(1) * iPnt];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      ret = (((p + degree) << 1) - p) - 1;
      if (ret < 0) {
        ret = 0;
      }
      excess += ret;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer + 1;
      nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
      balance = nTermsInPrevLayer + counterBottomRow;
      b_degree = nTermsInLayer - counterBottomRow;
      for (::coder::SizeType j{0}; j <= b_degree; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          V[ret + V.size(1) * c] =
              V[ret + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  // compute derivatives with respect to w
  offset += us.size(0);
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = offset + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = 0.0;
    V[ret + V.size(1) * 2] = 0.0;
    V[ret + V.size(1) * 3] = V[iPnt] * hs_inv_idx_2;
  }
  c = 4;
  d = 3;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 2; deg <= i; deg++) {
    for (::coder::SizeType j{0}; j <= deg; j++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    for (::coder::SizeType k{0}; k < deg; k++) {
      b_degree = (deg - k) - 1;
      for (::coder::SizeType b_i{0}; b_i <= b_degree; b_i++) {
        scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (((c - d) - deg) - 1)] * scalew;
        }
        c++;
      }
    }
    d = (d + deg) + 1;
  }
  // compute tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (::coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (::coder::SizeType k{0}; k < deg; k++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      b_degree = p + degree;
      ret = ((b_degree << 1) - p) - 1;
      if (ret < 0) {
        ret = 0;
      }
      excess += ret;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = nTermsInPrevLayer + counterBottomRow;
      degg = -degree;
      for (::coder::SizeType k{0}; k < degg; k++) {
        ret = (b_degree - k) - 1;
        if (ret < 0) {
          ret = -ret;
        }
        partition = -degree - ret;
        for (::coder::SizeType j{0}; j <= partition; j++) {
          scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(iPnt + offset) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - balance)] * scalew;
          }
          c++;
        }
      }
    }
  }
  //  compute du^2
  offset = us.size(0) << 2;
  uu2 = 2.0 * hs_inv_idx_0 * hs_inv_idx_0;
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = offset + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = 0.0;
    V[ret + V.size(1) * 2] = 0.0;
    V[ret + V.size(1) * 3] = 0.0;
    V[ret + V.size(1) * 4] = uu2 * V[iPnt];
    for (i = 0; i < 5; i++) {
      V[ret + V.size(1) * (i + 5)] = 0.0;
    }
  }
  c = 10;
  d = 6;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 3; deg <= i; deg++) {
    scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] =
          V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
    }
    c++;
    for (::coder::SizeType j{0}; j <= deg - 2; j++) {
      scaleu -= hs_inv_idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
      }
      c++;
    }
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret + V.size(1) * (c + 1)] =
            V[ret + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
    }
    c += 2;
    d = (d + deg) + 1;
  }
  // compute tri degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (::coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 1;
      // counter for the bottom row to be subtracted later
      for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - nTermsInLayer)] *
                                   us[us.size(1) * iPnt + 1];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      ret = (((p + degree) << 1) - p) - 1;
      if (ret < 0) {
        ret = 0;
      }
      excess += ret;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = (nTermsInPrevLayer + counterBottomRow) - 1;
      b_degree = nTermsInLayer - counterBottomRow;
      for (::coder::SizeType j{0}; j <= b_degree; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          V[ret + V.size(1) * c] =
              V[ret + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  //  compute dv^2
  offset += us.size(0);
  vv2 = 2.0 * hs_inv_idx_1 * hs_inv_idx_1;
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = offset + iPnt;
    for (i = 0; i < 6; i++) {
      V[ret + V.size(1) * i] = 0.0;
    }
    V[ret + V.size(1) * 6] = vv2 * V[iPnt];
    V[ret + V.size(1) * 7] = 0.0;
    V[ret + V.size(1) * 8] = 0.0;
    V[ret + V.size(1) * 9] = 0.0;
  }
  c = 10;
  d = 7;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 3; deg <= i; deg++) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    scalev = hs_inv_idx_1;
    for (::coder::SizeType j{0}; j <= deg - 2; j++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[(iPnt + (stride << 1)) + V.size(1) * (c - d)] * scalev;
      }
      scalev += hs_inv_idx_1;
      c++;
    }
    scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] =
          V[((stride << 1) + iPnt) + V.size(1) * (c - d)] * scalev;
    }
    c++;
    for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret + V.size(1) * c] =
            V[ret + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    d = (d + deg) + 1;
  }
  // compute the tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d - 2;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (::coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          V[ret + V.size(1) * c] =
              V[ret + V.size(1) * (c - nTermsInLayer)] * us[us.size(1) * iPnt];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      ret = (((p + degree) << 1) - p) - 1;
      if (ret < 0) {
        ret = 0;
      }
      excess += ret;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer + 1;
      nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
      balance = nTermsInPrevLayer + counterBottomRow;
      b_degree = nTermsInLayer - counterBottomRow;
      for (::coder::SizeType j{0}; j <= b_degree; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          V[ret + V.size(1) * c] =
              V[ret + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  //  compute dw^2
  offset += us.size(0);
  ww2 = 2.0 * hs_inv_idx_2 * hs_inv_idx_2;
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = offset + iPnt;
    for (i = 0; i < 9; i++) {
      V[ret + V.size(1) * i] = 0.0;
    }
    V[ret + V.size(1) * 9] = ww2 * V[iPnt];
  }
  c = 10;
  d = 6;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 3; deg <= i; deg++) {
    for (::coder::SizeType j{0}; j <= deg; j++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    for (::coder::SizeType k{0}; k < deg; k++) {
      b_degree = (deg - k) - 1;
      for (::coder::SizeType b_i{0}; b_i <= b_degree; b_i++) {
        scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + 3 * stride) + V.size(1) * (((c - d) - deg) - 1)] *
              scalew;
        }
        c++;
      }
    }
    d = (d + deg) + 1;
  }
  // compute tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (::coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (::coder::SizeType k{0}; k < deg; k++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      b_degree = p + degree;
      ret = ((b_degree << 1) - p) - 1;
      if (ret < 0) {
        ret = 0;
      }
      excess += ret;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = nTermsInPrevLayer + counterBottomRow;
      degg = -degree;
      for (::coder::SizeType k{0}; k < degg; k++) {
        ret = (b_degree - k) - 1;
        if (ret < 0) {
          ret = -ret;
        }
        partition = -degree - ret;
        for (::coder::SizeType j{0}; j <= partition; j++) {
          scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(iPnt + offset) + V.size(1) * c] =
                V[(iPnt + 3 * stride) + V.size(1) * (c - balance)] * scalew;
          }
          c++;
        }
      }
    }
  }
  //  compute du^4
  offset = us.size(0) * 7;
  uu4 = 24.0 * std::pow(hs_inv_idx_0, 4.0);
  for (::coder::SizeType b_i{0}; b_i < 35; b_i++) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
    }
  }
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    V[(offset + iPnt) + V.size(1) * 20] = uu4 * V[iPnt];
  }
  c = 35;
  d = 15;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 5; deg <= i; deg++) {
    scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] =
          V[(iPnt + (stride << 2)) + V.size(1) * ((c - (d << 1)) + deg)] *
          scaleu * (scaleu - hs_inv_idx_0);
    }
    c++;
    for (::coder::SizeType j{0}; j <= deg - 2; j++) {
      scaleu -= hs_inv_idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[(iPnt + (stride << 2)) + V.size(1) * ((c - (d << 1)) + deg)] *
            scaleu * (scaleu - hs_inv_idx_0);
      }
      c++;
    }
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret + V.size(1) * (c + 1)] =
            V[ret + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
    }
    c += 2;
    d = (d + deg) + 1;
  }
  //  compute du^2dv^2
  offset = us.size(0) << 3;
  u2v2_tmp = 4.0 * (hs_inv_idx_0 * hs_inv_idx_0);
  b_u2v2_tmp = hs_inv_idx_1 * hs_inv_idx_1;
  u2v2 = u2v2_tmp * b_u2v2_tmp;
  for (::coder::SizeType b_i{0}; b_i < 35; b_i++) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
    }
  }
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    V[(offset + iPnt) + V.size(1) * 22] = u2v2 * V[iPnt];
  }
  c = 35;
  d = 15;
  for (deg = 5; deg <= i; deg++) {
    scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] =
          V[(iPnt + 5 * stride) + V.size(1) * ((c - (d << 1)) + deg)] * scaleu *
          (scaleu - hs_inv_idx_0);
    }
    c++;
    for (::coder::SizeType j{0}; j <= deg - 2; j++) {
      scaleu -= hs_inv_idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[(iPnt + 5 * stride) + V.size(1) * ((c - (d << 1)) + deg)] *
            scaleu * (scaleu - hs_inv_idx_0);
      }
      c++;
    }
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret + V.size(1) * (c + 1)] =
            V[ret + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
    }
    c += 2;
    d = (d + deg) + 1;
  }
  //  compute dv^4
  offset = us.size(0) * 9;
  v4 = 24.0 * std::pow(hs_inv_idx_1, 4.0);
  for (::coder::SizeType b_i{0}; b_i < 35; b_i++) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
    }
  }
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    V[(offset + iPnt) + V.size(1) * 24] = v4 * V[iPnt];
  }
  c = 34;
  d = 15;
  for (deg = 5; deg <= degree; deg++) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
    }
    scalev = hs_inv_idx_1;
    for (::coder::SizeType j{0}; j <= deg - 2; j++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * (c + 2)] =
            V[(iPnt + 5 * stride) + V.size(1) * ((c - (d << 1)) + deg)] *
            scalev * (scalev - hs_inv_idx_1);
      }
      scalev += hs_inv_idx_1;
      c++;
    }
    scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * (c + 2)] =
          V[(5 * stride + iPnt) + V.size(1) * ((c - (d << 1)) + deg)] * scalev *
          (scalev - hs_inv_idx_1);
    }
    c += 3;
    for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret + V.size(1) * c] = V[ret + V.size(1) * (((c - d) - deg) - 1)] *
                                 us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    d = (d + deg) + 1;
  }
  //  compute du^2*dw^2
  offset += us.size(0);
  u2w2_tmp = hs_inv_idx_2 * hs_inv_idx_2;
  u2w2 = u2v2_tmp * u2w2_tmp;
  for (::coder::SizeType b_i{0}; b_i < 35; b_i++) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
    }
  }
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    V[(offset + iPnt) + V.size(1) * 29] = u2w2 * V[iPnt];
  }
  c = 35;
  d = 15;
  for (deg = 5; deg <= i; deg++) {
    for (::coder::SizeType j{0}; j <= deg; j++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    for (::coder::SizeType k{0}; k < deg; k++) {
      b_degree = (deg - k) - 1;
      for (::coder::SizeType b_i{0}; b_i <= b_degree; b_i++) {
        scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + (stride << 2)) +
                V.size(1) * (((c - (d << 1)) - deg) - 1)] *
              scalew * (scalew - hs_inv_idx_2);
        }
        c++;
      }
    }
    d = (d + deg) + 1;
  }
  //  compute dv^2*dw^2
  offset += us.size(0);
  v2w2 = 4.0 * b_u2v2_tmp * u2w2_tmp;
  for (::coder::SizeType b_i{0}; b_i < 35; b_i++) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
    }
  }
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    V[(offset + iPnt) + V.size(1) * 31] = v2w2 * V[iPnt];
  }
  c = 35;
  d = 15;
  for (deg = 5; deg <= i; deg++) {
    for (::coder::SizeType j{0}; j <= deg; j++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    for (::coder::SizeType k{0}; k < deg; k++) {
      b_degree = (deg - k) - 1;
      for (::coder::SizeType b_i{0}; b_i <= b_degree; b_i++) {
        scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + 5 * stride) +
                V.size(1) * (((c - (d << 1)) - deg) - 1)] *
              scalew * (scalew - hs_inv_idx_2);
        }
        c++;
      }
    }
    d = (d + deg) + 1;
  }
  //  compute dw^4
  offset += us.size(0);
  ww4 = 24.0 * std::pow(hs_inv_idx_2, 4.0);
  for (::coder::SizeType b_i{0}; b_i < 35; b_i++) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
    }
  }
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    V[(offset + iPnt) + V.size(1) * 34] = ww4 * V[iPnt];
  }
  c = 35;
  d = 15;
  for (deg = 5; deg <= i; deg++) {
    for (::coder::SizeType j{0}; j <= deg; j++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    for (::coder::SizeType k{0}; k < deg; k++) {
      b_degree = (deg - k) - 1;
      for (::coder::SizeType b_i{0}; b_i <= b_degree; b_i++) {
        scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + 6 * stride) +
                V.size(1) * (((c - (d << 1)) - deg) - 1)] *
              scalew * (scalew - hs_inv_idx_2);
        }
        c++;
      }
    }
    d = (d + deg) + 1;
  }
}

static void e_wls_solve_sys(WlsObject *b_wls, ::coder::array<real_T, 2U> &vdops)
{
  ::coder::SizeType b_loop_ub;
  ::coder::SizeType i;
  ::coder::SizeType loop_ub;
  ::coder::SizeType nRhs;
  ::coder::SizeType nrows;
  ::coder::SizeType nrows_vdops;
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      b_loop_ub = b_wls->QR.size(0);
      for (::coder::SizeType i1{0}; i1 < b_loop_ub; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  loop_ub = b_wls->ncols;
  b_loop_ub = b_wls->nrows;
  if (loop_ub >= b_loop_ub) {
    nrows_vdops = loop_ub;
  } else {
    nrows_vdops = b_loop_ub;
  }
  vdops.set_size(nrows_vdops, nRhs);
  //  Transpose the operator for row-major
  i = nrows_vdops - b_wls->interp0;
  for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (::coder::SizeType k{0}; k < nRhs; k++) {
      for (::coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      i = b_wls->nstpnts;
      for (::coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      //  Unit weights summed together
      vdops[0] = static_cast<real_T>(b_wls->nevpnts) - s;
    }
  }
}

static void e_wls_update_rhs(WlsObject *b_wls, const int8_T diff_idx_data[],
                             const ::coder::SizeType diff_idx_size[2])
{
  ::coder::SizeType nevpnts;
  ::coder::SizeType u0;
  ::coder::SizeType u1;
  nevpnts = b_wls->nevpnts;
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(1, u0);
  for (u1 = 0; u1 < u0; u1++) {
    b_wls->rhs[u1] = 0.0;
  }
  //  Summing up rows in the differential operator
  u1 = diff_idx_size[1];
  for (::coder::SizeType jDiff{0}; jDiff < u1; jDiff++) {
    ::coder::SizeType offset;
    //  Loop through the operators
    offset = (diff_idx_data[jDiff] - 1) * b_wls->us.size(0);
    //  Sum up monomials weighted by weights for each component
    u0 = b_wls->ncols - b_wls->interp0;
    for (::coder::SizeType iMonomial{0}; iMonomial < u0; iMonomial++) {
      ::coder::SizeType j;
      j = b_wls->jpvt[iMonomial] + b_wls->interp0;
      for (::coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
        b_wls->rhs[iMonomial] =
            b_wls->rhs[iMonomial] +
            b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
      }
    }
  }
}

static void e_wls_update_rhs(WlsObject *b_wls)
{
  ::coder::SizeType nevpnts;
  ::coder::SizeType u0;
  ::coder::SizeType u1;
  nevpnts = b_wls->nevpnts;
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(1, u0);
  for (u1 = 0; u1 < u0; u1++) {
    b_wls->rhs[u1] = 0.0;
  }
  //  Summing up rows in the differential operator
  u1 = b_wls->ncols - b_wls->interp0;
  for (::coder::SizeType iMonomial{0}; iMonomial < u1; iMonomial++) {
    ::coder::SizeType j;
    j = b_wls->jpvt[iMonomial] + b_wls->interp0;
    for (::coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
      b_wls->rhs[iMonomial] =
          b_wls->rhs[iMonomial] + b_wls->V[iEval + b_wls->V.size(1) * (j - 1)];
    }
  }
}

static void f_gen_vander(const ::coder::array<real_T, 2U> &us,
                         ::coder::SizeType npoints, ::coder::SizeType degree,
                         ::coder::SizeType order,
                         const ::coder::array<real_T, 2U> &hs_inv,
                         boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  switch (us.size(1)) {
  case 1: {
    real_T h_inv_;
    ::coder::SizeType V_tmp;
    ::coder::SizeType b_npoints;
    ::coder::SizeType i;
    ::coder::SizeType i1;
    ::coder::SizeType nrblks;
    ::coder::SizeType r;
    ::coder::SizeType stride;
    boolean_T b;
    boolean_T b1;
    b_npoints = npoints - 1;
    m2cAssert(us.size(1) == 1, "");
    //  Handle input arguments
    if (npoints == 0) {
      b_npoints = us.size(0) - 1;
    } else {
      m2cAssert(npoints <= us.size(0), "Input us is too small.");
    }
    m2cAssert(degree >= 0, "Degree must be nonnegative");
    if (hs_inv.size(1) == 0) {
      h_inv_ = 1.0;
    } else {
      h_inv_ = hs_inv[0];
    }
    stride = us.size(0);
    nrblks = order + 1;
    //  Number of row blocks
    switch (order) {
    case -1:
      nrblks = 2;
      break;
    case -2:
      nrblks = 3;
      break;
    }
    V.set_size(degree + 1, us.size(0) * nrblks);
    //  Compute rows corresponding to function values
    if (degree != 0) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      i = us.size(1) * us.size(0);
      V_tmp = 0;
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= i)) {
          V_tmp = 0;
          b = true;
        } else if (b) {
          b = false;
          V_tmp = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          i1 = us.size(1) * us.size(0) - 1;
          if (V_tmp > MAX_int32_T - us.size(1)) {
            V_tmp = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            V_tmp += us.size(1);
            if (V_tmp > i1) {
              V_tmp -= i1;
            }
          }
        }
        V[iPnt] = 1.0;
        V[iPnt + V.size(1)] = us[V_tmp];
      }
    } else {
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        V[iPnt] = 1.0;
      }
    }
    i = degree + 1;
    for (::coder::SizeType ii{2}; ii <= i; ii++) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      V_tmp = us.size(1) * us.size(0);
      i1 = 0;
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= V_tmp)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          ::coder::SizeType i2;
          i2 = us.size(1) * us.size(0) - 1;
          if (i1 > MAX_int32_T - us.size(1)) {
            i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i1 += us.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        V[iPnt + V.size(1) * (ii - 1)] =
            V[iPnt + V.size(1) * (ii - 2)] * us[i1];
      }
    }
    //  Add row blocks corresponding to kth derivatives
    r = us.size(0) - 1;
    if (order >= 0) {
      for (::coder::SizeType k{0}; k < order; k++) {
        for (::coder::SizeType j{0}; j <= k; j++) {
          for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
            V[((r + iPnt) + V.size(1) * j) + 1] = 0.0;
          }
        }
        for (::coder::SizeType j{k + 1}; j <= degree; j++) {
          real_T s;
          s = h_inv_ * static_cast<real_T>(j);
          for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
            V_tmp = (r + iPnt) + 1;
            V[V_tmp + V.size(1) * j] =
                V[(V_tmp - stride) + V.size(1) * (j - 1)] * s;
          }
        }
        r += stride;
      }
    } else {
      //      computing negative orders
      if (-order > 2) {
        i = 2;
      } else {
        i = -order;
      }
      for (::coder::SizeType k{0}; k < i; k++) {
        for (::coder::SizeType j{0}; j <= k; j++) {
          for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
            V[((r + iPnt) + V.size(1) * j) + 1] = 0.0;
          }
        }
        for (::coder::SizeType j{k + 1}; j <= degree; j++) {
          real_T s;
          s = h_inv_ * static_cast<real_T>(j);
          for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
            V_tmp = (r + iPnt) + 1;
            V[V_tmp + V.size(1) * j] =
                V[(V_tmp - stride) + V.size(1) * (j - 1)] * s;
          }
        }
        r += stride;
      }
      //      Calculate Biharmonic if order = -4
    }
  } break;
  case 2:
    f_gen_vander_2d(us, npoints, degree, order, hs_inv, unimono, V);
    break;
  default:
    f_gen_vander_3d(us, npoints, degree, order, hs_inv, unimono, V);
    break;
  }
}

static void f_gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                            ::coder::SizeType npoints, ::coder::SizeType degree,
                            ::coder::SizeType order,
                            const ::coder::array<real_T, 2U> &hs_inv,
                            boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  real_T hs_inv__idx_0;
  real_T hs_inv__idx_1;
  ::coder::SizeType c;
  ::coder::SizeType deg;
  ::coder::SizeType i;
  ::coder::SizeType nrblks;
  ::coder::SizeType ret;
  ::coder::SizeType stride;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (hs_inv.size(1) == 0) {
    hs_inv__idx_0 = 1.0;
    hs_inv__idx_1 = 1.0;
  } else {
    hs_inv__idx_0 = hs_inv[0];
    hs_inv__idx_1 = hs_inv[1];
  }
  stride = us.size(0);
  if (unimono) {
    if (order > 1) {
      m2cErrMsgIdAndTxt(
          "wlslib:WrongOrder",
          "For axes-aligned monomials, derivatives cannot have cross terms.");
    }
    if (degree >= 0) {
      degree = -degree;
    }
  }
  nrblks = (order + 1) * (order + 2) / 2;
  //  Number of row blocks
  switch (order) {
  case -1:
    nrblks = 3;
    break;
  case -2:
    nrblks = 5;
    break;
  }
  if (degree >= 0) {
    ret = (degree + 1) * (degree + 2) / 2;
    unimono = false;
  } else if (unimono) {
    ret = 1 - (degree << 1);
  } else {
    ret = (1 - degree) * (1 - degree);
  }
  //  Allocate storage for V
  V.set_size(ret, us.size(0) * nrblks);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
    }
  } else {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType j{0}; j < deg; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - deg) - 1)] * us[us.size(1) * iPnt + 1];
      }
      c++;
    }
    //  Compute the bi-degree terms if degree<0
    i = -degree;
    for (deg = i; deg >= 1; deg--) {
      for (::coder::SizeType k{0}; k < deg; k++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
        }
        c++;
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 2)] * us[us.size(1) * iPnt];
        V[iPnt + V.size(1) * (c + 1)] =
            V[iPnt + V.size(1) * (c - 1)] * us[us.size(1) * iPnt + 1];
      }
      c += 2;
    }
  }
  //  compute higher order confluent Vandermonde matrix blocks incrementally
  if (order != 0) {
    real_T scaleu;
    real_T scalev;
    ::coder::SizeType offset;
    //  This is an optimized version of update_vander_ordern for first-order CVM
    m2cAssert(degree != 0, "");
    //  Compute derivative with respect to u
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      ret = stride + iPnt;
      V[ret] = 0.0;
      V[ret + V.size(1)] = V[iPnt] * hs_inv__idx_0;
      V[ret + V.size(1) * 2] = 0.0;
    }
    c = 3;
    if (!unimono) {
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      for (deg = 2; deg <= i; deg++) {
        scaleu = static_cast<real_T>(deg) * hs_inv__idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * scaleu;
        }
        c++;
        for (::coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu -= hs_inv__idx_0;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - deg)] * scaleu;
          }
          c++;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      //  Compute the bi-degree terms if degree<0
      i = -degree;
      for (::coder::SizeType len{i}; len >= 0; len--) {
        scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
        for (::coder::SizeType k{0}; k < len; k++) {
          scaleu -= hs_inv__idx_0;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - len)] * scaleu;
          }
          c++;
        }
      }
    } else {
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      for (deg = 2; deg <= i; deg++) {
        scaleu = static_cast<real_T>(deg) * hs_inv__idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - 2)] * scaleu;
        }
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
      }
    }
    //  Compute derivative with respect to v
    offset = us.size(0) + us.size(0);
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      ret = offset + iPnt;
      V[ret] = 0.0;
      V[ret + V.size(1)] = 0.0;
      V[ret + V.size(1) * 2] = V[iPnt] * hs_inv__idx_1;
    }
    c = 3;
    if (!unimono) {
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      for (deg = 2; deg <= i; deg++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        for (::coder::SizeType j{0}; j < deg; j++) {
          scalev = (static_cast<real_T>(j) + 1.0) * hs_inv__idx_1;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * ((c - deg) - 1)] * scalev;
          }
          c++;
        }
      }
      //  Compute the bi-degree terms if degree<0
      ret = -degree;
      deg = -degree;
      for (::coder::SizeType len{ret}; len >= 0; len--) {
        deg++;
        scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
        for (::coder::SizeType k{0}; k < len; k++) {
          scalev += hs_inv__idx_1;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * ((c - len) - 1)] * scalev;
          }
          c++;
        }
      }
    } else {
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      for (deg = 2; deg <= i; deg++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        scalev = static_cast<real_T>(deg) * hs_inv__idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 1)] =
              V[iPnt + V.size(1) * (c - 1)] * scalev;
        }
        c += 2;
      }
    }
    //      compute regular orders if order > 0
    if (order > 0) {
      for (::coder::SizeType dd{2}; dd <= order; dd++) {
        ::coder::SizeType i1;
        ::coder::SizeType i2;
        ::coder::SizeType offset_prev;
        //  Compute order-N CVM row blocks from order-(N-1) CVM.
        m2cAssert(degree != 0, "");
        offset = 3 * stride;
        offset_prev = stride;
        //  Compute derivative with respect to u
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        i1 = -degree;
        for (::coder::SizeType b_i{0}; b_i < 2; b_i++) {
          //  Initialize block to zero
          i2 = offset + 1;
          ret = offset + npoints;
          for (::coder::SizeType col{0}; col < 3; col++) {
            for (::coder::SizeType row{i2}; row <= ret; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 3;
          for (deg = 2; deg <= i; deg++) {
            scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
            i2 = deg - 1;
            for (::coder::SizeType j{0}; j <= i2; j++) {
              scaleu -= hs_inv__idx_0;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
              }
              c++;
            }
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          //  Compute the bi-degree terms if degree<0
          for (::coder::SizeType len{i1}; len >= 0; len--) {
            scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
            for (::coder::SizeType k{0}; k < len; k++) {
              scaleu -= hs_inv__idx_0;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
              }
              c++;
            }
          }
          offset += stride;
          offset_prev += stride;
        }
        //  Compute derivative with respect to v
        i = offset + 1;
        i2 = offset + npoints;
        for (::coder::SizeType col{0}; col < 3; col++) {
          for (::coder::SizeType row{i}; row <= i2; row++) {
            V[(row + V.size(1) * col) - 1] = 0.0;
          }
        }
        c = 3;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j < 2; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType j{2}; j <= deg; j++) {
            scalev = static_cast<real_T>(j) * hs_inv__idx_1;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[((offset_prev - stride) + iPnt) +
                    V.size(1) * ((c - deg) - 1)] *
                  scalev;
            }
            c++;
          }
        }
        //  Compute the bi-degree terms if degree<0
        deg = -degree;
        for (::coder::SizeType len{i1}; len >= 0; len--) {
          deg++;
          scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
          for (::coder::SizeType k{0}; k < len; k++) {
            scalev += hs_inv__idx_1;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[((offset_prev - stride) + iPnt) +
                    V.size(1) * ((c - len) - 1)] *
                  scalev;
            }
            c++;
          }
        }
      }
    } else if (order < -1) {
      ::coder::SizeType i1;
      ::coder::SizeType offset_prev;
      //          compute efficient laplacian and bi-laplacian
      m2cAssert(degree != 0, "");
      offset = 3 * us.size(0);
      offset_prev = us.size(0);
      //  Compute derivative with respect to u
      i = offset + 1;
      i1 = offset + npoints;
      for (::coder::SizeType col{0}; col < 3; col++) {
        for (::coder::SizeType row{i}; row <= i1; row++) {
          V[(row + V.size(1) * col) - 1] = 0.0;
        }
      }
      c = 3;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
          i1 = deg - 1;
          for (::coder::SizeType j{0}; j <= i1; j++) {
            scaleu -= hs_inv__idx_0;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        //  Compute the bi-degree terms if degree<0
        i = -degree;
        for (::coder::SizeType len{i}; len >= 0; len--) {
          scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
          for (::coder::SizeType k{0}; k < len; k++) {
            scaleu -= hs_inv__idx_0;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
            }
            c++;
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          scaleu = static_cast<real_T>(deg) * hs_inv__idx_0;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(offset_prev + iPnt) + V.size(1) * (c - 2)] * scaleu;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
          }
          c += 2;
        }
      }
      offset += us.size(0);
      offset_prev = us.size(0) + us.size(0);
      //  Compute derivative with respect to v
      if (!unimono) {
        offset_prev += us.size(0);
      }
      i = offset + 1;
      i1 = offset + npoints;
      for (::coder::SizeType col{0}; col < 3; col++) {
        for (::coder::SizeType row{i}; row <= i1; row++) {
          V[(row + V.size(1) * col) - 1] = 0.0;
        }
      }
      c = 3;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j < 2; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType j{2}; j <= deg; j++) {
            scalev = static_cast<real_T>(j) * hs_inv__idx_1;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[((offset_prev - stride) + iPnt) +
                    V.size(1) * ((c - deg) - 1)] *
                  scalev;
            }
            c++;
          }
        }
        //  Compute the bi-degree terms if degree<0
        ret = -degree;
        deg = -degree;
        for (::coder::SizeType len{ret}; len >= 0; len--) {
          deg++;
          scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
          for (::coder::SizeType k{0}; k < len; k++) {
            scalev += hs_inv__idx_1;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[((offset_prev - stride) + iPnt) +
                    V.size(1) * ((c - len) - 1)] *
                  scalev;
            }
            c++;
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          scalev = static_cast<real_T>(deg) * hs_inv__idx_1;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * (c + 1)] =
                V[(offset_prev + iPnt) + V.size(1) * (c - 1)] * scalev;
          }
          c += 2;
        }
      }
    }
  }
}

static void f_gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                            ::coder::SizeType npoints, ::coder::SizeType degree,
                            ::coder::SizeType order,
                            const ::coder::array<real_T, 2U> &hs_inv,
                            boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  real_T hs_inv_idx_0;
  real_T hs_inv_idx_1;
  real_T hs_inv_idx_2;
  ::coder::SizeType c;
  ::coder::SizeType cornerTriangle;
  ::coder::SizeType counterBottomRow;
  ::coder::SizeType d;
  ::coder::SizeType deg;
  ::coder::SizeType excess;
  ::coder::SizeType i;
  ::coder::SizeType i1;
  ::coder::SizeType maxLayers;
  ::coder::SizeType nTermsInLayer;
  ::coder::SizeType nTermsInPrevLayer;
  ::coder::SizeType nrblks;
  ::coder::SizeType ret;
  ::coder::SizeType stride;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (hs_inv.size(1) == 0) {
    hs_inv_idx_0 = 1.0;
    hs_inv_idx_1 = 1.0;
    hs_inv_idx_2 = 1.0;
  } else {
    hs_inv_idx_0 = hs_inv[0];
    hs_inv_idx_1 = hs_inv[1];
    hs_inv_idx_2 = hs_inv[2];
  }
  stride = us.size(0);
  if (unimono) {
    if (order > 1) {
      m2cErrMsgIdAndTxt(
          "wlslib:WrongOrder",
          "For axes-aligned monomials, derivatives cannot have cross terms.");
    }
    if (degree >= 0) {
      degree = -degree;
    }
  }
  nrblks = (order + 1) * (order + 2) * (order + 3) / 6;
  switch (order) {
  case -1:
    nrblks = 4;
    break;
  case -2:
    nrblks = 7;
    break;
  }
  if (degree >= 0) {
    ret = (degree + 1) * (degree + 2) * (degree + 3) / 6;
    unimono = false;
  } else if (unimono) {
    ret = 1 - 3 * degree;
  } else {
    ret = (1 - degree) * (1 - degree) * (1 - degree);
  }
  //  Allocate storage for V
  V.set_size(ret, us.size(0) * nrblks);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
      V[iPnt + V.size(1) * 3] = us[us.size(1) * iPnt + 2];
    }
  } else {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 4;
  d = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      //  Within each level, use convention of Pascal triangle with x^deg at
      for (::coder::SizeType j{0}; j < deg; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * us[us.size(1) * iPnt];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - d) - 1)] * us[us.size(1) * iPnt + 1];
      }
      c++;
      for (::coder::SizeType j{0}; j < d; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
              us[us.size(1) * iPnt + 2];
        }
        c++;
      }
      d = (d + deg) + 1;
    }
    //  Compute the tri-degree terms if degree<0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        ::coder::SizeType gap;
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 1;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType k{0}; k < deg; k++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[iPnt + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - nTermsInLayer)] *
                us[us.size(1) * iPnt + 1];
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        ret = ((degree + degree) + p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer;
        nTermsInLayer = d + 3 * (excess - cornerTriangle);
        gap = (nTermsInPrevLayer + counterBottomRow) - 1;
        i1 = nTermsInLayer - counterBottomRow;
        for (::coder::SizeType j{0}; j <= i1; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[iPnt + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - gap)] * us[us.size(1) * iPnt + 2];
          }
          c++;
        }
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 3)] * us[us.size(1) * iPnt];
        V[iPnt + V.size(1) * (c + 1)] =
            V[iPnt + V.size(1) * (c - 2)] * us[us.size(1) * iPnt + 1];
        V[iPnt + V.size(1) * (c + 2)] =
            V[iPnt + V.size(1) * (c - 1)] * us[us.size(1) * iPnt + 2];
      }
      c += 3;
    }
  }
  m2cAssert(true, "");
  if (order != 0) {
    //      compute higher order confluent Vandermonde matrix blocks
    switch (order) {
    case 1: {
      ::coder::SizeType balance;
      ::coder::SizeType offset;
      //  Compute order-1 CVM row blocks from order-0 GVM.
      m2cAssert(degree != 0, "");
      // compute derivatives with respect to u
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = stride + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = V[iPnt] * hs_inv_idx_0;
        V[ret + V.size(1) * 2] = 0.0;
        V[ret + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 3;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          real_T scaleu;
          scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scaleu;
          }
          c++;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            scaleu -= hs_inv_idx_0;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (c - d)] * scaleu;
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] = 0.0;
          }
          for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = stride + iPnt;
              V[ret + V.size(1) * (c + 1)] =
                  V[ret + V.size(1) * ((c - d) - deg)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
          }
          c += 2;
          d = (d + deg) + 1;
        }
        // tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 1;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = stride + iPnt;
                V[ret + V.size(1) * c] =
                    V[ret + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt + 1];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = (nTermsInPrevLayer + counterBottomRow) - 1;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = stride + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          real_T scaleu;
          scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - 3)] * scaleu;
          }
          c += 3;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c - 2)] = 0.0;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c - 1)] = 0.0;
          }
        }
      }
      // compute derivatives with respect to v
      offset = us.size(0) + us.size(0);
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = 0.0;
        V[ret + V.size(1) * 2] = V[iPnt] * hs_inv_idx_1;
        V[ret + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 4;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          real_T scalev;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = hs_inv_idx_1;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (c - d)] * scalev;
            }
            scalev += hs_inv_idx_1;
            c++;
          }
          scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scalev;
          }
          c++;
          for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] = V[ret + V.size(1) * ((c - d) - deg)] *
                                       us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] =
                    V[ret + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          real_T scalev;
          scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] = 0.0;
            V[ret + V.size(1) * (c + 1)] =
                V[iPnt + V.size(1) * (c - 2)] * scalev;
            V[ret + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
      // compute derivatives with respect to w
      offset += us.size(0);
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = 0.0;
        V[ret + V.size(1) * 2] = 0.0;
        V[ret + V.size(1) * 3] = V[iPnt] * hs_inv_idx_2;
      }
      c = 4;
      d = 3;
      if (!unimono) {
        real_T scalew;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[iPnt + V.size(1) * (((c - d) - deg) - 1)] * scalew;
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            ::coder::SizeType degg;
            ::coder::SizeType x_tmp;
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ::coder::SizeType partition;
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[iPnt + V.size(1) * (c - balance)] * scalew;
                }
                c++;
              }
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          real_T scalew;
          scalew = static_cast<real_T>(deg) * hs_inv_idx_2;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] =
                V[iPnt + V.size(1) * (c - 1)] * scalew;
            V[ret + V.size(1) * (c + 1)] = 0.0;
            V[ret + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
    } break;
    case 2: {
      real_T scaleu;
      real_T scalev;
      real_T scalew;
      ::coder::SizeType balance;
      ::coder::SizeType degg;
      ::coder::SizeType offset;
      ::coder::SizeType partition;
      ::coder::SizeType x_tmp;
      //  Compute order-1 CVM row blocks from order-0 GVM.
      m2cAssert(degree != 0, "");
      // compute derivatives with respect to u
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = stride + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = V[iPnt] * hs_inv_idx_0;
        V[ret + V.size(1) * 2] = 0.0;
        V[ret + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 3;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scaleu;
          }
          c++;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            scaleu -= hs_inv_idx_0;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (c - d)] * scaleu;
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] = 0.0;
          }
          for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = stride + iPnt;
              V[ret + V.size(1) * (c + 1)] =
                  V[ret + V.size(1) * ((c - d) - deg)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
          }
          c += 2;
          d = (d + deg) + 1;
        }
        // tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 1;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = stride + iPnt;
                V[ret + V.size(1) * c] =
                    V[ret + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt + 1];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = (nTermsInPrevLayer + counterBottomRow) - 1;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = stride + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - 3)] * scaleu;
          }
          c += 3;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c - 2)] = 0.0;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c - 1)] = 0.0;
          }
        }
      }
      // compute derivatives with respect to v
      offset = us.size(0) + us.size(0);
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = 0.0;
        V[ret + V.size(1) * 2] = V[iPnt] * hs_inv_idx_1;
        V[ret + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 4;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = hs_inv_idx_1;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (c - d)] * scalev;
            }
            scalev += hs_inv_idx_1;
            c++;
          }
          scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scalev;
          }
          c++;
          for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] = V[ret + V.size(1) * ((c - d) - deg)] *
                                       us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] =
                    V[ret + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] = 0.0;
            V[ret + V.size(1) * (c + 1)] =
                V[iPnt + V.size(1) * (c - 2)] * scalev;
            V[ret + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
      // compute derivatives with respect to w
      offset += us.size(0);
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = 0.0;
        V[ret + V.size(1) * 2] = 0.0;
        V[ret + V.size(1) * 3] = V[iPnt] * hs_inv_idx_2;
      }
      c = 4;
      d = 3;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[iPnt + V.size(1) * (((c - d) - deg) - 1)] * scalew;
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[iPnt + V.size(1) * (c - balance)] * scalew;
                }
                c++;
              }
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          scalew = static_cast<real_T>(deg) * hs_inv_idx_2;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] =
                V[iPnt + V.size(1) * (c - 1)] * scalew;
            V[ret + V.size(1) * (c + 1)] = 0.0;
            V[ret + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
      //  compute du^2
      offset = us.size(0) << 2;
      if (!unimono) {
        real_T uu2;
        uu2 = 2.0 * hs_inv_idx_0 * hs_inv_idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          V[ret] = 0.0;
          V[ret + V.size(1)] = 0.0;
          V[ret + V.size(1) * 2] = 0.0;
          V[ret + V.size(1) * 3] = 0.0;
          V[ret + V.size(1) * 4] = uu2 * V[iPnt];
          for (i = 0; i < 5; i++) {
            V[ret + V.size(1) * (i + 5)] = 0.0;
          }
        }
        c = 10;
        d = 6;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
          }
          c++;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            scaleu -= hs_inv_idx_0;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * (c + 1)] =
                  V[ret + V.size(1) * ((c - d) - deg)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
          }
          c += 2;
          d = (d + deg) + 1;
        }
        // compute tri degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 1;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] =
                    V[ret + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt + 1];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = (nTermsInPrevLayer + counterBottomRow) - 1;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        c = 4;
        for (::coder::SizeType col{0}; col < 4; col++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * col] = 0.0;
          }
        }
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - 3)] * scaleu;
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 1)] = 0.0;
            V[ret + V.size(1) * (c + 2)] = 0.0;
          }
          c += 3;
        }
      }
      if (order > 0) {
        real_T uv;
        //      compute du*dv
        offset += us.size(0);
        uv = hs_inv_idx_0 * hs_inv_idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          for (i = 0; i < 5; i++) {
            V[ret + V.size(1) * i] = 0.0;
          }
          V[ret + V.size(1) * 5] = uv * V[iPnt];
          V[ret + V.size(1) * 6] = 0.0;
          V[ret + V.size(1) * 7] = 0.0;
          V[ret + V.size(1) * 8] = 0.0;
          V[ret + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 7;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = hs_inv_idx_1;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + stride) + V.size(1) * (c - d)] * scalev;
            }
            scalev += hs_inv_idx_1;
            c++;
          }
          scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] * scalev;
          }
          c++;
          for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] = V[ret + V.size(1) * ((c - d) - deg)] *
                                       us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  implicitly calculating number of elements in corner Pascal
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((stride << 1) + iPnt) +
                      V.size(1) * (c - nTermsInLayer)] *
                    static_cast<real_T>(-degree - kdegree) * hs_inv_idx_0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      }
      //  compute dv^2
      offset += us.size(0);
      if (!unimono) {
        real_T vv2;
        vv2 = 2.0 * hs_inv_idx_1 * hs_inv_idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          for (i = 0; i < 6; i++) {
            V[ret + V.size(1) * i] = 0.0;
          }
          V[ret + V.size(1) * 6] = vv2 * V[iPnt];
          V[ret + V.size(1) * 7] = 0.0;
          V[ret + V.size(1) * 8] = 0.0;
          V[ret + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 7;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = hs_inv_idx_1;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + (stride << 1)) + V.size(1) * (c - d)] * scalev;
            }
            scalev += hs_inv_idx_1;
            c++;
          }
          scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[((stride << 1) + iPnt) + V.size(1) * (c - d)] * scalev;
          }
          c++;
          for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] = V[ret + V.size(1) * ((c - d) - deg)] *
                                       us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] =
                    V[ret + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        c = 4;
        for (::coder::SizeType col{0}; col < 5; col++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * col] = 0.0;
          }
        }
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * (c + 1)] =
                V[(iPnt + (stride << 1)) + V.size(1) * (c - 2)] * scalev;
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] = 0.0;
            V[ret + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
      if (order > 0) {
        real_T uw;
        real_T vw;
        //      compute du*dw
        offset = (offset + us.size(0)) - 1;
        uw = hs_inv_idx_0 * hs_inv_idx_2;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = (offset + iPnt) + 1;
          for (i = 0; i < 7; i++) {
            V[ret + V.size(1) * i] = 0.0;
          }
          V[ret + V.size(1) * 7] = uw * V[iPnt];
          V[ret + V.size(1) * 8] = 0.0;
          V[ret + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] =
                    V[(iPnt + stride) + V.size(1) * (((c - d) - deg) - 1)] *
                    scalew;
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i1 = 1 - degree;
          for (::coder::SizeType p{i1}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[((iPnt + offset) + V.size(1) * c) + 1] =
                      V[(iPnt + stride) + V.size(1) * (c - balance)] * scalew;
                }
                c++;
              }
            }
          }
        }
        //      compute dv*dw
        offset = (offset + us.size(0)) + 1;
        vw = hs_inv_idx_1 * hs_inv_idx_2;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          for (i1 = 0; i1 < 8; i1++) {
            V[ret + V.size(1) * i1] = 0.0;
          }
          V[ret + V.size(1) * 8] = vw * V[iPnt];
          V[ret + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(iPnt + (stride << 1)) +
                      V.size(1) * (((c - d) - deg) - 1)] *
                    scalew;
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[(iPnt + (stride << 1)) + V.size(1) * (c - balance)] *
                      scalew;
                }
                c++;
              }
            }
          }
        }
      }
      //  compute dw^2
      offset += us.size(0);
      if (!unimono) {
        real_T ww2;
        ww2 = 2.0 * hs_inv_idx_2 * hs_inv_idx_2;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          for (i = 0; i < 9; i++) {
            V[ret + V.size(1) * i] = 0.0;
          }
          V[ret + V.size(1) * 9] = ww2 * V[iPnt];
        }
        c = 10;
        d = 6;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(iPnt + 3 * stride) + V.size(1) * (((c - d) - deg) - 1)] *
                    scalew;
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[(iPnt + 3 * stride) + V.size(1) * (c - balance)] *
                      scalew;
                }
                c++;
              }
            }
          }
        }
      } else {
        c = 4;
        for (::coder::SizeType col{0}; col < 6; col++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * col] = 0.0;
          }
        }
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          scalew = static_cast<real_T>(deg) * hs_inv_idx_2;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] =
                V[(iPnt + 3 * stride) + V.size(1) * (c - 1)] * scalew;
            V[ret + V.size(1) * (c + 1)] = 0.0;
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
    } break;
    case -1: {
      ::coder::SizeType balance;
      ::coder::SizeType offset;
      //  Compute order-1 CVM row blocks from order-0 GVM.
      m2cAssert(degree != 0, "");
      // compute derivatives with respect to u
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = stride + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = V[iPnt] * hs_inv_idx_0;
        V[ret + V.size(1) * 2] = 0.0;
        V[ret + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 3;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          real_T scaleu;
          scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scaleu;
          }
          c++;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            scaleu -= hs_inv_idx_0;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (c - d)] * scaleu;
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] = 0.0;
          }
          for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = stride + iPnt;
              V[ret + V.size(1) * (c + 1)] =
                  V[ret + V.size(1) * ((c - d) - deg)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
          }
          c += 2;
          d = (d + deg) + 1;
        }
        // tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 1;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = stride + iPnt;
                V[ret + V.size(1) * c] =
                    V[ret + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt + 1];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = (nTermsInPrevLayer + counterBottomRow) - 1;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = stride + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          real_T scaleu;
          scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - 3)] * scaleu;
          }
          c += 3;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c - 2)] = 0.0;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c - 1)] = 0.0;
          }
        }
      }
      // compute derivatives with respect to v
      offset = us.size(0) + us.size(0);
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = 0.0;
        V[ret + V.size(1) * 2] = V[iPnt] * hs_inv_idx_1;
        V[ret + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 4;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          real_T scalev;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = hs_inv_idx_1;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (c - d)] * scalev;
            }
            scalev += hs_inv_idx_1;
            c++;
          }
          scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scalev;
          }
          c++;
          for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] = V[ret + V.size(1) * ((c - d) - deg)] *
                                       us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] =
                    V[ret + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          real_T scalev;
          scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] = 0.0;
            V[ret + V.size(1) * (c + 1)] =
                V[iPnt + V.size(1) * (c - 2)] * scalev;
            V[ret + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
      // compute derivatives with respect to w
      offset += us.size(0);
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = 0.0;
        V[ret + V.size(1) * 2] = 0.0;
        V[ret + V.size(1) * 3] = V[iPnt] * hs_inv_idx_2;
      }
      c = 4;
      d = 3;
      if (!unimono) {
        real_T scalew;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[iPnt + V.size(1) * (((c - d) - deg) - 1)] * scalew;
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            ::coder::SizeType degg;
            ::coder::SizeType x_tmp;
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ::coder::SizeType partition;
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[iPnt + V.size(1) * (c - balance)] * scalew;
                }
                c++;
              }
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          real_T scalew;
          scalew = static_cast<real_T>(deg) * hs_inv_idx_2;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] =
                V[iPnt + V.size(1) * (c - 1)] * scalew;
            V[ret + V.size(1) * (c + 1)] = 0.0;
            V[ret + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
    } break;
    case -2: {
      real_T scaleu;
      real_T scalev;
      real_T scalew;
      ::coder::SizeType balance;
      ::coder::SizeType degg;
      ::coder::SizeType offset;
      ::coder::SizeType partition;
      ::coder::SizeType x_tmp;
      //  Compute order-1 CVM row blocks from order-0 GVM.
      m2cAssert(degree != 0, "");
      // compute derivatives with respect to u
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = stride + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = V[iPnt] * hs_inv_idx_0;
        V[ret + V.size(1) * 2] = 0.0;
        V[ret + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 3;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scaleu;
          }
          c++;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            scaleu -= hs_inv_idx_0;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (c - d)] * scaleu;
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] = 0.0;
          }
          for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = stride + iPnt;
              V[ret + V.size(1) * (c + 1)] =
                  V[ret + V.size(1) * ((c - d) - deg)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
          }
          c += 2;
          d = (d + deg) + 1;
        }
        // tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 1;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = stride + iPnt;
                V[ret + V.size(1) * c] =
                    V[ret + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt + 1];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = (nTermsInPrevLayer + counterBottomRow) - 1;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = stride + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - 3)] * scaleu;
          }
          c += 3;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c - 2)] = 0.0;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c - 1)] = 0.0;
          }
        }
      }
      // compute derivatives with respect to v
      offset = us.size(0) + us.size(0);
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = 0.0;
        V[ret + V.size(1) * 2] = V[iPnt] * hs_inv_idx_1;
        V[ret + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 4;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = hs_inv_idx_1;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (c - d)] * scalev;
            }
            scalev += hs_inv_idx_1;
            c++;
          }
          scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scalev;
          }
          c++;
          for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] = V[ret + V.size(1) * ((c - d) - deg)] *
                                       us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] =
                    V[ret + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] = 0.0;
            V[ret + V.size(1) * (c + 1)] =
                V[iPnt + V.size(1) * (c - 2)] * scalev;
            V[ret + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
      // compute derivatives with respect to w
      offset += us.size(0);
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret] = 0.0;
        V[ret + V.size(1)] = 0.0;
        V[ret + V.size(1) * 2] = 0.0;
        V[ret + V.size(1) * 3] = V[iPnt] * hs_inv_idx_2;
      }
      c = 4;
      d = 3;
      if (!unimono) {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[iPnt + V.size(1) * (((c - d) - deg) - 1)] * scalew;
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[iPnt + V.size(1) * (c - balance)] * scalew;
                }
                c++;
              }
            }
          }
        }
      } else {
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          scalew = static_cast<real_T>(deg) * hs_inv_idx_2;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] =
                V[iPnt + V.size(1) * (c - 1)] * scalew;
            V[ret + V.size(1) * (c + 1)] = 0.0;
            V[ret + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
      //  compute du^2
      offset = us.size(0) << 2;
      if (!unimono) {
        real_T uu2;
        uu2 = 2.0 * hs_inv_idx_0 * hs_inv_idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          V[ret] = 0.0;
          V[ret + V.size(1)] = 0.0;
          V[ret + V.size(1) * 2] = 0.0;
          V[ret + V.size(1) * 3] = 0.0;
          V[ret + V.size(1) * 4] = uu2 * V[iPnt];
          for (i = 0; i < 5; i++) {
            V[ret + V.size(1) * (i + 5)] = 0.0;
          }
        }
        c = 10;
        d = 6;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
          }
          c++;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            scaleu -= hs_inv_idx_0;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * (c + 1)] =
                  V[ret + V.size(1) * ((c - d) - deg)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
          }
          c += 2;
          d = (d + deg) + 1;
        }
        // compute tri degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 1;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] =
                    V[ret + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt + 1];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = (nTermsInPrevLayer + counterBottomRow) - 1;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        c = 4;
        for (::coder::SizeType col{0}; col < 4; col++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * col] = 0.0;
          }
        }
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - 3)] * scaleu;
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 1)] = 0.0;
            V[ret + V.size(1) * (c + 2)] = 0.0;
          }
          c += 3;
        }
      }
      if (order > 0) {
        real_T uv;
        //      compute du*dv
        offset += us.size(0);
        uv = hs_inv_idx_0 * hs_inv_idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          for (i = 0; i < 5; i++) {
            V[ret + V.size(1) * i] = 0.0;
          }
          V[ret + V.size(1) * 5] = uv * V[iPnt];
          V[ret + V.size(1) * 6] = 0.0;
          V[ret + V.size(1) * 7] = 0.0;
          V[ret + V.size(1) * 8] = 0.0;
          V[ret + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 7;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = hs_inv_idx_1;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + stride) + V.size(1) * (c - d)] * scalev;
            }
            scalev += hs_inv_idx_1;
            c++;
          }
          scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] * scalev;
          }
          c++;
          for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] = V[ret + V.size(1) * ((c - d) - deg)] *
                                       us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  implicitly calculating number of elements in corner Pascal
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((stride << 1) + iPnt) +
                      V.size(1) * (c - nTermsInLayer)] *
                    static_cast<real_T>(-degree - kdegree) * hs_inv_idx_0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      }
      //  compute dv^2
      offset += us.size(0);
      if (!unimono) {
        real_T vv2;
        vv2 = 2.0 * hs_inv_idx_1 * hs_inv_idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          for (i = 0; i < 6; i++) {
            V[ret + V.size(1) * i] = 0.0;
          }
          V[ret + V.size(1) * 6] = vv2 * V[iPnt];
          V[ret + V.size(1) * 7] = 0.0;
          V[ret + V.size(1) * 8] = 0.0;
          V[ret + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 7;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = hs_inv_idx_1;
          for (::coder::SizeType j{0}; j <= deg - 2; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + (stride << 1)) + V.size(1) * (c - d)] * scalev;
            }
            scalev += hs_inv_idx_1;
            c++;
          }
          scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[((stride << 1) + iPnt) + V.size(1) * (c - d)] * scalev;
          }
          c++;
          for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              ret = offset + iPnt;
              V[ret + V.size(1) * c] = V[ret + V.size(1) * ((c - d) - deg)] *
                                       us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] =
                    V[ret + V.size(1) * (c - nTermsInLayer)] *
                    us[us.size(1) * iPnt];
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            ret = (((p + degree) << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            i1 = nTermsInLayer - counterBottomRow;
            for (::coder::SizeType j{0}; j <= i1; j++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                ret = offset + iPnt;
                V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - balance)] *
                                         us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      } else {
        c = 4;
        for (::coder::SizeType col{0}; col < 5; col++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * col] = 0.0;
          }
        }
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * (c + 1)] =
                V[(iPnt + (stride << 1)) + V.size(1) * (c - 2)] * scalev;
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] = 0.0;
            V[ret + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
      if (order > 0) {
        real_T uw;
        real_T vw;
        //      compute du*dw
        offset = (offset + us.size(0)) - 1;
        uw = hs_inv_idx_0 * hs_inv_idx_2;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = (offset + iPnt) + 1;
          for (i = 0; i < 7; i++) {
            V[ret + V.size(1) * i] = 0.0;
          }
          V[ret + V.size(1) * 7] = uw * V[iPnt];
          V[ret + V.size(1) * 8] = 0.0;
          V[ret + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] =
                    V[(iPnt + stride) + V.size(1) * (((c - d) - deg) - 1)] *
                    scalew;
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i1 = 1 - degree;
          for (::coder::SizeType p{i1}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[((iPnt + offset) + V.size(1) * c) + 1] =
                      V[(iPnt + stride) + V.size(1) * (c - balance)] * scalew;
                }
                c++;
              }
            }
          }
        }
        //      compute dv*dw
        offset = (offset + us.size(0)) + 1;
        vw = hs_inv_idx_1 * hs_inv_idx_2;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          for (i1 = 0; i1 < 8; i1++) {
            V[ret + V.size(1) * i1] = 0.0;
          }
          V[ret + V.size(1) * 8] = vw * V[iPnt];
          V[ret + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(iPnt + (stride << 1)) +
                      V.size(1) * (((c - d) - deg) - 1)] *
                    scalew;
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[(iPnt + (stride << 1)) + V.size(1) * (c - balance)] *
                      scalew;
                }
                c++;
              }
            }
          }
        }
      }
      //  compute dw^2
      offset += us.size(0);
      if (!unimono) {
        real_T ww2;
        ww2 = 2.0 * hs_inv_idx_2 * hs_inv_idx_2;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          for (i = 0; i < 9; i++) {
            V[ret + V.size(1) * i] = 0.0;
          }
          V[ret + V.size(1) * 9] = ww2 * V[iPnt];
        }
        c = 10;
        d = 6;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 3; deg <= i; deg++) {
          for (::coder::SizeType j{0}; j <= deg; j++) {
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (::coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(iPnt + 3 * stride) + V.size(1) * (((c - d) - deg) - 1)] *
                    scalew;
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (::coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (::coder::SizeType k{0}; k < deg; k++) {
              for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x_tmp = p + degree;
            ret = ((x_tmp << 1) - p) - 1;
            if (ret < 0) {
              ret = 0;
            }
            excess += ret;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            degg = -degree;
            for (::coder::SizeType k{0}; k < degg; k++) {
              ret = (x_tmp - k) - 1;
              if (ret < 0) {
                ret = -ret;
              }
              partition = -degree - ret;
              for (::coder::SizeType j{0}; j <= partition; j++) {
                scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
                for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[(iPnt + 3 * stride) + V.size(1) * (c - balance)] *
                      scalew;
                }
                c++;
              }
            }
          }
        }
      } else {
        c = 4;
        for (::coder::SizeType col{0}; col < 6; col++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * col] = 0.0;
          }
        }
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          scalew = static_cast<real_T>(deg) * hs_inv_idx_2;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * (c + 2)] =
                V[(iPnt + 3 * stride) + V.size(1) * (c - 1)] * scalew;
            V[ret + V.size(1) * (c + 1)] = 0.0;
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c += 3;
        }
      }
    } break;
    default:
      m2cAssert(false, "Order must be 0, 1, 2, -1, -2, or -4.");
      break;
    }
  }
}

static real_T find_kth_shortest_dist(::coder::array<real_T, 1U> &arr,
                                     ::coder::SizeType k, ::coder::SizeType l,
                                     ::coder::SizeType r)
{
  real_T dist;
  real_T val;
  ::coder::SizeType i;
  ::coder::SizeType j;
  //  Find the kth smallest number in arr(l:r).
  if (k < l) {
    k = l;
  }
  if (k > r) {
    k = r;
  }
  val = arr[l - 1];
  i = l;
  j = r;
  while (i <= j) {
    real_T d;
    real_T d1;
    ::coder::SizeType exitg1;
    do {
      exitg1 = 0;
      d = arr[i - 1];
      if (d < val) {
        i++;
      } else {
        exitg1 = 1;
      }
    } while (exitg1 == 0);
    do {
      exitg1 = 0;
      d1 = arr[j - 1];
      if (d1 > val) {
        j--;
      } else {
        exitg1 = 1;
      }
    } while (exitg1 == 0);
    if (i <= j) {
      arr[i - 1] = d1;
      arr[j - 1] = d;
      i++;
      j--;
    }
  }
  if (k <= j) {
    dist = find_kth_shortest_dist(arr, k, l, j);
  } else if (k >= i) {
    dist = find_kth_shortest_dist(arr, k, i, r);
  } else {
    dist = val;
  }
  return dist;
}

static void g_gen_vander(const ::coder::array<real_T, 2U> &us,
                         ::coder::SizeType npoints, ::coder::SizeType degree,
                         const ::coder::array<real_T, 2U> &hs_inv,
                         boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  switch (us.size(1)) {
  case 1: {
    real_T h_inv_;
    ::coder::SizeType V_tmp;
    ::coder::SizeType b_npoints;
    ::coder::SizeType i;
    ::coder::SizeType i1;
    ::coder::SizeType r;
    ::coder::SizeType stride;
    boolean_T b;
    boolean_T b1;
    b_npoints = npoints - 1;
    m2cAssert(us.size(1) == 1, "");
    //  Handle input arguments
    if (npoints == 0) {
      b_npoints = us.size(0) - 1;
    } else {
      m2cAssert(npoints <= us.size(0), "Input us is too small.");
    }
    m2cAssert(degree >= 0, "Degree must be nonnegative");
    if (hs_inv.size(1) == 0) {
      h_inv_ = 1.0;
    } else {
      h_inv_ = hs_inv[0];
    }
    stride = us.size(0);
    //  Number of row blocks
    V.set_size(degree + 1, us.size(0) * 3);
    //  Compute rows corresponding to function values
    if (degree != 0) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      V_tmp = us.size(1) * us.size(0);
      i = 0;
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= V_tmp)) {
          i = 0;
          b = true;
        } else if (b) {
          b = false;
          i = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          i1 = us.size(1) * us.size(0) - 1;
          if (i > MAX_int32_T - us.size(1)) {
            i = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i += us.size(1);
            if (i > i1) {
              i -= i1;
            }
          }
        }
        V[iPnt] = 1.0;
        V[iPnt + V.size(1)] = us[i];
      }
    } else {
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        V[iPnt] = 1.0;
      }
    }
    V_tmp = degree + 1;
    for (::coder::SizeType ii{2}; ii <= V_tmp; ii++) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      i = us.size(1) * us.size(0);
      i1 = 0;
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          ::coder::SizeType i2;
          i2 = us.size(1) * us.size(0) - 1;
          if (i1 > MAX_int32_T - us.size(1)) {
            i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i1 += us.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        V[iPnt + V.size(1) * (ii - 1)] =
            V[iPnt + V.size(1) * (ii - 2)] * us[i1];
      }
    }
    //  Add row blocks corresponding to kth derivatives
    r = us.size(0);
    for (::coder::SizeType k{0}; k < 2; k++) {
      for (::coder::SizeType j{0}; j <= k; j++) {
        for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
          V[(r + iPnt) + V.size(1) * j] = 0.0;
        }
      }
      for (::coder::SizeType j{k + 1}; j <= degree; j++) {
        real_T s;
        s = h_inv_ * static_cast<real_T>(j);
        for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
          V_tmp = (r + iPnt) + 1;
          V[(V_tmp + V.size(1) * j) - 1] =
              V[((V_tmp - stride) + V.size(1) * (j - 1)) - 1] * s;
        }
      }
      r += stride;
    }
  } break;
  case 2:
    g_gen_vander_2d(us, npoints, degree, hs_inv, unimono, V);
    break;
  default:
    g_gen_vander_3d(us, npoints, degree, hs_inv, unimono, V);
    break;
  }
}

static void g_gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                            ::coder::SizeType npoints, ::coder::SizeType degree,
                            const ::coder::array<real_T, 2U> &hs_inv,
                            boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  real_T hs_inv__idx_0;
  real_T hs_inv__idx_1;
  real_T scaleu;
  real_T scalev;
  ::coder::SizeType c;
  ::coder::SizeType deg;
  ::coder::SizeType i;
  ::coder::SizeType i1;
  ::coder::SizeType i2;
  ::coder::SizeType offset;
  ::coder::SizeType offset_prev;
  ::coder::SizeType ret;
  ::coder::SizeType stride;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (hs_inv.size(1) == 0) {
    hs_inv__idx_0 = 1.0;
    hs_inv__idx_1 = 1.0;
  } else {
    hs_inv__idx_0 = hs_inv[0];
    hs_inv__idx_1 = hs_inv[1];
  }
  stride = us.size(0);
  if (unimono) {
    m2cErrMsgIdAndTxt(
        "wlslib:WrongOrder",
        "For axes-aligned monomials, derivatives cannot have cross terms.");
    if (degree >= 0) {
      degree = -degree;
    }
  }
  //  Number of row blocks
  if (degree >= 0) {
    ret = (degree + 1) * (degree + 2) / 2;
    unimono = false;
  } else if (unimono) {
    ret = 1 - (degree << 1);
  } else {
    ret = (1 - degree) * (1 - degree);
  }
  //  Allocate storage for V
  V.set_size(ret, us.size(0) * 6);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
    }
  } else {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType j{0}; j < deg; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - deg) - 1)] * us[us.size(1) * iPnt + 1];
      }
      c++;
    }
    //  Compute the bi-degree terms if degree<0
    i = -degree;
    for (deg = i; deg >= 1; deg--) {
      for (::coder::SizeType k{0}; k < deg; k++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
        }
        c++;
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 2)] * us[us.size(1) * iPnt];
        V[iPnt + V.size(1) * (c + 1)] =
            V[iPnt + V.size(1) * (c - 1)] * us[us.size(1) * iPnt + 1];
      }
      c += 2;
    }
  }
  //  compute higher order confluent Vandermonde matrix blocks incrementally
  m2cAssert(degree != 0, "");
  //  Compute derivative with respect to u
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = stride + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = V[iPnt] * hs_inv__idx_0;
    V[ret + V.size(1) * 2] = 0.0;
  }
  c = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scaleu = static_cast<real_T>(deg) * hs_inv__idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * scaleu;
      }
      c++;
      for (::coder::SizeType j{0}; j <= deg - 2; j++) {
        scaleu -= hs_inv__idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * scaleu;
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    //  Compute the bi-degree terms if degree<0
    i = -degree;
    for (::coder::SizeType len{i}; len >= 0; len--) {
      scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
      for (::coder::SizeType k{0}; k < len; k++) {
        scaleu -= hs_inv__idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - len)] * scaleu;
        }
        c++;
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scaleu = static_cast<real_T>(deg) * hs_inv__idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 2)] * scaleu;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
      }
      c += 2;
    }
  }
  //  Compute derivative with respect to v
  offset = us.size(0) + us.size(0);
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = offset + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = 0.0;
    V[ret + V.size(1) * 2] = V[iPnt] * hs_inv__idx_1;
  }
  c = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
      for (::coder::SizeType j{0}; j < deg; j++) {
        scalev = (static_cast<real_T>(j) + 1.0) * hs_inv__idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * ((c - deg) - 1)] * scalev;
        }
        c++;
      }
    }
    //  Compute the bi-degree terms if degree<0
    ret = -degree;
    deg = -degree;
    for (::coder::SizeType len{ret}; len >= 0; len--) {
      deg++;
      scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
      for (::coder::SizeType k{0}; k < len; k++) {
        scalev += hs_inv__idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * ((c - len) - 1)] * scalev;
        }
        c++;
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      scalev = static_cast<real_T>(deg) * hs_inv__idx_1;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * (c + 1)] =
            V[iPnt + V.size(1) * (c - 1)] * scalev;
      }
      c += 2;
    }
  }
  //      compute regular orders if order > 0
  m2cAssert(degree != 0, "");
  offset = 3 * us.size(0);
  offset_prev = us.size(0);
  //  Compute derivative with respect to u
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  i1 = -degree;
  for (::coder::SizeType b_i{0}; b_i < 2; b_i++) {
    //  Initialize block to zero
    i2 = offset + 1;
    ret = offset + npoints;
    for (::coder::SizeType col{0}; col < 3; col++) {
      for (::coder::SizeType row{i2}; row <= ret; row++) {
        V[(row + V.size(1) * col) - 1] = 0.0;
      }
    }
    c = 3;
    for (deg = 2; deg <= i; deg++) {
      scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
      i2 = deg - 1;
      for (::coder::SizeType j{0}; j <= i2; j++) {
        scaleu -= hs_inv__idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    //  Compute the bi-degree terms if degree<0
    for (::coder::SizeType len{i1}; len >= 0; len--) {
      scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
      for (::coder::SizeType k{0}; k < len; k++) {
        scaleu -= hs_inv__idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
        }
        c++;
      }
    }
    offset += stride;
    offset_prev += stride;
  }
  //  Compute derivative with respect to v
  i = offset + 1;
  i2 = offset + npoints;
  for (::coder::SizeType col{0}; col < 3; col++) {
    for (::coder::SizeType row{i}; row <= i2; row++) {
      V[(row + V.size(1) * col) - 1] = 0.0;
    }
  }
  c = 3;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 2; deg <= i; deg++) {
    for (::coder::SizeType j{0}; j < 2; j++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    for (::coder::SizeType j{2}; j <= deg; j++) {
      scalev = static_cast<real_T>(j) * hs_inv__idx_1;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - deg) - 1)] *
            scalev;
      }
      c++;
    }
  }
  //  Compute the bi-degree terms if degree<0
  deg = -degree;
  for (::coder::SizeType len{i1}; len >= 0; len--) {
    deg++;
    scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
    for (::coder::SizeType k{0}; k < len; k++) {
      scalev += hs_inv__idx_1;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - len) - 1)] *
            scalev;
      }
      c++;
    }
  }
}

static void g_gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                            ::coder::SizeType npoints, ::coder::SizeType degree,
                            const ::coder::array<real_T, 2U> &hs_inv,
                            boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  real_T hs_inv_idx_0;
  real_T hs_inv_idx_1;
  real_T hs_inv_idx_2;
  real_T scaleu;
  real_T scalev;
  real_T scalew;
  real_T uv;
  real_T uw;
  real_T vw;
  ::coder::SizeType balance;
  ::coder::SizeType c;
  ::coder::SizeType cornerTriangle;
  ::coder::SizeType counterBottomRow;
  ::coder::SizeType d;
  ::coder::SizeType deg;
  ::coder::SizeType degg;
  ::coder::SizeType excess;
  ::coder::SizeType i;
  ::coder::SizeType i1;
  ::coder::SizeType maxLayers;
  ::coder::SizeType nTermsInLayer;
  ::coder::SizeType nTermsInPrevLayer;
  ::coder::SizeType offset;
  ::coder::SizeType partition;
  ::coder::SizeType ret;
  ::coder::SizeType stride;
  ::coder::SizeType x_tmp;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (hs_inv.size(1) == 0) {
    hs_inv_idx_0 = 1.0;
    hs_inv_idx_1 = 1.0;
    hs_inv_idx_2 = 1.0;
  } else {
    hs_inv_idx_0 = hs_inv[0];
    hs_inv_idx_1 = hs_inv[1];
    hs_inv_idx_2 = hs_inv[2];
  }
  stride = us.size(0);
  if (unimono) {
    m2cErrMsgIdAndTxt(
        "wlslib:WrongOrder",
        "For axes-aligned monomials, derivatives cannot have cross terms.");
    if (degree >= 0) {
      degree = -degree;
    }
  }
  if (degree >= 0) {
    ret = (degree + 1) * (degree + 2) * (degree + 3) / 6;
    unimono = false;
  } else if (unimono) {
    ret = 1 - 3 * degree;
  } else {
    ret = (1 - degree) * (1 - degree) * (1 - degree);
  }
  //  Allocate storage for V
  V.set_size(ret, us.size(0) * 10);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
      V[iPnt + V.size(1) * 3] = us[us.size(1) * iPnt + 2];
    }
  } else {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 4;
  d = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      //  Within each level, use convention of Pascal triangle with x^deg at
      for (::coder::SizeType j{0}; j < deg; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * us[us.size(1) * iPnt];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - d) - 1)] * us[us.size(1) * iPnt + 1];
      }
      c++;
      for (::coder::SizeType j{0}; j < d; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
              us[us.size(1) * iPnt + 2];
        }
        c++;
      }
      d = (d + deg) + 1;
    }
    //  Compute the tri-degree terms if degree<0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        ::coder::SizeType gap;
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 1;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType k{0}; k < deg; k++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[iPnt + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - nTermsInLayer)] *
                us[us.size(1) * iPnt + 1];
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        ret = ((degree + degree) + p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer;
        nTermsInLayer = d + 3 * (excess - cornerTriangle);
        gap = (nTermsInPrevLayer + counterBottomRow) - 1;
        i1 = nTermsInLayer - counterBottomRow;
        for (::coder::SizeType j{0}; j <= i1; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[iPnt + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - gap)] * us[us.size(1) * iPnt + 2];
          }
          c++;
        }
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 3)] * us[us.size(1) * iPnt];
        V[iPnt + V.size(1) * (c + 1)] =
            V[iPnt + V.size(1) * (c - 2)] * us[us.size(1) * iPnt + 1];
        V[iPnt + V.size(1) * (c + 2)] =
            V[iPnt + V.size(1) * (c - 1)] * us[us.size(1) * iPnt + 2];
      }
      c += 3;
    }
  }
  m2cAssert(true, "");
  //      compute higher order confluent Vandermonde matrix blocks
  m2cAssert(degree != 0, "");
  // compute derivatives with respect to u
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = stride + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = V[iPnt] * hs_inv_idx_0;
    V[ret + V.size(1) * 2] = 0.0;
    V[ret + V.size(1) * 3] = 0.0;
  }
  c = 4;
  d = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * scaleu;
      }
      c++;
      for (::coder::SizeType j{0}; j <= deg - 2; j++) {
        scaleu -= hs_inv_idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * scaleu;
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] = 0.0;
      }
      for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = stride + iPnt;
          V[ret + V.size(1) * (c + 1)] =
              V[ret + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
      }
      c += 2;
      d = (d + deg) + 1;
    }
    // tri-degree terms if degree < 0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 1;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = stride + iPnt;
            V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - nTermsInLayer)] *
                                     us[us.size(1) * iPnt + 1];
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        ret = (((p + degree) << 1) - p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer;
        nTermsInLayer = d + 3 * (excess - cornerTriangle);
        balance = (nTermsInPrevLayer + counterBottomRow) - 1;
        i1 = nTermsInLayer - counterBottomRow;
        for (::coder::SizeType j{0}; j <= i1; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = stride + iPnt;
            V[ret + V.size(1) * c] =
                V[ret + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
          }
          c++;
        }
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 3)] * scaleu;
      }
      c += 3;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * (c - 2)] = 0.0;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * (c - 1)] = 0.0;
      }
    }
  }
  // compute derivatives with respect to v
  offset = us.size(0) + us.size(0);
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = offset + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = 0.0;
    V[ret + V.size(1) * 2] = V[iPnt] * hs_inv_idx_1;
    V[ret + V.size(1) * 3] = 0.0;
  }
  c = 4;
  d = 4;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
      scalev = hs_inv_idx_1;
      for (::coder::SizeType j{0}; j <= deg - 2; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * scalev;
        }
        scalev += hs_inv_idx_1;
        c++;
      }
      scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * scalev;
      }
      c++;
      for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          V[ret + V.size(1) * c] =
              V[ret + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
      d = (d + deg) + 1;
    }
    // compute the tri-degree terms if degree < 0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d - 2;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 0;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - nTermsInLayer)] *
                                     us[us.size(1) * iPnt];
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        ret = (((p + degree) << 1) - p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer + 1;
        nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
        balance = nTermsInPrevLayer + counterBottomRow;
        i1 = nTermsInLayer - counterBottomRow;
        for (::coder::SizeType j{0}; j <= i1; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * c] =
                V[ret + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
          }
          c++;
        }
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret + V.size(1) * (c + 2)] = 0.0;
        V[ret + V.size(1) * (c + 1)] = V[iPnt + V.size(1) * (c - 2)] * scalev;
        V[ret + V.size(1) * c] = 0.0;
      }
      c += 3;
    }
  }
  // compute derivatives with respect to w
  offset += us.size(0);
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = offset + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = 0.0;
    V[ret + V.size(1) * 2] = 0.0;
    V[ret + V.size(1) * 3] = V[iPnt] * hs_inv_idx_2;
  }
  c = 4;
  d = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType j{0}; j <= deg; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      for (::coder::SizeType k{0}; k < deg; k++) {
        i1 = (deg - k) - 1;
        for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
          scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (((c - d) - deg) - 1)] * scalew;
          }
          c++;
        }
      }
      d = (d + deg) + 1;
    }
    // compute tri-degree terms if degree < 0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 0;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType k{0}; k < deg; k++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        x_tmp = p + degree;
        ret = ((x_tmp << 1) - p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer;
        nTermsInLayer = d + 3 * (excess - cornerTriangle);
        balance = nTermsInPrevLayer + counterBottomRow;
        degg = -degree;
        for (::coder::SizeType k{0}; k < degg; k++) {
          ret = (x_tmp - k) - 1;
          if (ret < 0) {
            ret = -ret;
          }
          partition = -degree - ret;
          for (::coder::SizeType j{0}; j <= partition; j++) {
            scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(iPnt + offset) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (c - balance)] * scalew;
            }
            c++;
          }
        }
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scalew = static_cast<real_T>(deg) * hs_inv_idx_2;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret + V.size(1) * (c + 2)] = V[iPnt + V.size(1) * (c - 1)] * scalew;
        V[ret + V.size(1) * (c + 1)] = 0.0;
        V[ret + V.size(1) * c] = 0.0;
      }
      c += 3;
    }
  }
  //  compute du^2
  offset = us.size(0) << 2;
  if (!unimono) {
    real_T uu2;
    uu2 = 2.0 * hs_inv_idx_0 * hs_inv_idx_0;
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      ret = offset + iPnt;
      V[ret] = 0.0;
      V[ret + V.size(1)] = 0.0;
      V[ret + V.size(1) * 2] = 0.0;
      V[ret + V.size(1) * 3] = 0.0;
      ret = offset + iPnt;
      V[ret + V.size(1) * 4] = uu2 * V[iPnt];
      for (i = 0; i < 5; i++) {
        V[ret + V.size(1) * (i + 5)] = 0.0;
      }
    }
    c = 10;
    d = 6;
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 3; deg <= i; deg++) {
      scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
      }
      c++;
      for (::coder::SizeType j{0}; j <= deg - 2; j++) {
        scaleu -= hs_inv_idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          V[ret + V.size(1) * (c + 1)] =
              V[ret + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
      }
      c += 2;
      d = (d + deg) + 1;
    }
    // compute tri degree terms if degree < 0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 1;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - nTermsInLayer)] *
                                     us[us.size(1) * iPnt + 1];
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        ret = (((p + degree) << 1) - p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer;
        nTermsInLayer = d + 3 * (excess - cornerTriangle);
        balance = (nTermsInPrevLayer + counterBottomRow) - 1;
        i1 = nTermsInLayer - counterBottomRow;
        for (::coder::SizeType j{0}; j <= i1; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * c] =
                V[ret + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
          }
          c++;
        }
      }
    }
  } else {
    c = 4;
    for (::coder::SizeType col{0}; col < 4; col++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * col] = 0.0;
      }
    }
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret + V.size(1) * c] =
            V[(iPnt + stride) + V.size(1) * (c - 3)] * scaleu;
        V[ret + V.size(1) * (c + 1)] = 0.0;
        V[(offset + iPnt) + V.size(1) * (c + 2)] = 0.0;
      }
      c += 3;
    }
  }
  //      compute du*dv
  offset += us.size(0);
  uv = hs_inv_idx_0 * hs_inv_idx_1;
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = offset + iPnt;
    for (i = 0; i < 5; i++) {
      V[ret + V.size(1) * i] = 0.0;
    }
    V[ret + V.size(1) * 5] = uv * V[iPnt];
    V[ret + V.size(1) * 6] = 0.0;
    V[ret + V.size(1) * 7] = 0.0;
    V[ret + V.size(1) * 8] = 0.0;
    V[ret + V.size(1) * 9] = 0.0;
  }
  c = 10;
  d = 7;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 3; deg <= i; deg++) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    scalev = hs_inv_idx_1;
    for (::coder::SizeType j{0}; j <= deg - 2; j++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[(iPnt + stride) + V.size(1) * (c - d)] * scalev;
      }
      scalev += hs_inv_idx_1;
      c++;
    }
    scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] =
          V[(iPnt + stride) + V.size(1) * (c - d)] * scalev;
    }
    c++;
    for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret + V.size(1) * c] =
            V[ret + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    d = (d + deg) + 1;
  }
  // compute the tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3 + 1;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d - 2;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (::coder::SizeType p{i}; p <= maxLayers; p++) {
      //  implicitly calculating number of elements in corner Pascal triangles
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((stride << 1) + iPnt) + V.size(1) * (c - nTermsInLayer)] *
              static_cast<real_T>(-degree - kdegree) * hs_inv_idx_0;
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      ret = (((p + degree) << 1) - p) - 1;
      if (ret < 0) {
        ret = 0;
      }
      excess += ret;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer + 1;
      nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
      balance = nTermsInPrevLayer + counterBottomRow;
      i1 = nTermsInLayer - counterBottomRow;
      for (::coder::SizeType j{0}; j <= i1; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          V[ret + V.size(1) * c] =
              V[ret + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  //  compute dv^2
  offset += us.size(0);
  if (!unimono) {
    real_T vv2;
    vv2 = 2.0 * hs_inv_idx_1 * hs_inv_idx_1;
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      ret = offset + iPnt;
      for (i = 0; i < 6; i++) {
        V[ret + V.size(1) * i] = 0.0;
      }
      V[ret + V.size(1) * 6] = vv2 * V[iPnt];
      V[ret + V.size(1) * 7] = 0.0;
      V[ret + V.size(1) * 8] = 0.0;
      V[ret + V.size(1) * 9] = 0.0;
    }
    c = 10;
    d = 7;
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 3; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
      scalev = hs_inv_idx_1;
      for (::coder::SizeType j{0}; j <= deg - 2; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + (stride << 1)) + V.size(1) * (c - d)] * scalev;
        }
        scalev += hs_inv_idx_1;
        c++;
      }
      scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[((stride << 1) + iPnt) + V.size(1) * (c - d)] * scalev;
      }
      c++;
      for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          V[ret + V.size(1) * c] =
              V[ret + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
      d = (d + deg) + 1;
    }
    // compute the tri-degree terms if degree < 0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d - 2;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 0;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - nTermsInLayer)] *
                                     us[us.size(1) * iPnt];
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        ret = (((p + degree) << 1) - p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer + 1;
        nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
        balance = nTermsInPrevLayer + counterBottomRow;
        i1 = nTermsInLayer - counterBottomRow;
        for (::coder::SizeType j{0}; j <= i1; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * c] =
                V[ret + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
          }
          c++;
        }
      }
    }
  } else {
    c = 4;
    for (::coder::SizeType col{0}; col < 5; col++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * col] = 0.0;
      }
    }
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret + V.size(1) * (c + 1)] =
            V[(iPnt + (stride << 1)) + V.size(1) * (c - 2)] * scalev;
        V[ret + V.size(1) * (c + 2)] = 0.0;
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c += 3;
    }
  }
  //      compute du*dw
  offset = (offset + us.size(0)) - 1;
  uw = hs_inv_idx_0 * hs_inv_idx_2;
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = (offset + iPnt) + 1;
    for (i = 0; i < 7; i++) {
      V[ret + V.size(1) * i] = 0.0;
    }
    V[ret + V.size(1) * 7] = uw * V[iPnt];
    V[ret + V.size(1) * 8] = 0.0;
    V[ret + V.size(1) * 9] = 0.0;
  }
  c = 10;
  d = 6;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 3; deg <= i; deg++) {
    for (::coder::SizeType j{0}; j <= deg; j++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
      }
      c++;
    }
    for (::coder::SizeType k{0}; k < deg; k++) {
      i1 = (deg - k) - 1;
      for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
        scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[((offset + iPnt) + V.size(1) * c) + 1] =
              V[(iPnt + stride) + V.size(1) * (((c - d) - deg) - 1)] * scalew;
        }
        c++;
      }
    }
    d = (d + deg) + 1;
  }
  // compute tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3 + 1;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i1 = 1 - degree;
    for (::coder::SizeType p{i1}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (::coder::SizeType k{0}; k < deg; k++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      x_tmp = p + degree;
      ret = ((x_tmp << 1) - p) - 1;
      if (ret < 0) {
        ret = 0;
      }
      excess += ret;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = nTermsInPrevLayer + counterBottomRow;
      degg = -degree;
      for (::coder::SizeType k{0}; k < degg; k++) {
        ret = (x_tmp - k) - 1;
        if (ret < 0) {
          ret = -ret;
        }
        partition = -degree - ret;
        for (::coder::SizeType j{0}; j <= partition; j++) {
          scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[((iPnt + offset) + V.size(1) * c) + 1] =
                V[(iPnt + stride) + V.size(1) * (c - balance)] * scalew;
          }
          c++;
        }
      }
    }
  }
  //      compute dv*dw
  offset += us.size(0);
  vw = hs_inv_idx_1 * hs_inv_idx_2;
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = (offset + iPnt) + 1;
    for (i1 = 0; i1 < 8; i1++) {
      V[ret + V.size(1) * i1] = 0.0;
    }
    V[ret + V.size(1) * 8] = vw * V[iPnt];
    V[ret + V.size(1) * 9] = 0.0;
  }
  c = 10;
  d = 6;
  for (deg = 3; deg <= i; deg++) {
    for (::coder::SizeType j{0}; j <= deg; j++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
      }
      c++;
    }
    for (::coder::SizeType k{0}; k < deg; k++) {
      i1 = (deg - k) - 1;
      for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
        scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[((offset + iPnt) + V.size(1) * c) + 1] =
              V[(iPnt + (stride << 1)) + V.size(1) * (((c - d) - deg) - 1)] *
              scalew;
        }
        c++;
      }
    }
    d = (d + deg) + 1;
  }
  // compute tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3 + 1;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (::coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (::coder::SizeType k{0}; k < deg; k++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      x_tmp = p + degree;
      ret = ((x_tmp << 1) - p) - 1;
      if (ret < 0) {
        ret = 0;
      }
      excess += ret;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = nTermsInPrevLayer + counterBottomRow;
      degg = -degree;
      for (::coder::SizeType k{0}; k < degg; k++) {
        ret = (x_tmp - k) - 1;
        if (ret < 0) {
          ret = -ret;
        }
        partition = -degree - ret;
        for (::coder::SizeType j{0}; j <= partition; j++) {
          scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[((iPnt + offset) + V.size(1) * c) + 1] =
                V[(iPnt + (stride << 1)) + V.size(1) * (c - balance)] * scalew;
          }
          c++;
        }
      }
    }
  }
  //  compute dw^2
  offset = (offset + us.size(0)) + 1;
  if (!unimono) {
    real_T ww2;
    ww2 = 2.0 * hs_inv_idx_2 * hs_inv_idx_2;
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      ret = offset + iPnt;
      for (i = 0; i < 9; i++) {
        V[ret + V.size(1) * i] = 0.0;
      }
      V[ret + V.size(1) * 9] = ww2 * V[iPnt];
    }
    c = 10;
    d = 6;
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 3; deg <= i; deg++) {
      for (::coder::SizeType j{0}; j <= deg; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      for (::coder::SizeType k{0}; k < deg; k++) {
        i1 = (deg - k) - 1;
        for (::coder::SizeType b_i{0}; b_i <= i1; b_i++) {
          scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + 3 * stride) + V.size(1) * (((c - d) - deg) - 1)] *
                scalew;
          }
          c++;
        }
      }
      d = (d + deg) + 1;
    }
    // compute tri-degree terms if degree < 0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 0;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType k{0}; k < deg; k++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        x_tmp = p + degree;
        ret = ((x_tmp << 1) - p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer;
        nTermsInLayer = d + 3 * (excess - cornerTriangle);
        balance = nTermsInPrevLayer + counterBottomRow;
        degg = -degree;
        for (::coder::SizeType k{0}; k < degg; k++) {
          ret = (x_tmp - k) - 1;
          if (ret < 0) {
            ret = -ret;
          }
          partition = -degree - ret;
          for (::coder::SizeType j{0}; j <= partition; j++) {
            scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(iPnt + offset) + V.size(1) * c] =
                  V[(iPnt + 3 * stride) + V.size(1) * (c - balance)] * scalew;
            }
            c++;
          }
        }
      }
    }
  } else {
    c = 4;
    for (::coder::SizeType col{0}; col < 6; col++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * col] = 0.0;
      }
    }
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scalew = static_cast<real_T>(deg) * hs_inv_idx_2;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret + V.size(1) * (c + 2)] =
            V[(iPnt + 3 * stride) + V.size(1) * (c - 1)] * scalew;
        V[ret + V.size(1) * (c + 1)] = 0.0;
        V[ret + V.size(1) * c] = 0.0;
      }
      c += 3;
    }
  }
}

//  gen_vander  Wrapper function for computing confluent Vandermonde matrix in
static void gen_vander(const ::coder::array<real_T, 2U> &us,
                       ::coder::SizeType npoints, ::coder::SizeType degree,
                       const ::coder::array<real_T, 2U> &hs_inv,
                       boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  switch (us.size(1)) {
  case 1: {
    real_T h_inv_;
    ::coder::SizeType b_npoints;
    ::coder::SizeType i;
    ::coder::SizeType i1;
    ::coder::SizeType i2;
    ::coder::SizeType stride;
    boolean_T b;
    boolean_T b1;
    b_npoints = npoints - 1;
    m2cAssert(us.size(1) == 1, "");
    //  Handle input arguments
    if (npoints == 0) {
      b_npoints = us.size(0) - 1;
    } else {
      m2cAssert(npoints <= us.size(0), "Input us is too small.");
    }
    m2cAssert(degree >= 0, "Degree must be nonnegative");
    if (hs_inv.size(1) == 0) {
      h_inv_ = 1.0;
    } else {
      h_inv_ = hs_inv[0];
    }
    stride = us.size(0);
    //  Number of row blocks
    V.set_size(degree + 1, us.size(0) << 1);
    //  Compute rows corresponding to function values
    if (degree != 0) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      i = us.size(1) * us.size(0);
      i1 = 0;
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          i2 = us.size(1) * us.size(0) - 1;
          if (i1 > MAX_int32_T - us.size(1)) {
            i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i1 += us.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        V[iPnt] = 1.0;
        V[iPnt + V.size(1)] = us[i1];
      }
    } else {
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        V[iPnt] = 1.0;
      }
    }
    i = degree + 1;
    for (::coder::SizeType ii{2}; ii <= i; ii++) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      i1 = us.size(1) * us.size(0);
      i2 = 0;
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= i1)) {
          i2 = 0;
          b = true;
        } else if (b) {
          b = false;
          i2 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          ::coder::SizeType i3;
          i3 = us.size(1) * us.size(0) - 1;
          if (i2 > MAX_int32_T - us.size(1)) {
            i2 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i2 += us.size(1);
            if (i2 > i3) {
              i2 -= i3;
            }
          }
        }
        V[iPnt + V.size(1) * (ii - 1)] =
            V[iPnt + V.size(1) * (ii - 2)] * us[i2];
      }
    }
    //  Add row blocks corresponding to kth derivatives
    for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
      V[stride + iPnt] = 0.0;
    }
    for (::coder::SizeType j{0}; j < degree; j++) {
      real_T s;
      s = h_inv_ * static_cast<real_T>(j + 1);
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * (j + 1)] = V[iPnt + V.size(1) * j] * s;
      }
    }
  } break;
  case 2:
    gen_vander_2d(us, npoints, degree, hs_inv, unimono, V);
    break;
  default:
    gen_vander_3d(us, npoints, degree, hs_inv, unimono, V);
    break;
  }
}

//  gen_vander_2d  Generate generalized/confluent Vandermonde matrix in 2D.
static void gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                          ::coder::SizeType npoints, ::coder::SizeType degree,
                          const ::coder::array<real_T, 2U> &hs_inv,
                          boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  real_T hs_inv__idx_0;
  real_T hs_inv__idx_1;
  ::coder::SizeType c;
  ::coder::SizeType deg;
  ::coder::SizeType offset;
  ::coder::SizeType ret;
  ::coder::SizeType stride;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (hs_inv.size(1) == 0) {
    hs_inv__idx_0 = 1.0;
    hs_inv__idx_1 = 1.0;
  } else {
    hs_inv__idx_0 = hs_inv[0];
    hs_inv__idx_1 = hs_inv[1];
  }
  stride = us.size(0);
  if (unimono && (degree >= 0)) {
    degree = -degree;
  }
  //  Number of row blocks
  if (degree >= 0) {
    ret = (degree + 1) * (degree + 2) / 2;
    unimono = false;
  } else if (unimono) {
    ret = 1 - (degree << 1);
  } else {
    ret = (1 - degree) * (1 - degree);
  }
  //  Allocate storage for V
  V.set_size(ret, us.size(0) * 3);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
    }
  } else {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 3;
  if (!unimono) {
    if (degree < 0) {
      ret = -degree;
    } else {
      ret = degree;
    }
    for (deg = 2; deg <= ret; deg++) {
      for (::coder::SizeType j{0}; j < deg; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - deg) - 1)] * us[us.size(1) * iPnt + 1];
      }
      c++;
    }
    //  Compute the bi-degree terms if degree<0
    ret = -degree;
    for (deg = ret; deg >= 1; deg--) {
      for (::coder::SizeType k{0}; k < deg; k++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
        }
        c++;
      }
    }
  } else {
    if (degree < 0) {
      ret = -degree;
    } else {
      ret = degree;
    }
    for (deg = 2; deg <= ret; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 2)] * us[us.size(1) * iPnt];
        V[iPnt + V.size(1) * (c + 1)] =
            V[iPnt + V.size(1) * (c - 1)] * us[us.size(1) * iPnt + 1];
      }
      c += 2;
    }
  }
  //  compute higher order confluent Vandermonde matrix blocks incrementally
  m2cAssert(degree != 0, "");
  //  Compute derivative with respect to u
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = stride + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = V[iPnt] * hs_inv__idx_0;
    V[ret + V.size(1) * 2] = 0.0;
  }
  c = 3;
  if (!unimono) {
    real_T scaleu;
    if (degree < 0) {
      ret = -degree;
    } else {
      ret = degree;
    }
    for (deg = 2; deg <= ret; deg++) {
      scaleu = static_cast<real_T>(deg) * hs_inv__idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * scaleu;
      }
      c++;
      for (::coder::SizeType j{0}; j <= deg - 2; j++) {
        scaleu -= hs_inv__idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * scaleu;
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    //  Compute the bi-degree terms if degree<0
    ret = -degree;
    for (::coder::SizeType len{ret}; len >= 0; len--) {
      scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
      for (::coder::SizeType k{0}; k < len; k++) {
        scaleu -= hs_inv__idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - len)] * scaleu;
        }
        c++;
      }
    }
  } else {
    if (degree < 0) {
      ret = -degree;
    } else {
      ret = degree;
    }
    for (deg = 2; deg <= ret; deg++) {
      real_T scaleu;
      scaleu = static_cast<real_T>(deg) * hs_inv__idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 2)] * scaleu;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
      }
      c += 2;
    }
  }
  //  Compute derivative with respect to v
  offset = us.size(0) + us.size(0);
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = offset + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = 0.0;
    V[ret + V.size(1) * 2] = V[iPnt] * hs_inv__idx_1;
  }
  c = 3;
  if (!unimono) {
    real_T scalev;
    if (degree < 0) {
      ret = -degree;
    } else {
      ret = degree;
    }
    for (deg = 2; deg <= ret; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
      for (::coder::SizeType j{0}; j < deg; j++) {
        scalev = (static_cast<real_T>(j) + 1.0) * hs_inv__idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * ((c - deg) - 1)] * scalev;
        }
        c++;
      }
    }
    //  Compute the bi-degree terms if degree<0
    ret = -degree;
    deg = -degree;
    for (::coder::SizeType len{ret}; len >= 0; len--) {
      deg++;
      scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
      for (::coder::SizeType k{0}; k < len; k++) {
        scalev += hs_inv__idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * ((c - len) - 1)] * scalev;
        }
        c++;
      }
    }
  } else {
    if (degree < 0) {
      ret = -degree;
    } else {
      ret = degree;
    }
    for (deg = 2; deg <= ret; deg++) {
      real_T scalev;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      scalev = static_cast<real_T>(deg) * hs_inv__idx_1;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * (c + 1)] =
            V[iPnt + V.size(1) * (c - 1)] * scalev;
      }
      c += 2;
    }
  }
  //      compute regular orders if order > 0
}

//  gen_vander_3d  Generate generalized/confluent Vandermonde matrix in 3D.
static void gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                          ::coder::SizeType npoints, ::coder::SizeType degree,
                          const ::coder::array<real_T, 2U> &hs_inv,
                          boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  real_T hs_inv_idx_0;
  real_T hs_inv_idx_1;
  real_T hs_inv_idx_2;
  ::coder::SizeType balance;
  ::coder::SizeType c;
  ::coder::SizeType cornerTriangle;
  ::coder::SizeType counterBottomRow;
  ::coder::SizeType d;
  ::coder::SizeType deg;
  ::coder::SizeType excess;
  ::coder::SizeType i;
  ::coder::SizeType maxLayers;
  ::coder::SizeType nTermsInLayer;
  ::coder::SizeType nTermsInPrevLayer;
  ::coder::SizeType offset;
  ::coder::SizeType ret;
  ::coder::SizeType stride;
  ::coder::SizeType x_tmp;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (hs_inv.size(1) == 0) {
    hs_inv_idx_0 = 1.0;
    hs_inv_idx_1 = 1.0;
    hs_inv_idx_2 = 1.0;
  } else {
    hs_inv_idx_0 = hs_inv[0];
    hs_inv_idx_1 = hs_inv[1];
    hs_inv_idx_2 = hs_inv[2];
  }
  stride = us.size(0);
  if (unimono && (degree >= 0)) {
    degree = -degree;
  }
  if (degree >= 0) {
    ret = (degree + 1) * (degree + 2) * (degree + 3) / 6;
    unimono = false;
  } else if (unimono) {
    ret = 1 - 3 * degree;
  } else {
    ret = (1 - degree) * (1 - degree) * (1 - degree);
  }
  //  Allocate storage for V
  V.set_size(ret, us.size(0) << 2);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
      V[iPnt + V.size(1) * 3] = us[us.size(1) * iPnt + 2];
    }
  } else {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 4;
  d = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      //  Within each level, use convention of Pascal triangle with x^deg at
      for (::coder::SizeType j{0}; j < deg; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * us[us.size(1) * iPnt];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - d) - 1)] * us[us.size(1) * iPnt + 1];
      }
      c++;
      for (::coder::SizeType j{0}; j < d; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
              us[us.size(1) * iPnt + 2];
        }
        c++;
      }
      d = (d + deg) + 1;
    }
    //  Compute the tri-degree terms if degree<0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        ::coder::SizeType gap;
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 1;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType k{0}; k < deg; k++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[iPnt + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - nTermsInLayer)] *
                us[us.size(1) * iPnt + 1];
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        ret = ((degree + degree) + p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer;
        nTermsInLayer = d + 3 * (excess - cornerTriangle);
        gap = (nTermsInPrevLayer + counterBottomRow) - 1;
        x_tmp = nTermsInLayer - counterBottomRow;
        for (::coder::SizeType j{0}; j <= x_tmp; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[iPnt + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - gap)] * us[us.size(1) * iPnt + 2];
          }
          c++;
        }
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 3)] * us[us.size(1) * iPnt];
        V[iPnt + V.size(1) * (c + 1)] =
            V[iPnt + V.size(1) * (c - 2)] * us[us.size(1) * iPnt + 1];
        V[iPnt + V.size(1) * (c + 2)] =
            V[iPnt + V.size(1) * (c - 1)] * us[us.size(1) * iPnt + 2];
      }
      c += 3;
    }
  }
  m2cAssert(true, "");
  //      compute higher order confluent Vandermonde matrix blocks
  m2cAssert(degree != 0, "");
  // compute derivatives with respect to u
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = stride + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = V[iPnt] * hs_inv_idx_0;
    V[ret + V.size(1) * 2] = 0.0;
    V[ret + V.size(1) * 3] = 0.0;
  }
  c = 4;
  d = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      real_T scaleu;
      scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * scaleu;
      }
      c++;
      for (::coder::SizeType j{0}; j <= deg - 2; j++) {
        scaleu -= hs_inv_idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * scaleu;
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] = 0.0;
      }
      for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = stride + iPnt;
          V[ret + V.size(1) * (c + 1)] =
              V[ret + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
      }
      c += 2;
      d = (d + deg) + 1;
    }
    // tri-degree terms if degree < 0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 1;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = stride + iPnt;
            V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - nTermsInLayer)] *
                                     us[us.size(1) * iPnt + 1];
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        ret = (((p + degree) << 1) - p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer;
        nTermsInLayer = d + 3 * (excess - cornerTriangle);
        balance = (nTermsInPrevLayer + counterBottomRow) - 1;
        x_tmp = nTermsInLayer - counterBottomRow;
        for (::coder::SizeType j{0}; j <= x_tmp; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = stride + iPnt;
            V[ret + V.size(1) * c] =
                V[ret + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
          }
          c++;
        }
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      real_T scaleu;
      scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 3)] * scaleu;
      }
      c += 3;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * (c - 2)] = 0.0;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * (c - 1)] = 0.0;
      }
    }
  }
  // compute derivatives with respect to v
  offset = us.size(0) + us.size(0);
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = offset + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = 0.0;
    V[ret + V.size(1) * 2] = V[iPnt] * hs_inv_idx_1;
    V[ret + V.size(1) * 3] = 0.0;
  }
  c = 4;
  d = 4;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      real_T scalev;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
      scalev = hs_inv_idx_1;
      for (::coder::SizeType j{0}; j <= deg - 2; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * scalev;
        }
        scalev += hs_inv_idx_1;
        c++;
      }
      scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * scalev;
      }
      c++;
      for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          V[ret + V.size(1) * c] =
              V[ret + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
      d = (d + deg) + 1;
    }
    // compute the tri-degree terms if degree < 0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d - 2;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 0;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - nTermsInLayer)] *
                                     us[us.size(1) * iPnt];
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        ret = (((p + degree) << 1) - p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer + 1;
        nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
        balance = nTermsInPrevLayer + counterBottomRow;
        x_tmp = nTermsInLayer - counterBottomRow;
        for (::coder::SizeType j{0}; j <= x_tmp; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * c] =
                V[ret + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
          }
          c++;
        }
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      real_T scalev;
      scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret + V.size(1) * (c + 2)] = 0.0;
        V[ret + V.size(1) * (c + 1)] = V[iPnt + V.size(1) * (c - 2)] * scalev;
        V[ret + V.size(1) * c] = 0.0;
      }
      c += 3;
    }
  }
  // compute derivatives with respect to w
  offset += us.size(0);
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = offset + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = 0.0;
    V[ret + V.size(1) * 2] = 0.0;
    V[ret + V.size(1) * 3] = V[iPnt] * hs_inv_idx_2;
  }
  c = 4;
  d = 3;
  if (!unimono) {
    real_T scalew;
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType j{0}; j <= deg; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      for (::coder::SizeType k{0}; k < deg; k++) {
        x_tmp = (deg - k) - 1;
        for (::coder::SizeType b_i{0}; b_i <= x_tmp; b_i++) {
          scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (((c - d) - deg) - 1)] * scalew;
          }
          c++;
        }
      }
      d = (d + deg) + 1;
    }
    // compute tri-degree terms if degree < 0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        ::coder::SizeType degg;
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 0;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType k{0}; k < deg; k++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        x_tmp = p + degree;
        ret = ((x_tmp << 1) - p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer;
        nTermsInLayer = d + 3 * (excess - cornerTriangle);
        balance = nTermsInPrevLayer + counterBottomRow;
        degg = -degree;
        for (::coder::SizeType k{0}; k < degg; k++) {
          ::coder::SizeType partition;
          ret = (x_tmp - k) - 1;
          if (ret < 0) {
            ret = -ret;
          }
          partition = -degree - ret;
          for (::coder::SizeType j{0}; j <= partition; j++) {
            scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(iPnt + offset) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (c - balance)] * scalew;
            }
            c++;
          }
        }
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      real_T scalew;
      scalew = static_cast<real_T>(deg) * hs_inv_idx_2;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret + V.size(1) * (c + 2)] = V[iPnt + V.size(1) * (c - 1)] * scalew;
        V[ret + V.size(1) * (c + 1)] = 0.0;
        V[ret + V.size(1) * c] = 0.0;
      }
      c += 3;
    }
  }
}

static void h_gen_vander(const ::coder::array<real_T, 2U> &us,
                         ::coder::SizeType npoints, ::coder::SizeType degree,
                         const ::coder::array<real_T, 2U> &hs_inv,
                         boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  switch (us.size(1)) {
  case 1: {
    real_T h_inv_;
    ::coder::SizeType V_tmp;
    ::coder::SizeType b_npoints;
    ::coder::SizeType i;
    ::coder::SizeType i1;
    ::coder::SizeType r;
    ::coder::SizeType stride;
    boolean_T b;
    boolean_T b1;
    b_npoints = npoints - 1;
    m2cAssert(us.size(1) == 1, "");
    //  Handle input arguments
    if (npoints == 0) {
      b_npoints = us.size(0) - 1;
    } else {
      m2cAssert(npoints <= us.size(0), "Input us is too small.");
    }
    m2cAssert(degree >= 0, "Degree must be nonnegative");
    if (hs_inv.size(1) == 0) {
      h_inv_ = 1.0;
    } else {
      h_inv_ = hs_inv[0];
    }
    stride = us.size(0);
    //  Number of row blocks
    V.set_size(degree + 1, us.size(0) * 3);
    //  Compute rows corresponding to function values
    if (degree != 0) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      V_tmp = us.size(1) * us.size(0);
      i = 0;
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= V_tmp)) {
          i = 0;
          b = true;
        } else if (b) {
          b = false;
          i = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          i1 = us.size(1) * us.size(0) - 1;
          if (i > MAX_int32_T - us.size(1)) {
            i = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i += us.size(1);
            if (i > i1) {
              i -= i1;
            }
          }
        }
        V[iPnt] = 1.0;
        V[iPnt + V.size(1)] = us[i];
      }
    } else {
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        V[iPnt] = 1.0;
      }
    }
    V_tmp = degree + 1;
    for (::coder::SizeType ii{2}; ii <= V_tmp; ii++) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      i = us.size(1) * us.size(0);
      i1 = 0;
      for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          ::coder::SizeType i2;
          i2 = us.size(1) * us.size(0) - 1;
          if (i1 > MAX_int32_T - us.size(1)) {
            i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i1 += us.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        V[iPnt + V.size(1) * (ii - 1)] =
            V[iPnt + V.size(1) * (ii - 2)] * us[i1];
      }
    }
    //  Add row blocks corresponding to kth derivatives
    r = us.size(0);
    //      computing negative orders
    for (::coder::SizeType k{0}; k < 2; k++) {
      for (::coder::SizeType j{0}; j <= k; j++) {
        for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
          V[(r + iPnt) + V.size(1) * j] = 0.0;
        }
      }
      for (::coder::SizeType j{k + 1}; j <= degree; j++) {
        real_T s;
        s = h_inv_ * static_cast<real_T>(j);
        for (::coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
          V_tmp = (r + iPnt) + 1;
          V[(V_tmp + V.size(1) * j) - 1] =
              V[((V_tmp - stride) + V.size(1) * (j - 1)) - 1] * s;
        }
      }
      r += stride;
    }
    //      Calculate Biharmonic if order = -4
  } break;
  case 2:
    h_gen_vander_2d(us, npoints, degree, hs_inv, unimono, V);
    break;
  default:
    h_gen_vander_3d(us, npoints, degree, hs_inv, unimono, V);
    break;
  }
}

static void h_gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                            ::coder::SizeType npoints, ::coder::SizeType degree,
                            const ::coder::array<real_T, 2U> &hs_inv,
                            boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  real_T hs_inv__idx_0;
  real_T hs_inv__idx_1;
  real_T scaleu;
  real_T scalev;
  ::coder::SizeType c;
  ::coder::SizeType deg;
  ::coder::SizeType i;
  ::coder::SizeType offset;
  ::coder::SizeType offset_prev;
  ::coder::SizeType ret;
  ::coder::SizeType stride;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (hs_inv.size(1) == 0) {
    hs_inv__idx_0 = 1.0;
    hs_inv__idx_1 = 1.0;
  } else {
    hs_inv__idx_0 = hs_inv[0];
    hs_inv__idx_1 = hs_inv[1];
  }
  stride = us.size(0);
  if (unimono && (degree >= 0)) {
    degree = -degree;
  }
  //  Number of row blocks
  if (degree >= 0) {
    ret = (degree + 1) * (degree + 2) / 2;
    unimono = false;
  } else if (unimono) {
    ret = 1 - (degree << 1);
  } else {
    ret = (1 - degree) * (1 - degree);
  }
  //  Allocate storage for V
  V.set_size(ret, us.size(0) * 5);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
    }
  } else {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType j{0}; j < deg; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - deg) - 1)] * us[us.size(1) * iPnt + 1];
      }
      c++;
    }
    //  Compute the bi-degree terms if degree<0
    i = -degree;
    for (deg = i; deg >= 1; deg--) {
      for (::coder::SizeType k{0}; k < deg; k++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
        }
        c++;
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 2)] * us[us.size(1) * iPnt];
        V[iPnt + V.size(1) * (c + 1)] =
            V[iPnt + V.size(1) * (c - 1)] * us[us.size(1) * iPnt + 1];
      }
      c += 2;
    }
  }
  //  compute higher order confluent Vandermonde matrix blocks incrementally
  m2cAssert(degree != 0, "");
  //  Compute derivative with respect to u
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = stride + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = V[iPnt] * hs_inv__idx_0;
    V[ret + V.size(1) * 2] = 0.0;
  }
  c = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scaleu = static_cast<real_T>(deg) * hs_inv__idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * scaleu;
      }
      c++;
      for (::coder::SizeType j{0}; j <= deg - 2; j++) {
        scaleu -= hs_inv__idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * scaleu;
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    //  Compute the bi-degree terms if degree<0
    i = -degree;
    for (::coder::SizeType len{i}; len >= 0; len--) {
      scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
      for (::coder::SizeType k{0}; k < len; k++) {
        scaleu -= hs_inv__idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - len)] * scaleu;
        }
        c++;
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scaleu = static_cast<real_T>(deg) * hs_inv__idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 2)] * scaleu;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
      }
      c += 2;
    }
  }
  //  Compute derivative with respect to v
  offset = us.size(0) + us.size(0);
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = offset + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = 0.0;
    V[ret + V.size(1) * 2] = V[iPnt] * hs_inv__idx_1;
  }
  c = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
      for (::coder::SizeType j{0}; j < deg; j++) {
        scalev = (static_cast<real_T>(j) + 1.0) * hs_inv__idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * ((c - deg) - 1)] * scalev;
        }
        c++;
      }
    }
    //  Compute the bi-degree terms if degree<0
    ret = -degree;
    deg = -degree;
    for (::coder::SizeType len{ret}; len >= 0; len--) {
      deg++;
      scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
      for (::coder::SizeType k{0}; k < len; k++) {
        scalev += hs_inv__idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * ((c - len) - 1)] * scalev;
        }
        c++;
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      scalev = static_cast<real_T>(deg) * hs_inv__idx_1;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * (c + 1)] =
            V[iPnt + V.size(1) * (c - 1)] * scalev;
      }
      c += 2;
    }
  }
  //      compute regular orders if order > 0
  m2cAssert(degree != 0, "");
  offset = 3 * us.size(0);
  offset_prev = us.size(0);
  //  Compute derivative with respect to u
  i = offset + 1;
  ret = offset + npoints;
  for (::coder::SizeType col{0}; col < 3; col++) {
    for (::coder::SizeType row{i}; row <= ret; row++) {
      V[(row + V.size(1) * col) - 1] = 0.0;
    }
  }
  c = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
      ret = deg - 1;
      for (::coder::SizeType j{0}; j <= ret; j++) {
        scaleu -= hs_inv__idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    //  Compute the bi-degree terms if degree<0
    i = -degree;
    for (::coder::SizeType len{i}; len >= 0; len--) {
      scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
      for (::coder::SizeType k{0}; k < len; k++) {
        scaleu -= hs_inv__idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
        }
        c++;
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scaleu = static_cast<real_T>(deg) * hs_inv__idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[(offset_prev + iPnt) + V.size(1) * (c - 2)] * scaleu;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
      }
      c += 2;
    }
  }
  offset += us.size(0);
  offset_prev = us.size(0) + us.size(0);
  //  Compute derivative with respect to v
  if (!unimono) {
    offset_prev += us.size(0);
  }
  i = offset + 1;
  ret = offset + npoints;
  for (::coder::SizeType col{0}; col < 3; col++) {
    for (::coder::SizeType row{i}; row <= ret; row++) {
      V[(row + V.size(1) * col) - 1] = 0.0;
    }
  }
  c = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType j{0}; j < 2; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      for (::coder::SizeType j{2}; j <= deg; j++) {
        scalev = static_cast<real_T>(j) * hs_inv__idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - deg) - 1)] *
              scalev;
        }
        c++;
      }
    }
    //  Compute the bi-degree terms if degree<0
    ret = -degree;
    deg = -degree;
    for (::coder::SizeType len{ret}; len >= 0; len--) {
      deg++;
      scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
      for (::coder::SizeType k{0}; k < len; k++) {
        scalev += hs_inv__idx_1;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - len) - 1)] *
              scalev;
        }
        c++;
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      scalev = static_cast<real_T>(deg) * hs_inv__idx_1;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * (c + 1)] =
            V[(offset_prev + iPnt) + V.size(1) * (c - 1)] * scalev;
      }
      c += 2;
    }
  }
}

static void h_gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                            ::coder::SizeType npoints, ::coder::SizeType degree,
                            const ::coder::array<real_T, 2U> &hs_inv,
                            boolean_T unimono, ::coder::array<real_T, 2U> &V)
{
  real_T hs_inv_idx_0;
  real_T hs_inv_idx_1;
  real_T hs_inv_idx_2;
  real_T scaleu;
  real_T scalev;
  real_T scalew;
  ::coder::SizeType balance;
  ::coder::SizeType c;
  ::coder::SizeType cornerTriangle;
  ::coder::SizeType counterBottomRow;
  ::coder::SizeType d;
  ::coder::SizeType deg;
  ::coder::SizeType degg;
  ::coder::SizeType excess;
  ::coder::SizeType i;
  ::coder::SizeType maxLayers;
  ::coder::SizeType nTermsInLayer;
  ::coder::SizeType nTermsInPrevLayer;
  ::coder::SizeType offset;
  ::coder::SizeType partition;
  ::coder::SizeType ret;
  ::coder::SizeType stride;
  ::coder::SizeType x_tmp;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (hs_inv.size(1) == 0) {
    hs_inv_idx_0 = 1.0;
    hs_inv_idx_1 = 1.0;
    hs_inv_idx_2 = 1.0;
  } else {
    hs_inv_idx_0 = hs_inv[0];
    hs_inv_idx_1 = hs_inv[1];
    hs_inv_idx_2 = hs_inv[2];
  }
  stride = us.size(0);
  if (unimono && (degree >= 0)) {
    degree = -degree;
  }
  if (degree >= 0) {
    ret = (degree + 1) * (degree + 2) * (degree + 3) / 6;
    unimono = false;
  } else if (unimono) {
    ret = 1 - 3 * degree;
  } else {
    ret = (1 - degree) * (1 - degree) * (1 - degree);
  }
  //  Allocate storage for V
  V.set_size(ret, us.size(0) * 7);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
      V[iPnt + V.size(1) * 3] = us[us.size(1) * iPnt + 2];
    }
  } else {
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 4;
  d = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      //  Within each level, use convention of Pascal triangle with x^deg at
      for (::coder::SizeType j{0}; j < deg; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * us[us.size(1) * iPnt];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - d) - 1)] * us[us.size(1) * iPnt + 1];
      }
      c++;
      for (::coder::SizeType j{0}; j < d; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
              us[us.size(1) * iPnt + 2];
        }
        c++;
      }
      d = (d + deg) + 1;
    }
    //  Compute the tri-degree terms if degree<0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        ::coder::SizeType gap;
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 1;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType k{0}; k < deg; k++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[iPnt + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - nTermsInLayer)] *
                us[us.size(1) * iPnt + 1];
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        ret = ((degree + degree) + p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer;
        nTermsInLayer = d + 3 * (excess - cornerTriangle);
        gap = (nTermsInPrevLayer + counterBottomRow) - 1;
        x_tmp = nTermsInLayer - counterBottomRow;
        for (::coder::SizeType j{0}; j <= x_tmp; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[iPnt + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - gap)] * us[us.size(1) * iPnt + 2];
          }
          c++;
        }
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 3)] * us[us.size(1) * iPnt];
        V[iPnt + V.size(1) * (c + 1)] =
            V[iPnt + V.size(1) * (c - 2)] * us[us.size(1) * iPnt + 1];
        V[iPnt + V.size(1) * (c + 2)] =
            V[iPnt + V.size(1) * (c - 1)] * us[us.size(1) * iPnt + 2];
      }
      c += 3;
    }
  }
  m2cAssert(true, "");
  //      compute higher order confluent Vandermonde matrix blocks
  m2cAssert(degree != 0, "");
  // compute derivatives with respect to u
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = stride + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = V[iPnt] * hs_inv_idx_0;
    V[ret + V.size(1) * 2] = 0.0;
    V[ret + V.size(1) * 3] = 0.0;
  }
  c = 4;
  d = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * scaleu;
      }
      c++;
      for (::coder::SizeType j{0}; j <= deg - 2; j++) {
        scaleu -= hs_inv_idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * scaleu;
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] = 0.0;
      }
      for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = stride + iPnt;
          V[ret + V.size(1) * (c + 1)] =
              V[ret + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
      }
      c += 2;
      d = (d + deg) + 1;
    }
    // tri-degree terms if degree < 0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 1;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = stride + iPnt;
            V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - nTermsInLayer)] *
                                     us[us.size(1) * iPnt + 1];
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        ret = (((p + degree) << 1) - p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer;
        nTermsInLayer = d + 3 * (excess - cornerTriangle);
        balance = (nTermsInPrevLayer + counterBottomRow) - 1;
        x_tmp = nTermsInLayer - counterBottomRow;
        for (::coder::SizeType j{0}; j <= x_tmp; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = stride + iPnt;
            V[ret + V.size(1) * c] =
                V[ret + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
          }
          c++;
        }
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - 3)] * scaleu;
      }
      c += 3;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * (c - 2)] = 0.0;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * (c - 1)] = 0.0;
      }
    }
  }
  // compute derivatives with respect to v
  offset = us.size(0) + us.size(0);
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = offset + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = 0.0;
    V[ret + V.size(1) * 2] = V[iPnt] * hs_inv_idx_1;
    V[ret + V.size(1) * 3] = 0.0;
  }
  c = 4;
  d = 4;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
      scalev = hs_inv_idx_1;
      for (::coder::SizeType j{0}; j <= deg - 2; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * scalev;
        }
        scalev += hs_inv_idx_1;
        c++;
      }
      scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * scalev;
      }
      c++;
      for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          V[ret + V.size(1) * c] =
              V[ret + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
      d = (d + deg) + 1;
    }
    // compute the tri-degree terms if degree < 0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d - 2;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 0;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - nTermsInLayer)] *
                                     us[us.size(1) * iPnt];
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        ret = (((p + degree) << 1) - p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer + 1;
        nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
        balance = nTermsInPrevLayer + counterBottomRow;
        x_tmp = nTermsInLayer - counterBottomRow;
        for (::coder::SizeType j{0}; j <= x_tmp; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * c] =
                V[ret + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
          }
          c++;
        }
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret + V.size(1) * (c + 2)] = 0.0;
        V[ret + V.size(1) * (c + 1)] = V[iPnt + V.size(1) * (c - 2)] * scalev;
        V[ret + V.size(1) * c] = 0.0;
      }
      c += 3;
    }
  }
  // compute derivatives with respect to w
  offset += us.size(0);
  for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    ret = offset + iPnt;
    V[ret] = 0.0;
    V[ret + V.size(1)] = 0.0;
    V[ret + V.size(1) * 2] = 0.0;
    V[ret + V.size(1) * 3] = V[iPnt] * hs_inv_idx_2;
  }
  c = 4;
  d = 3;
  if (!unimono) {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      for (::coder::SizeType j{0}; j <= deg; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      for (::coder::SizeType k{0}; k < deg; k++) {
        x_tmp = (deg - k) - 1;
        for (::coder::SizeType b_i{0}; b_i <= x_tmp; b_i++) {
          scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (((c - d) - deg) - 1)] * scalew;
          }
          c++;
        }
      }
      d = (d + deg) + 1;
    }
    // compute tri-degree terms if degree < 0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 0;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType k{0}; k < deg; k++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        x_tmp = p + degree;
        ret = ((x_tmp << 1) - p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer;
        nTermsInLayer = d + 3 * (excess - cornerTriangle);
        balance = nTermsInPrevLayer + counterBottomRow;
        degg = -degree;
        for (::coder::SizeType k{0}; k < degg; k++) {
          ret = (x_tmp - k) - 1;
          if (ret < 0) {
            ret = -ret;
          }
          partition = -degree - ret;
          for (::coder::SizeType j{0}; j <= partition; j++) {
            scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(iPnt + offset) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (c - balance)] * scalew;
            }
            c++;
          }
        }
      }
    }
  } else {
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scalew = static_cast<real_T>(deg) * hs_inv_idx_2;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret + V.size(1) * (c + 2)] = V[iPnt + V.size(1) * (c - 1)] * scalew;
        V[ret + V.size(1) * (c + 1)] = 0.0;
        V[ret + V.size(1) * c] = 0.0;
      }
      c += 3;
    }
  }
  //  compute du^2
  offset = us.size(0) << 2;
  if (!unimono) {
    real_T uu2;
    uu2 = 2.0 * hs_inv_idx_0 * hs_inv_idx_0;
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      ret = offset + iPnt;
      V[ret] = 0.0;
      V[ret + V.size(1)] = 0.0;
      V[ret + V.size(1) * 2] = 0.0;
      V[ret + V.size(1) * 3] = 0.0;
      ret = offset + iPnt;
      V[ret + V.size(1) * 4] = uu2 * V[iPnt];
      for (i = 0; i < 5; i++) {
        V[ret + V.size(1) * (i + 5)] = 0.0;
      }
    }
    c = 10;
    d = 6;
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 3; deg <= i; deg++) {
      scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
      }
      c++;
      for (::coder::SizeType j{0}; j <= deg - 2; j++) {
        scaleu -= hs_inv_idx_0;
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      for (::coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          V[ret + V.size(1) * (c + 1)] =
              V[ret + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
      }
      c += 2;
      d = (d + deg) + 1;
    }
    // compute tri degree terms if degree < 0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 1;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - nTermsInLayer)] *
                                     us[us.size(1) * iPnt + 1];
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        ret = (((p + degree) << 1) - p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer;
        nTermsInLayer = d + 3 * (excess - cornerTriangle);
        balance = (nTermsInPrevLayer + counterBottomRow) - 1;
        x_tmp = nTermsInLayer - counterBottomRow;
        for (::coder::SizeType j{0}; j <= x_tmp; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * c] =
                V[ret + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
          }
          c++;
        }
      }
    }
  } else {
    c = 4;
    for (::coder::SizeType col{0}; col < 4; col++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * col] = 0.0;
      }
    }
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret + V.size(1) * c] =
            V[(iPnt + stride) + V.size(1) * (c - 3)] * scaleu;
        V[ret + V.size(1) * (c + 1)] = 0.0;
        V[ret + V.size(1) * (c + 2)] = 0.0;
      }
      c += 3;
    }
  }
  //  compute dv^2
  offset += us.size(0);
  if (!unimono) {
    real_T vv2;
    vv2 = 2.0 * hs_inv_idx_1 * hs_inv_idx_1;
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      ret = offset + iPnt;
      for (i = 0; i < 6; i++) {
        V[ret + V.size(1) * i] = 0.0;
      }
      V[ret + V.size(1) * 6] = vv2 * V[iPnt];
      V[ret + V.size(1) * 7] = 0.0;
      V[ret + V.size(1) * 8] = 0.0;
      V[ret + V.size(1) * 9] = 0.0;
    }
    c = 10;
    d = 7;
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 3; deg <= i; deg++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
      scalev = hs_inv_idx_1;
      for (::coder::SizeType j{0}; j <= deg - 2; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + (stride << 1)) + V.size(1) * (c - d)] * scalev;
        }
        scalev += hs_inv_idx_1;
        c++;
      }
      scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[((stride << 1) + iPnt) + V.size(1) * (c - d)] * scalev;
      }
      c++;
      for (::coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          ret = offset + iPnt;
          V[ret + V.size(1) * c] =
              V[ret + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
      d = (d + deg) + 1;
    }
    // compute the tri-degree terms if degree < 0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d - 2;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 0;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * c] = V[ret + V.size(1) * (c - nTermsInLayer)] *
                                     us[us.size(1) * iPnt];
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        ret = (((p + degree) << 1) - p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer + 1;
        nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
        balance = nTermsInPrevLayer + counterBottomRow;
        x_tmp = nTermsInLayer - counterBottomRow;
        for (::coder::SizeType j{0}; j <= x_tmp; j++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            ret = offset + iPnt;
            V[ret + V.size(1) * c] =
                V[ret + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
          }
          c++;
        }
      }
    }
  } else {
    c = 4;
    for (::coder::SizeType col{0}; col < 5; col++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * col] = 0.0;
      }
    }
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret + V.size(1) * (c + 1)] =
            V[(iPnt + (stride << 1)) + V.size(1) * (c - 2)] * scalev;
        V[ret + V.size(1) * (c + 2)] = 0.0;
        V[ret + V.size(1) * c] = 0.0;
      }
      c += 3;
    }
  }
  //  compute dw^2
  offset += us.size(0);
  if (!unimono) {
    real_T ww2;
    ww2 = 2.0 * hs_inv_idx_2 * hs_inv_idx_2;
    for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      ret = offset + iPnt;
      for (i = 0; i < 9; i++) {
        V[ret + V.size(1) * i] = 0.0;
      }
      V[ret + V.size(1) * 9] = ww2 * V[iPnt];
    }
    c = 10;
    d = 6;
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 3; deg <= i; deg++) {
      for (::coder::SizeType j{0}; j <= deg; j++) {
        for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      for (::coder::SizeType k{0}; k < deg; k++) {
        x_tmp = (deg - k) - 1;
        for (::coder::SizeType b_i{0}; b_i <= x_tmp; b_i++) {
          scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + 3 * stride) + V.size(1) * (((c - d) - deg) - 1)] *
                scalew;
          }
          c++;
        }
      }
      d = (d + deg) + 1;
    }
    // compute tri-degree terms if degree < 0
    if (degree < 0) {
      deg = -degree;
      maxLayers = -degree * 3;
      // max number of layers needed in the Pascal tetrahedron
      cornerTriangle = 0;
      // number of elements subtracted in each corner Pascal triangle
      nTermsInLayer = d;
      // initializing number of elements in layer
      excess = 0;
      // excess based on overlapping of growing Pascal triangles
      i = 1 - degree;
      for (::coder::SizeType p{i}; p <= maxLayers; p++) {
        //  Within each level, x^deg is at the peak of Pascal triangle
        cornerTriangle = (cornerTriangle + p) + degree;
        counterBottomRow = 0;
        // counter for the bottom row to be subtracted later
        for (::coder::SizeType k{0}; k < deg; k++) {
          for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          counterBottomRow++;
        }
        deg--;
        x_tmp = p + degree;
        ret = ((x_tmp << 1) - p) - 1;
        if (ret < 0) {
          ret = 0;
        }
        excess += ret;
        d = (d + p) + 1;
        // number of terms in Pascal tetrahedron
        nTermsInPrevLayer = nTermsInLayer;
        nTermsInLayer = d + 3 * (excess - cornerTriangle);
        balance = nTermsInPrevLayer + counterBottomRow;
        degg = -degree;
        for (::coder::SizeType k{0}; k < degg; k++) {
          ret = (x_tmp - k) - 1;
          if (ret < 0) {
            ret = -ret;
          }
          partition = -degree - ret;
          for (::coder::SizeType j{0}; j <= partition; j++) {
            scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
            for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(iPnt + offset) + V.size(1) * c] =
                  V[(iPnt + 3 * stride) + V.size(1) * (c - balance)] * scalew;
            }
            c++;
          }
        }
      }
    }
  } else {
    c = 4;
    for (::coder::SizeType col{0}; col < 6; col++) {
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * col] = 0.0;
      }
    }
    if (degree < 0) {
      i = -degree;
    } else {
      i = degree;
    }
    for (deg = 2; deg <= i; deg++) {
      scalew = static_cast<real_T>(deg) * hs_inv_idx_2;
      for (::coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        ret = offset + iPnt;
        V[ret + V.size(1) * (c + 2)] =
            V[(iPnt + 3 * stride) + V.size(1) * (c - 1)] * scalew;
        V[ret + V.size(1) * (c + 1)] = 0.0;
        V[ret + V.size(1) * c] = 0.0;
      }
      c += 3;
    }
  }
}

//  onaxes - Check whether the points are all on the axes
static boolean_T onaxes(const ::coder::array<real_T, 2U> &us,
                        ::coder::SizeType npnts)
{
  boolean_T tf;
  tf = true;
  if (us.size(1) == 2) {
    ::coder::SizeType i;
    boolean_T exitg2;
    i = 0;
    exitg2 = false;
    while ((!exitg2) && (i <= npnts - 1)) {
      if ((us[us.size(1) * i] != 0.0) + (us[us.size(1) * i + 1] != 0.0) > 1) {
        tf = false;
        exitg2 = true;
      } else {
        i++;
      }
    }
  } else if (us.size(1) == 3) {
    ::coder::SizeType i;
    boolean_T exitg1;
    i = 0;
    exitg1 = false;
    while ((!exitg1) && (i <= npnts - 1)) {
      if (((us[us.size(1) * i] != 0.0) + (us[us.size(1) * i + 1] != 0.0)) +
              (us[us.size(1) * i + 2] != 0.0) >
          1) {
        tf = false;
        exitg1 = true;
      } else {
        i++;
      }
    }
  }
  return tf;
}

//  rrqr_factor  Compute rank-revealing QR with column pivoting
static void rrqr_factor(const ::coder::array<real_T, 2U> &A, real_T thres,
                        ::coder::SizeType rowoffset,
                        ::coder::SizeType coloffset, ::coder::SizeType m,
                        ::coder::SizeType n, ::coder::array<real_T, 2U> &QR,
                        ::coder::array<int32_T, 1U> &p, int32_T *rank,
                        ::coder::array<real_T, 1U> &work)
{
  ::coder::SizeType wsize;
  if (m == 0) {
    m = A.size(1) - rowoffset;
  } else {
    m2cAssert(m + rowoffset <= A.size(1),
              "Number of rows cannot exceed nrows(A).");
  }
  if (n == 0) {
    n = A.size(0) - coloffset;
  } else {
    m2cAssert(n + coloffset <= A.size(0),
              "Number of ncolumns cannot exceed ncols(A).");
  }
  //  Preallocate output arguments
  m2cAssert(QR.size(1) == A.size(1),
            "The number of rows in QR must be equal to that of A.");
  m2cAssert(QR.size(0) >= n + 1,
            "The number of columns in QR must be greater than that of A.");
  m2cAssert(p.size(0) >= n, "Length of permutation vector must be no smaller "
                            "than the number of columns.");
  //  Allocate work space if needed
  wsize = wls::query_work_size(m, n);
  work.set_size(wsize);
  p[0] = 0;
  *rank = wls::rrqr_factor(&A[rowoffset + A.size(1) * coloffset], thres, m, n,
                           &QR[0], &(p.data())[0], &(work.data())[0], wsize,
                           A.size(1));
}

//  rrqr_qmulti  Perform Q*bs, where Q is stored implicitly in QR
static void rrqr_qmulti(const ::coder::array<real_T, 2U> &QR,
                        ::coder::SizeType m, ::coder::SizeType n,
                        ::coder::SizeType rank, ::coder::array<real_T, 2U> &bs,
                        ::coder::SizeType nrhs,
                        ::coder::array<real_T, 1U> &work)
{
  ::coder::SizeType stride_bs;
  ::coder::SizeType u1;
  ::coder::SizeType wsize;
  stride_bs = bs.size(1);
  //  Obtain input arguments
  if (m == 0) {
    m = QR.size(1);
  }
  if (n == 0) {
    n = QR.size(0) - 1;
  }
  if (rank == 0) {
    rank = n;
  }
  u1 = n;
  if (m <= n) {
    u1 = m;
  }
  if ((rank > u1) || (rank < 1)) {
    m2cErrMsgIdAndTxt(
        "wlslib:WrongRank",
        "Rank %d must be a positive value no greater than min(%d, %d).",
        (int)rank, (int)m, (int)n);
  }
  if (nrhs == 0) {
    nrhs = bs.size(0);
  }
  //  Resize work space if needed
  wsize = wls::query_work_size(m, n);
  work.set_size(wsize);
  u1 = n + 1;
  for (::coder::SizeType i{u1}; i <= m; i++) {
    for (::coder::SizeType j{0}; j < nrhs; j++) {
      bs[(i + bs.size(1) * j) - 1] = 0.0;
    }
  }
  //  Invoke C++ function
  wls::rrqr_qmulti(&QR[0], m, n, rank, QR.size(1), nrhs, &bs[0], stride_bs,
                   &(work.data())[0], wsize);
}

//  rrqr_rtsolve  Perform forward substitution to compute bs=R'\bs, where R is
static void rrqr_rtsolve(const ::coder::array<real_T, 2U> &QR,
                         ::coder::SizeType n, ::coder::SizeType rank,
                         ::coder::array<real_T, 2U> &bs, ::coder::SizeType nrhs)
{
  ::coder::SizeType i;
  if (n == 0) {
    n = QR.size(0) - 1;
  }
  if (rank == 0) {
    rank = n;
  }
  if (QR.size(1) > n) {
    i = n;
  } else {
    i = QR.size(1);
  }
  if ((rank > i) || (rank < 1)) {
    m2cErrMsgIdAndTxt(
        "wlslib:WrongRank",
        "Rank %d must be a positive value no greater than min(%d, %d).",
        (int)rank, (int)QR.size(1), (int)n);
  }
  if (nrhs == 0) {
    nrhs = bs.size(0);
  }
  //  Obtain stride
  wls::rrqr_rtsolve(&QR[0], n, rank, QR.size(1), nrhs, &bs[0], bs.size(1));
}

//  wls_buhmann_weights  Weights based on Buhmann's radial basis function
static void wls_buhmann_weights(const ::coder::array<real_T, 2U> &us,
                                ::coder::SizeType npoints,
                                ::coder::SizeType degree, boolean_T unimono,
                                const ::coder::array<real_T, 1U> &params_sh,
                                const ::coder::array<real_T, 2U> &params_pw,
                                ::coder::array<real_T, 1U> &ws)
{
  real_T d;
  real_T dist_k;
  real_T r;
  real_T r1;
  real_T r2;
  real_T rho;
  real_T sigma;
  ::coder::SizeType abs_degree;
  ::coder::SizeType i;
  if (degree == 0) {
    degree = 2;
  }
  if (degree < 0) {
    abs_degree = 1 - degree;
  } else {
    abs_degree = degree + 1;
  }
  if ((params_sh.size(0) != 0) && (params_sh[0] != 0.0)) {
    sigma = params_sh[0];

    //  Assign default rho
  } else if (abs_degree - 1 >= 9) {
    sigma = 1.2;
  } else {
    sigma = dv1[abs_degree - 2];
  }
  if (ws.size(0) == 0) {
    ws.set_size(npoints);
  } else {
    m2cAssert(ws.size(0) >= npoints,
              "length of ws cannot be smaller than npoints");
  }
  //  Compute rho to be sigma times the kth distance for k=ceil(1.5*ncoff)
  if (degree >= 0) {
    //  Compute 2-norm
    i = us.size(1);
    for (::coder::SizeType b_i{0}; b_i < npoints; b_i++) {
      d = us[us.size(1) * b_i];
      r2 = d * d;
      for (::coder::SizeType j{2}; j <= i; j++) {
        d = us[(j + us.size(1) * b_i) - 1];
        r2 += d * d;
      }
      ws[b_i] = std::sqrt(r2);
    }
  } else {
    //  Compute inf-norm for tensor-product
    i = us.size(1);
    for (::coder::SizeType b_i{0}; b_i < npoints; b_i++) {
      r = std::abs(us[us.size(1) * b_i]);
      for (::coder::SizeType j{2}; j <= i; j++) {
        r1 = std::abs(us[(j + us.size(1) * b_i) - 1]);
        if (r1 > r) {
          r = r1;
        }
      }
      ws[b_i] = r;
    }
  }
  if (us.size(1) == 1) {
    i = abs_degree;
  } else if (us.size(1) == 2) {
    if (unimono) {
      i = ((abs_degree - 1) << 1) + 1;
    } else if (degree < 0) {
      i = abs_degree * abs_degree;
    } else {
      i = (abs_degree + 1) * abs_degree / 2;
    }
  } else if (unimono) {
    i = 3 * (abs_degree - 1) + 1;
  } else if (degree < 0) {
    i = abs_degree * abs_degree * abs_degree;
  } else {
    i = (abs_degree + 2) * (abs_degree + 1) * abs_degree / 6;
  }
  dist_k = find_kth_shortest_dist(ws, (i * 3 + 1) / 2, 1, npoints);
  rho = sigma * dist_k;
  if ((params_pw.size(0) == 0) || (params_pw.size(1) == 0)) {
    for (::coder::SizeType b_i{0}; b_i < npoints; b_i++) {
      if (degree > 0) {
        //  Compute 2-norm
        d = us[us.size(1) * b_i];
        r2 = d * d;
        i = us.size(1);
        for (::coder::SizeType j{2}; j <= i; j++) {
          d = us[(j + us.size(1) * b_i) - 1];
          r2 += d * d;
        }
        r = std::sqrt(r2);
      } else {
        //  Compute inf-norm for tensor-product
        r = std::abs(us[us.size(1) * b_i]);
        i = us.size(1);
        for (::coder::SizeType j{2}; j <= i; j++) {
          r1 = std::abs(us[(j + us.size(1) * b_i) - 1]);
          if (r1 > r) {
            r = r1;
          }
        }
      }
      if (r > rho) {
        ws[b_i] = 0.0;
      } else {
        real_T r_sqrt;
        r /= rho;
        r_sqrt = std::sqrt(r);
        ws[b_i] = r * r *
                      (r * r_sqrt *
                           (r_sqrt * (r_sqrt * 112.0 / 45.0 + -7.0) +
                            5.333333333333333) +
                       -0.93333333333333335) +
                  0.1111111111111111;
      }
    }
  } else {
    m2cAssert(params_pw.size(0) >= npoints,
              "size(params_pw,1) should be >=npoints");
    for (::coder::SizeType b_i{0}; b_i < npoints; b_i++) {
      real_T b_gamma;
      b_gamma = params_pw[params_pw.size(1) * b_i];
      if (b_gamma <= 0.0) {
        ws[b_i] = 0.0;
      } else {
        if (degree > 0) {
          //  Compute 2-norm
          d = us[us.size(1) * b_i];
          r2 = d * d;
          i = us.size(1);
          for (::coder::SizeType j{2}; j <= i; j++) {
            d = us[(j + us.size(1) * b_i) - 1];
            r2 += d * d;
          }
          r = std::sqrt(r2);
        } else {
          //  Compute inf-norm for tensor-product
          r = std::abs(us[us.size(1) * b_i]);
          i = us.size(1);
          for (::coder::SizeType j{2}; j <= i; j++) {
            r1 = std::abs(us[(j + us.size(1) * b_i) - 1]);
            if (r1 > r) {
              r = r1;
            }
          }
        }
        if (r > rho) {
          ws[b_i] = 0.0;
        } else {
          real_T r_sqrt;
          r /= rho;
          r_sqrt = std::sqrt(r);
          ws[b_i] =
              b_gamma * (r * r *
                             (r * r_sqrt *
                                  (r_sqrt * (r_sqrt * 112.0 / 45.0 + -7.0) +
                                   5.333333333333333) +
                              -0.93333333333333335) +
                         0.1111111111111111);
        }
      }
    }
  }
}

//  wls_eno_weights  WLS-ENO weights based on function values
static void wls_eno_weights(const ::coder::array<real_T, 2U> &us,
                            ::coder::SizeType npoints, ::coder::SizeType degree,
                            const ::coder::array<real_T, 2U> &us_unscaled,
                            const ::coder::array<real_T, 1U> &params_sh,
                            const ::coder::array<real_T, 2U> &params_pw,
                            ::coder::array<real_T, 1U> &ws)
{
  real_T c0;
  real_T c1;
  real_T c1dfg;
  real_T epsilon_ENO;
  real_T epsilon_ID;
  real_T h2bar;
  real_T h2bar_tmp;
  real_T safegauard;
  m2cAssert(params_sh.size(0) >= 2, "first two shared parameters are required");
  m2cAssert(params_pw.size(0) >= npoints,
            "size(params_pw,1) should be >=npoints");
  m2cAssert(params_pw.size(1) >= 2, "size(params_pw,2) should be >=2");
  if (ws.size(0) == 0) {
    ws.set_size(npoints);
  } else {
    m2cAssert(ws.size(0) >= npoints,
              "length of ws cannot be smaller than npoints");
  }
  //  Compute hbar using ws as buffer space
  if (degree >= 0) {
    ::coder::SizeType i;
    //  Compute 2-norm
    i = us_unscaled.size(1);
    for (::coder::SizeType b_i{0}; b_i < npoints; b_i++) {
      real_T r2;
      h2bar_tmp = us_unscaled[us_unscaled.size(1) * b_i];
      r2 = h2bar_tmp * h2bar_tmp;
      for (::coder::SizeType j{2}; j <= i; j++) {
        h2bar_tmp = us_unscaled[(j + us_unscaled.size(1) * b_i) - 1];
        r2 += h2bar_tmp * h2bar_tmp;
      }
      ws[b_i] = std::sqrt(r2);
    }
  } else {
    ::coder::SizeType i;
    //  Compute inf-norm for tensor-product
    i = us_unscaled.size(1);
    for (::coder::SizeType b_i{0}; b_i < npoints; b_i++) {
      real_T r;
      r = std::abs(us_unscaled[us_unscaled.size(1) * b_i]);
      for (::coder::SizeType j{2}; j <= i; j++) {
        real_T r1;
        r1 = std::abs(us_unscaled[(j + us_unscaled.size(1) * b_i) - 1]);
        if (r1 > r) {
          r = r1;
        }
      }
      ws[b_i] = r;
    }
  }
  h2bar = ws[0] * ws[0];
  for (::coder::SizeType b_i{2}; b_i <= npoints; b_i++) {
    h2bar_tmp = ws[b_i - 1];
    h2bar += h2bar_tmp * h2bar_tmp;
  }
  h2bar /= static_cast<real_T>(npoints);
  //  Evaluate the inverse-distance weights as base
  if ((params_sh.size(0) >= 5) && (params_sh[4] != 0.0)) {
    epsilon_ID = params_sh[4];
  } else {
    epsilon_ID = 0.01;
  }
  wls_invdist_weights(us, npoints, 0.5 - static_cast<real_T>(degree < 0),
                      epsilon_ID, ws);
  if ((params_sh.size(0) >= 3) && (params_sh[2] != 0.0)) {
    c0 = params_sh[2];
  } else {
    c0 = 1.0;
  }
  if ((params_sh.size(0) >= 4) && (params_sh[3] != 0.0)) {
    c1 = params_sh[3];
  } else {
    c1 = 0.05;
  }
  c1dfg = c1 * params_sh[1];
  if ((params_sh.size(0) >= 6) && (params_sh[5] != 0.0)) {
    epsilon_ENO = params_sh[5];
  } else {
    epsilon_ENO = 0.001;
  }
  safegauard = epsilon_ENO * (params_sh[1] * params_sh[1]) * h2bar;
  if (params_pw.size(1) > 2) {
    for (::coder::SizeType b_i{0}; b_i < npoints; b_i++) {
      h2bar_tmp = params_pw[params_pw.size(1) * b_i] - params_sh[0];
      ws[b_i] = ws[b_i] / ((c0 * (h2bar_tmp * h2bar_tmp) +
                            c1dfg * params_pw[params_pw.size(1) * b_i + 1]) +
                           safegauard);
    }
  }
}

// wls_eval_ops - Evaluate the operator with given function values
static inline void wls_eval_ops(WlsObject *b_wls,
                                const ::coder::array<real_T, 2U> &vdops,
                                const ::coder::array<real_T, 2U> &fs,
                                ::coder::array<real_T, 2U> &results)
{
  if ((fs.size(0) == 0) || (fs.size(1) == 0)) {
    results.set_size(vdops.size(1), 0);
  } else if ((fs.size(1) == 1) || (fs.size(0) == vdops.size(0))) {
    ::coder::SizeType i;
    ::coder::SizeType nrows;
    ::coder::SizeType unnamed_idx_0;
    nrows = vdops.size(1);
    results.set_size(vdops.size(1), fs.size(1));
    unnamed_idx_0 = fs.size(1) * vdops.size(1);
    for (i = 0; i < unnamed_idx_0; i++) {
      results[i] = 0.0;
    }
    //  Compute solution
    i = fs.size(1);
    for (::coder::SizeType iFunc{0}; iFunc < i; iFunc++) {
      ::coder::SizeType iOp;
      iOp = 0;
      for (::coder::SizeType iDiff{0}; iDiff < nrows; iDiff++) {
        ::coder::SizeType i1;
        i1 = vdops.size(0);
        for (::coder::SizeType iRow{0}; iRow < i1; iRow++) {
          results[iFunc + results.size(1) * iOp] =
              results[iFunc + results.size(1) * iOp] +
              fs[iFunc + fs.size(1) * iRow] *
                  vdops[iDiff + vdops.size(1) * iRow];
        }
        if (iOp + 1 == results.size(0)) {
          iOp = 0;
        } else {
          iOp++;
        }
      }
    }
  } else {
    ::coder::SizeType i;
    ::coder::SizeType i1;
    ::coder::SizeType i2;
    ::coder::SizeType i3;
    ::coder::SizeType nrows;
    ::coder::SizeType unnamed_idx_0;
    m2cAssert(fs.size(1) * fs.size(0) == vdops.size(0),
              "Size of fs must match size(vdops, 1)");
    //  use wls.V and wls.QRt as buffer spaces
    unnamed_idx_0 = fs.size(1) * fs.size(0);
    i = 0;
    i1 = 0;
    i2 = 0;
    i3 = 0;
    b_wls->V.set_size(unnamed_idx_0, 1);
    for (::coder::SizeType i4{0}; i4 < unnamed_idx_0; i4++) {
      b_wls->V[i1 + b_wls->V.size(1) * i] = fs[i3 + fs.size(1) * i2];
      i++;
      i2++;
      if (i > b_wls->V.size(0) - 1) {
        i = 0;
        i1++;
      }
      if (i2 > fs.size(0) - 1) {
        i2 = 0;
        i3++;
      }
    }
    nrows = vdops.size(1);
    m2cAssert((b_wls->V.size(0) != 0) && (b_wls->V.size(1) != 0),
              "Cannot be empty");
    results.set_size(vdops.size(1), b_wls->V.size(1));
    unnamed_idx_0 = b_wls->V.size(1) * vdops.size(1);
    for (i = 0; i < unnamed_idx_0; i++) {
      results[i] = 0.0;
    }
    //  Compute solution
    i = b_wls->V.size(1);
    for (::coder::SizeType iFunc{0}; iFunc < i; iFunc++) {
      ::coder::SizeType iOp;
      iOp = 0;
      for (::coder::SizeType iDiff{0}; iDiff < nrows; iDiff++) {
        i1 = vdops.size(0);
        for (::coder::SizeType iRow{0}; iRow < i1; iRow++) {
          results[iFunc + results.size(1) * iOp] =
              results[iFunc + results.size(1) * iOp] +
              b_wls->V[iFunc + b_wls->V.size(1) * iRow] *
                  vdops[iDiff + vdops.size(1) * iRow];
        }
        if (iOp + 1 == results.size(0)) {
          iOp = 0;
        } else {
          iOp++;
        }
      }
    }
  }
}

//  wls_invdist_weights  Weights based on inverse distance
static void wls_invdist_weights(const ::coder::array<real_T, 2U> &us,
                                ::coder::SizeType npoints,
                                ::coder::SizeType degree,
                                const ::coder::array<real_T, 1U> &params_sh,
                                const ::coder::array<real_T, 2U> &params_pw,
                                ::coder::array<real_T, 1U> &ws)
{
  real_T alpha;
  real_T epsilon;
  ::coder::SizeType b_degree;
  epsilon = 0.01;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  alpha = static_cast<real_T>(b_degree) / 2.0;
  if ((params_sh.size(0) != 0) && (params_sh[0] != 0.0)) {
    epsilon = params_sh[0];
  }
  if ((params_sh.size(0) > 1) && (params_sh[1] != 0.0)) {
    alpha = params_sh[1];
  }
  if (ws.size(0) == 0) {
    ws.set_size(npoints);
  } else {
    m2cAssert(ws.size(0) >= npoints,
              "length of ws cannot be smaller than npoints");
  }
  if ((params_pw.size(0) == 0) || (params_pw.size(1) == 0)) {
    for (::coder::SizeType i{0}; i < npoints; i++) {
      real_T r;
      real_T r2;
      r = std::abs(us[us.size(1) * i]);
      if (us.size(1) > 1) {
        if (degree > 0) {
          //  Compute 2-norm
          r2 = r * r;
          b_degree = us.size(1);
          for (::coder::SizeType j{2}; j <= b_degree; j++) {
            real_T d;
            d = us[(j + us.size(1) * i) - 1];
            r2 += d * d;
          }
        } else {
          //  Compute inf-norm for tensor-product
          b_degree = us.size(1);
          for (::coder::SizeType j{2}; j <= b_degree; j++) {
            real_T r1;
            r1 = std::abs(us[(j + us.size(1) * i) - 1]);
            if (r1 > r) {
              r = r1;
            }
          }
          r2 = r * r;
        }
      } else {
        r2 = r * r;
      }
      //  Compute weight
      ws[i] = std::pow(std::sqrt(r2 + epsilon), -alpha);
    }
  } else {
    m2cAssert(params_pw.size(0) >= npoints,
              "size(params_pw,1) should be >=npoints");
    for (::coder::SizeType i{0}; i < npoints; i++) {
      real_T b_gamma;
      b_gamma = params_pw[params_pw.size(1) * i];
      if (b_gamma <= 0.0) {
        ws[i] = 0.0;
      } else {
        real_T r;
        real_T r2;
        r = std::abs(us[us.size(1) * i]);
        if (us.size(1) > 1) {
          if (degree > 0) {
            //  Compute 2-norm
            r2 = r * r;
            b_degree = us.size(1);
            for (::coder::SizeType j{2}; j <= b_degree; j++) {
              real_T d;
              d = us[(j + us.size(1) * i) - 1];
              r2 += d * d;
            }
          } else {
            //  Compute inf-norm for tensor-product
            b_degree = us.size(1);
            for (::coder::SizeType j{2}; j <= b_degree; j++) {
              real_T r1;
              r1 = std::abs(us[(j + us.size(1) * i) - 1]);
              if (r1 > r) {
                r = r1;
              }
            }
            r2 = r * r;
          }
        } else {
          r2 = r * r;
        }
        //  Compute weight
        ws[i] = b_gamma * std::pow(std::sqrt(r2 + epsilon), -alpha);
      }
    }
  }
}

//  wls_invdist_weights  Weights based on inverse distance
static void wls_invdist_weights(const ::coder::array<real_T, 2U> &us,
                                ::coder::SizeType npoints, real_T degree,
                                real_T params_sh,
                                ::coder::array<real_T, 1U> &ws)
{
  real_T alpha;
  real_T epsilon;
  epsilon = 0.01;
  alpha = std::abs(degree) / 2.0;
  if (params_sh != 0.0) {
    epsilon = params_sh;
  }
  m2cAssert(ws.size(0) >= npoints,
            "length of ws cannot be smaller than npoints");
  for (::coder::SizeType i{0}; i < npoints; i++) {
    real_T r;
    real_T r2;
    r = std::abs(us[us.size(1) * i]);
    if (us.size(1) > 1) {
      if (degree > 0.0) {
        ::coder::SizeType b_i;
        //  Compute 2-norm
        r2 = r * r;
        b_i = us.size(1);
        for (::coder::SizeType j{2}; j <= b_i; j++) {
          real_T d;
          d = us[(j + us.size(1) * i) - 1];
          r2 += d * d;
        }
      } else {
        ::coder::SizeType b_i;
        //  Compute inf-norm for tensor-product
        b_i = us.size(1);
        for (::coder::SizeType j{2}; j <= b_i; j++) {
          real_T r1;
          r1 = std::abs(us[(j + us.size(1) * i) - 1]);
          if (r1 > r) {
            r = r1;
          }
        }
        r2 = r * r;
      }
    } else {
      r2 = r * r;
    }
    //  Compute weight
    ws[i] = std::pow(std::sqrt(r2 + epsilon), -alpha);
  }
}

//  wls_invdist_weights  Weights based on inverse distance
static void wls_invdist_weights(const ::coder::array<real_T, 2U> &us,
                                ::coder::SizeType npoints,
                                ::coder::SizeType degree,
                                ::coder::array<real_T, 1U> &ws)
{
  real_T alpha;
  ::coder::SizeType b_degree;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  alpha = static_cast<real_T>(b_degree) / 2.0;
  if (ws.size(0) == 0) {
    ws.set_size(npoints);
  } else {
    m2cAssert(ws.size(0) >= npoints,
              "length of ws cannot be smaller than npoints");
  }
  for (::coder::SizeType i{0}; i < npoints; i++) {
    real_T r;
    real_T r2;
    r = std::abs(us[us.size(1) * i]);
    if (us.size(1) > 1) {
      if (degree > 0) {
        //  Compute 2-norm
        r2 = r * r;
        b_degree = us.size(1);
        for (::coder::SizeType j{2}; j <= b_degree; j++) {
          real_T d;
          d = us[(j + us.size(1) * i) - 1];
          r2 += d * d;
        }
      } else {
        //  Compute inf-norm for tensor-product
        b_degree = us.size(1);
        for (::coder::SizeType j{2}; j <= b_degree; j++) {
          real_T r1;
          r1 = std::abs(us[(j + us.size(1) * i) - 1]);
          if (r1 > r) {
            r = r1;
          }
        }
        r2 = r * r;
      }
    } else {
      r2 = r * r;
    }
    //  Compute weight
    ws[i] = std::pow(std::sqrt(r2 + 0.01), -alpha);
  }
}

//  wls_kernel - Kernel for evaluating an operator at one or more points using
static void wls_kernel(WlsObject *b_wls,
                       const ::coder::array<real_T, 2U> &eval_pnts,
                       const ::coder::array<real_T, 2U> &fs,
                       ::coder::array<real_T, 2U> &vdops,
                       ::coder::array<real_T, 2U> &results)
{
  real_T timestamp;
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  nevpnts = eval_pnts.size(0);
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  b_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->unimono,
               b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  b_wls_update_rhs(b_wls);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  b_wls_solve_sys(b_wls, vdops);
  //  Rearrange vdops using wls.V as work space
  wls_eval_ops(b_wls, vdops, fs, results);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_kernel - Kernel for evaluating an operator at one or more points using
static void wls_kernel(WlsObject *b_wls,
                       const ::coder::array<real_T, 2U> &eval_pnts,
                       const ::coder::array<real_T, 2U> &fs,
                       ::coder::SizeType nevpnts,
                       ::coder::array<real_T, 2U> &vdops,
                       ::coder::array<real_T, 2U> &results)
{
  real_T timestamp;
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  b_gen_vander(b_wls->us, b_nevpnts, b_wls->degree, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  b_wls_update_rhs(b_wls);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  b_wls_solve_sys(b_wls, vdops);
  //  Rearrange vdops using wls.V as work space
  wls_eval_ops(b_wls, vdops, fs, results);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_kernel - Kernel for evaluating an operator at one or more points using
static void
wls_kernel(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
           const int8_T diff_idx_data[], ::coder::SizeType diff_idx_size,
           const ::coder::array<real_T, 2U> &fs, ::coder::SizeType nevpnts,
           ::coder::array<real_T, 2U> &vdops,
           ::coder::array<real_T, 2U> &results)
{
  real_T timestamp;
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, b_nevpnts, b_wls->degree, b_wls->hs_inv, b_wls->unimono,
             b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  wls_update_rhs(b_wls, diff_idx_data, diff_idx_size);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  wls_solve_sys(b_wls, diff_idx_data, diff_idx_size, vdops);
  //  Rearrange vdops using wls.V as work space
  wls_eval_ops(b_wls, vdops, fs, results);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_kernel - Kernel for evaluating an operator at one or more points using
static void wls_kernel(WlsObject *b_wls,
                       const ::coder::array<real_T, 2U> &eval_pnts,
                       const int8_T diff_idx_data[],
                       ::coder::SizeType diff_idx_size,
                       ::coder::SizeType nevpnts,
                       const ::coder::array<real_T, 2U> &varargin_1,
                       ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, b_nevpnts, b_wls->degree, b_wls->hs_inv, b_wls->unimono,
             b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  wls_update_rhs(b_wls, diff_idx_data, diff_idx_size, varargin_1);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  b_wls_solve_sys(b_wls, diff_idx_data, diff_idx_size, vdops);
  //  Rearrange vdops using wls.V as work space
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_kernel - Kernel for evaluating an operator at one or more points using
static void
wls_kernel(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
           const int8_T diff_idx_data[], ::coder::SizeType diff_idx_size,
           ::coder::SizeType nevpnts, ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, b_nevpnts, b_wls->degree, b_wls->hs_inv, b_wls->unimono,
             b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  c_wls_update_rhs(b_wls, diff_idx_data, diff_idx_size);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  b_wls_solve_sys(b_wls, diff_idx_data, diff_idx_size, vdops);
  //  Rearrange vdops using wls.V as work space
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_kernel - Kernel for evaluating an operator at one or more points using
static void
wls_kernel(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
           const int8_T diff_idx_data[], ::coder::SizeType diff_idx_size,
           const ::coder::array<real_T, 2U> &fs, ::coder::SizeType nevpnts,
           const ::coder::array<real_T, 2U> &varargin_1,
           ::coder::array<real_T, 2U> &vdops,
           ::coder::array<real_T, 2U> &results)
{
  real_T timestamp;
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, b_nevpnts, b_wls->degree, b_wls->hs_inv, b_wls->unimono,
             b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  wls_update_rhs(b_wls, diff_idx_data, diff_idx_size, varargin_1);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  b_wls_solve_sys(b_wls, diff_idx_data, diff_idx_size, vdops);
  //  Rearrange vdops using wls.V as work space
  wls_eval_ops(b_wls, vdops, fs, results);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_kernel - Kernel for evaluating an operator at one or more points using
static void wls_kernel(WlsObject *b_wls,
                       const ::coder::array<real_T, 2U> &eval_pnts,
                       const int8_T diff_idx_data[],
                       ::coder::SizeType diff_idx_size,
                       const ::coder::array<real_T, 2U> &fs,
                       ::coder::array<real_T, 2U> &vdops,
                       ::coder::array<real_T, 2U> &results)
{
  real_T timestamp;
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  nevpnts = eval_pnts.size(0);
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv,
             b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  wls_update_rhs(b_wls, diff_idx_data, diff_idx_size);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  wls_solve_sys(b_wls, diff_idx_data, diff_idx_size, vdops);
  //  Rearrange vdops using wls.V as work space
  wls_eval_ops(b_wls, vdops, fs, results);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_kernel - Kernel for evaluating an operator at one or more points using
static void wls_kernel(WlsObject *b_wls,
                       const ::coder::array<real_T, 2U> &eval_pnts,
                       const int8_T diff_idx_data[],
                       ::coder::SizeType diff_idx_size,
                       ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  nevpnts = eval_pnts.size(0);
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv,
             b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  wls_update_rhs(b_wls, diff_idx_data, diff_idx_size);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  wls_solve_sys(b_wls, diff_idx_data, diff_idx_size, vdops);
  //  Rearrange vdops using wls.V as work space
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_kernel - Kernel for evaluating an operator at one or more points using
static void wls_kernel(WlsObject *b_wls,
                       const ::coder::array<real_T, 2U> &eval_pnts,
                       const ::coder::array<real_T, 2U> &fs,
                       ::coder::SizeType nevpnts,
                       const ::coder::array<real_T, 2U> &varargin_1,
                       ::coder::array<real_T, 2U> &vdops,
                       ::coder::array<real_T, 2U> &results)
{
  real_T timestamp;
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, b_nevpnts, b_wls->degree, b_wls->hs_inv, b_wls->unimono,
             b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  b_wls_update_rhs(b_wls, varargin_1);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  b_wls_solve_sys(b_wls, varargin_1, vdops);
  //  Rearrange vdops using wls.V as work space
  wls_eval_ops(b_wls, vdops, fs, results);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_kernel - Kernel for evaluating an operator at one or more points using
static void wls_kernel(WlsObject *b_wls,
                       const ::coder::array<real_T, 2U> &eval_pnts,
                       ::coder::SizeType nevpnts,
                       const ::coder::array<real_T, 2U> &varargin_1,
                       ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, b_nevpnts, b_wls->degree, b_wls->hs_inv, b_wls->unimono,
             b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  b_wls_update_rhs(b_wls, varargin_1);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  b_wls_solve_sys(b_wls, varargin_1, vdops);
  //  Rearrange vdops using wls.V as work space
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_kernel - Kernel for evaluating an operator at one or more points using
static void wls_kernel(WlsObject *b_wls,
                       const ::coder::array<real_T, 2U> &eval_pnts,
                       const int8_T diff_idx_data[],
                       const ::coder::SizeType diff_idx_size[2],
                       ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  nevpnts = eval_pnts.size(0);
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv,
             b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  wls_update_rhs(b_wls, diff_idx_data, diff_idx_size);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  wls_solve_sys(b_wls, diff_idx_data, diff_idx_size, vdops);
  //  Rearrange vdops using wls.V as work space
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_kernel - Kernel for evaluating an operator at one or more points using
static void wls_kernel(WlsObject *b_wls,
                       const ::coder::array<real_T, 2U> &eval_pnts,
                       const int8_T diff_idx_data[],
                       const ::coder::SizeType diff_idx_size[2],
                       const ::coder::array<real_T, 2U> &fs,
                       ::coder::array<real_T, 2U> &vdops,
                       ::coder::array<real_T, 2U> &results)
{
  real_T timestamp;
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  nevpnts = eval_pnts.size(0);
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv,
             b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  wls_update_rhs(b_wls, diff_idx_data, diff_idx_size);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  wls_solve_sys(b_wls, diff_idx_data, diff_idx_size, vdops);
  //  Rearrange vdops using wls.V as work space
  wls_eval_ops(b_wls, vdops, fs, results);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_kernel - Kernel for evaluating an operator at one or more points using
static void wls_kernel(
    WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
    const int8_T diff_idx_data[], const ::coder::SizeType diff_idx_size[2],
    const ::coder::array<real_T, 2U> &fs, ::coder::SizeType nevpnts,
    ::coder::array<real_T, 2U> &vdops, ::coder::array<real_T, 2U> &results)
{
  real_T timestamp;
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, b_nevpnts, b_wls->degree, b_wls->hs_inv, b_wls->unimono,
             b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  wls_update_rhs(b_wls, diff_idx_data, diff_idx_size);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  wls_solve_sys(b_wls, diff_idx_data, diff_idx_size, vdops);
  //  Rearrange vdops using wls.V as work space
  wls_eval_ops(b_wls, vdops, fs, results);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_kernel - Kernel for evaluating an operator at one or more points using
static void wls_kernel(WlsObject *b_wls,
                       const ::coder::array<real_T, 2U> &eval_pnts,
                       const int8_T diff_idx_data[],
                       const ::coder::SizeType diff_idx_size[2],
                       ::coder::SizeType nevpnts,
                       const ::coder::array<real_T, 2U> &varargin_1,
                       ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  e_gen_vander(b_wls->us, b_nevpnts, b_wls->degree, b_wls->hs_inv,
               b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  wls_update_rhs(b_wls, diff_idx_data, diff_idx_size, varargin_1);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  b_wls_solve_sys(b_wls, diff_idx_data, diff_idx_size, vdops);
  //  Rearrange vdops using wls.V as work space
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_kernel - Kernel for evaluating an operator at one or more points using
static void wls_kernel(WlsObject *b_wls,
                       const ::coder::array<real_T, 2U> &eval_pnts,
                       ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  nevpnts = eval_pnts.size(0);
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv,
             b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  wls_update_rhs(b_wls);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  wls_solve_sys(b_wls, vdops);
  //  Rearrange vdops using wls.V as work space
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_kernel - Kernel for evaluating an operator at one or more points using
static void wls_kernel(WlsObject *b_wls,
                       const ::coder::array<real_T, 2U> &eval_pnts,
                       ::coder::SizeType nevpnts,
                       ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, b_nevpnts, b_wls->degree, b_wls->hs_inv, b_wls->unimono,
             b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  wls_update_rhs(b_wls);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  wls_solve_sys(b_wls, vdops);
  //  Rearrange vdops using wls.V as work space
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_kernel - Kernel for evaluating an operator at one or more points using
static void wls_kernel(WlsObject *b_wls,
                       const ::coder::array<real_T, 2U> &eval_pnts,
                       const int8_T diff_idx_data[],
                       const ::coder::SizeType diff_idx_size[2],
                       ::coder::SizeType nevpnts,
                       ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  e_gen_vander(b_wls->us, b_nevpnts, b_wls->degree, b_wls->hs_inv,
               b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  b_wls_update_rhs(b_wls, diff_idx_data, diff_idx_size);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  b_wls_solve_sys(b_wls, diff_idx_data, diff_idx_size, vdops);
  //  Rearrange vdops using wls.V as work space
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_kernel - Kernel for evaluating an operator at one or more points using
static void wls_kernel(
    WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
    const int8_T diff_idx_data[], const ::coder::SizeType diff_idx_size[2],
    const ::coder::array<real_T, 2U> &fs, ::coder::SizeType nevpnts,
    const ::coder::array<real_T, 2U> &varargin_1,
    ::coder::array<real_T, 2U> &vdops, ::coder::array<real_T, 2U> &results)
{
  real_T timestamp;
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  e_gen_vander(b_wls->us, b_nevpnts, b_wls->degree, b_wls->hs_inv,
               b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  wls_update_rhs(b_wls, diff_idx_data, diff_idx_size, varargin_1);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  b_wls_solve_sys(b_wls, diff_idx_data, diff_idx_size, vdops);
  //  Rearrange vdops using wls.V as work space
  wls_eval_ops(b_wls, vdops, fs, results);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_resize  Reinitialize the buffers of WlsObject
static void wls_resize(WlsObject *b_wls, ::coder::SizeType dim,
                       ::coder::SizeType nstpnts, ::coder::SizeType degree,
                       ::coder::SizeType order)
{
  ::coder::SizeType b_degree;
  ::coder::SizeType ncols;
  ::coder::SizeType nrows;
  ::coder::SizeType stride;
  ::coder::SizeType x;
  b_wls->degree = degree;
  b_wls->order = order;
  //  make stride a multiple of four
  stride = ((nstpnts + 3) / 4) << 2;
  b_wls->stride = stride;
  if (order == 0) {
    nrows = stride;
  } else if (order == 1) {
    nrows = (dim + 1) * stride;
  } else {
    ::coder::SizeType nrblks;
    switch (dim) {
    case 1:
      nrblks = order + 1;
      break;
    case 2:
      nrblks = (order + 1) * (order + 2) / 2;
      break;
    default:
      nrblks = (order + 1) * (order + 2) * (order + 3) / 6;
      break;
    }
    nrows = nrblks * stride;
  }
  b_wls->us.set_size(stride, dim);
  b_wls->rweights.set_size(stride);
  b_wls->nstpnts = nstpnts;
  //  determine number of columns and allocate V and QR
  switch (dim) {
  case 1:
    if (degree < 0) {
      b_degree = -degree;
    } else {
      b_degree = degree;
    }
    ncols = b_degree + 1;
    break;
  case 2:
    if (degree > 0) {
      ncols = (degree + 1) * (degree + 2) / 2;
    } else {
      ncols = (1 - degree) * (1 - degree);
    }
    break;
  default:
    if (degree > 0) {
      ncols = (degree + 1) * (degree + 2) * (degree + 3) / 6;
    } else {
      ncols = (1 - degree) * (1 - degree) * (1 - degree);
    }
    break;
  }
  b_wls->hs_inv.set_size(1, dim);
  b_wls->jpvt.set_size(ncols);
  b_wls->V.set_size(ncols, nrows);
  b_degree = (ncols - b_wls->interp0) + 1;
  b_wls->QR.set_size(b_degree, nrows);
  b_wls->rank = 0;
  //  work space
  x = ncols << 2;
  b_degree = ncols + 1;
  if (nrows >= b_degree) {
    b_degree = nrows;
  }
  if (x < 4160) {
    x = 4160;
  }
  b_wls->work.set_size((b_degree << 5) + x);
}

// wls_solve_sys - Solve Vandermonde system to obtain the operator
static void wls_solve_sys(WlsObject *b_wls, const int8_T diff_idx_data[],
                          ::coder::SizeType diff_idx_size,
                          ::coder::array<real_T, 2U> &vdops)
{
  ::coder::SizeType i;
  ::coder::SizeType k;
  ::coder::SizeType loop_ub;
  ::coder::SizeType nRhs;
  ::coder::SizeType nnzops;
  ::coder::SizeType nrows;
  ::coder::SizeType nrows_vdops;
  boolean_T exitg1;
  boolean_T p;
  nRhs = b_wls->rhs.size(0) - 1;
  p = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k <= diff_idx_size - 1)) {
    if (diff_idx_data[k] == 0) {
      p = false;
      exitg1 = true;
    } else {
      k++;
    }
  }
  if (!p) {
    //  Compress wls.rhs
    nnzops = 0;
    for (::coder::SizeType j{0}; j <= nRhs; j++) {
      nnzops++;
    }
  } else {
    nnzops = b_wls->rhs.size(0);
  }
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    k = b_wls->QR.size(1);
    for (i = 0; i < k; i++) {
      loop_ub = b_wls->QR.size(0);
      for (::coder::SizeType i1{0}; i1 < loop_ub; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  }
  k = b_wls->ncols;
  loop_ub = b_wls->nrows;
  if (k >= loop_ub) {
    nrows_vdops = k;
  } else {
    nrows_vdops = loop_ub;
  }
  vdops.set_size(nrows_vdops, nRhs + 1);
  //  Transpose the operator for row-major
  i = nrows_vdops - b_wls->interp0;
  for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (::coder::SizeType j{0}; j <= nRhs; j++) {
      vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (k = 0; k <= nRhs; k++) {
      for (::coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    for (::coder::SizeType j{0}; j <= nRhs; j++) {
      real_T s;
      s = 0.0;
      i = b_wls->nstpnts;
      for (::coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      p = diff_idx_size == 1;
      if (p) {
        p = true;
        k = 0;
        exitg1 = false;
        while ((!exitg1) && (k <= diff_idx_size - 1)) {
          if (diff_idx_data[0] != 1) {
            p = false;
            exitg1 = true;
          } else {
            k++;
          }
        }
      }
      vdops[j] = static_cast<real_T>(p) - s;
    }
  }
}

// wls_solve_sys - Solve Vandermonde system to obtain the operator
static void wls_solve_sys(WlsObject *b_wls, const int8_T diff_idx_data[],
                          const ::coder::SizeType diff_idx_size[2],
                          ::coder::array<real_T, 2U> &vdops)
{
  ::coder::SizeType b_k;
  ::coder::SizeType i;
  ::coder::SizeType i1;
  ::coder::SizeType k;
  ::coder::SizeType loop_ub;
  ::coder::SizeType nRhs;
  ::coder::SizeType nnzops;
  ::coder::SizeType nrows;
  ::coder::SizeType nrows_vdops;
  ::coder::SizeType row;
  int8_T tmp_data[9];
  int8_T diff_idx_idx_0;
  boolean_T compressed;
  boolean_T exitg1;
  boolean_T p;
  nRhs = b_wls->rhs.size(0);
  compressed = false;
  diff_idx_idx_0 = static_cast<int8_T>(diff_idx_size[0] * diff_idx_size[1]);
  i = 0;
  i1 = 0;
  for (k = 0; k < diff_idx_idx_0; k++) {
    tmp_data[k] = diff_idx_data[i1 + diff_idx_size[1] * i];
    i++;
    if (i > diff_idx_size[0] - 1) {
      i = 0;
      i1++;
    }
  }
  p = true;
  b_k = 0;
  exitg1 = false;
  while ((!exitg1) && (b_k <= diff_idx_idx_0 - 1)) {
    if (tmp_data[b_k] == 0) {
      p = false;
      exitg1 = true;
    } else {
      b_k++;
    }
  }
  if (!p) {
    //  Compress wls.rhs
    nnzops = 0;
    row = 1;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      p = false;
      b_k = 0;
      exitg1 = false;
      while ((!exitg1) && (b_k <= diff_idx_size[1] - 1)) {
        if (diff_idx_data[b_k + diff_idx_size[1] * (row - 1)] != 0) {
          p = true;
          exitg1 = true;
        } else {
          b_k++;
        }
      }
      if (p) {
        nnzops++;
        if (compressed) {
          i = b_wls->rhs.size(1);
          for (b_k = 0; b_k < i; b_k++) {
            b_wls->rhs[b_k + b_wls->rhs.size(1) * (nnzops - 1)] =
                b_wls->rhs[b_k + b_wls->rhs.size(1) * j];
          }
        }
      } else {
        compressed = true;
      }
      if (row < diff_idx_size[0]) {
        row++;
      } else {
        row = 1;
      }
    }
  } else {
    nnzops = b_wls->rhs.size(0);
  }
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      b_k = b_wls->QR.size(0);
      for (i1 = 0; i1 < b_k; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  }
  k = b_wls->ncols;
  b_k = b_wls->nrows;
  if (k >= b_k) {
    nrows_vdops = k;
  } else {
    nrows_vdops = b_k;
  }
  vdops.set_size(nrows_vdops, nRhs);
  if (compressed) {
    vdops.set_size(nrows_vdops, nRhs);
    loop_ub = nRhs * nrows_vdops;
    for (i = 0; i < loop_ub; i++) {
      vdops[i] = 0.0;
    }
    //  Compress wls.rhs
    nnzops = -1;
    row = 1;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      p = false;
      b_k = 0;
      exitg1 = false;
      while ((!exitg1) && (b_k <= diff_idx_size[1] - 1)) {
        if (diff_idx_data[b_k + diff_idx_size[1] * (row - 1)] != 0) {
          p = true;
          exitg1 = true;
        } else {
          b_k++;
        }
      }
      if (p) {
        nnzops++;
        i = nrows_vdops - b_wls->interp0;
        for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
          vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
              b_wls->rhs[b_i + b_wls->rhs.size(1) * nnzops];
        }
      }
      if (row < diff_idx_size[0]) {
        row++;
      } else {
        row = 1;
      }
    }
  } else {
    //  Transpose the operator for row-major
    i = nrows_vdops - b_wls->interp0;
    for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
      for (::coder::SizeType j{0}; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (b_k = 0; b_k < nRhs; b_k++) {
      for (::coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[b_k + vdops.size(1) * iRow] =
            vdops[b_k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      real_T s;
      ::coder::SizeType totalw;
      s = 0.0;
      i = b_wls->nstpnts;
      for (::coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      p = false;
      if ((diff_idx_size[0] == 1) && (diff_idx_size[1] == 1)) {
        p = true;
      }
      if (p) {
        p = true;
        b_k = 0;
        exitg1 = false;
        while ((!exitg1) && (b_k <= diff_idx_size[0] - 1)) {
          boolean_T exitg2;
          k = 0;
          exitg2 = false;
          while ((!exitg2) && (k <= diff_idx_size[1] - 1)) {
            if (diff_idx_data[0] != 1) {
              p = false;
              exitg2 = true;
            } else {
              k++;
            }
          }
          if (!p) {
            exitg1 = true;
          } else {
            b_k++;
          }
        }
      }
      if (p) {
        totalw = 1;
      } else if (diff_idx_data[0] != 1) {
        totalw = 0;
      } else {
        totalw = b_wls->nevpnts;
        //  Unit weights summed together
      }
      vdops[j] = static_cast<real_T>(totalw) - s;
    }
  }
  if ((diff_idx_size[0] > 1) && (diff_idx_size[1] > 1)) {
    ::coder::SizeType ndims;
    ndims = b_wls->us.size(1);
    b_wls->V.set_size(vdops.size(0), vdops.size(1));
    loop_ub = vdops.size(1) * vdops.size(0);
    for (i = 0; i < loop_ub; i++) {
      b_wls->V[i] = vdops[i];
    }
    k = vdops.size(1) / b_wls->us.size(1);
    vdops.set_size(b_wls->nstpnts * b_wls->us.size(1), k);
    loop_ub = k * (b_wls->nstpnts * b_wls->us.size(1));
    for (i = 0; i < loop_ub; i++) {
      vdops[i] = 0.0;
    }
    for (::coder::SizeType b_i{0}; b_i < k; b_i++) {
      i = b_wls->nstpnts;
      for (::coder::SizeType b_p{0}; b_p < i; b_p++) {
        for (::coder::SizeType j{0}; j < ndims; j++) {
          vdops[b_i + vdops.size(1) * (b_p * ndims + j)] =
              b_wls->V[(static_cast<::coder::SizeType>(
                            static_cast<real_T>(ndims) *
                            ((static_cast<real_T>(b_i) + 1.0) - 1.0)) +
                        j) +
                       b_wls->V.size(1) * b_p];
        }
      }
    }
  }
}

// wls_solve_sys - Solve Vandermonde system to obtain the operator
static void wls_solve_sys(WlsObject *b_wls,
                          const ::coder::array<real_T, 2U> &ws,
                          ::coder::array<real_T, 2U> &vdops)
{
  ::coder::SizeType b_loop_ub;
  ::coder::SizeType i;
  ::coder::SizeType loop_ub;
  ::coder::SizeType nRhs;
  ::coder::SizeType nrows;
  ::coder::SizeType nrows_vdops;
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      b_loop_ub = b_wls->QR.size(0);
      for (::coder::SizeType i1{0}; i1 < b_loop_ub; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  loop_ub = b_wls->ncols;
  b_loop_ub = b_wls->nrows;
  if (loop_ub >= b_loop_ub) {
    nrows_vdops = loop_ub;
  } else {
    nrows_vdops = b_loop_ub;
  }
  vdops.set_size(nrows_vdops, nRhs);
  //  Transpose the operator for row-major
  i = nrows_vdops - b_wls->interp0;
  for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (::coder::SizeType k{0}; k < nRhs; k++) {
      for (::coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    ::coder::SizeType iWeight;
    //  In interp0 mode, set the first entry based on partition of unity
    iWeight = 1;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      real_T s;
      real_T totalw;
      s = 0.0;
      i = b_wls->nstpnts;
      for (::coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      if (coder::isequal(ws)) {
        totalw = 0.0;
      } else if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
        totalw = b_wls->nevpnts;
        //  Unit weights summed together
      } else {
        ::coder::SizeType iEval_ws;
        //  All weights summed together
        totalw = 0.0;
        iEval_ws = 0;
        i = b_wls->nevpnts;
        for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
          totalw += ws[(iWeight + ws.size(1) * iEval_ws) - 1];
          iEval_ws += ws.size(0) > 1;
        }
        iWeight += iWeight < ws.size(1);
      }
      vdops[0] = totalw - s;
    }
  }
}

// wls_solve_sys - Solve Vandermonde system to obtain the operator
static void wls_solve_sys(WlsObject *b_wls, ::coder::array<real_T, 2U> &vdops)
{
  ::coder::SizeType b_loop_ub;
  ::coder::SizeType i;
  ::coder::SizeType k;
  ::coder::SizeType loop_ub;
  ::coder::SizeType nRhs;
  ::coder::SizeType ndims;
  ::coder::SizeType nnzops;
  ::coder::SizeType nrows;
  ::coder::SizeType nrows_vdops;
  ::coder::SizeType row;
  int8_T x[3];
  boolean_T compressed;
  boolean_T exitg1;
  boolean_T y;
  nRhs = b_wls->rhs.size(0);
  compressed = false;
  //  Compress wls.rhs
  nnzops = 0;
  row = 1;
  for (::coder::SizeType j{0}; j < nRhs; j++) {
    k = 3 * (row - 1);
    x[0] = iv[k];
    x[1] = iv[k + 1];
    x[2] = iv[k + 2];
    y = false;
    k = 0;
    exitg1 = false;
    while ((!exitg1) && (k < 3)) {
      if (x[k] != 0) {
        y = true;
        exitg1 = true;
      } else {
        k++;
      }
    }
    if (y) {
      nnzops++;
      if (compressed) {
        i = b_wls->rhs.size(1);
        for (k = 0; k < i; k++) {
          b_wls->rhs[k + b_wls->rhs.size(1) * (nnzops - 1)] =
              b_wls->rhs[k + b_wls->rhs.size(1) * j];
        }
      }
    } else {
      compressed = true;
    }
    if (row < 9) {
      row++;
    } else {
      row = 1;
    }
  }
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      b_loop_ub = b_wls->QR.size(0);
      for (k = 0; k < b_loop_ub; k++) {
        b_wls->QRt[k + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * k];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  }
  k = b_wls->ncols;
  b_loop_ub = b_wls->nrows;
  if (k >= b_loop_ub) {
    nrows_vdops = k;
  } else {
    nrows_vdops = b_loop_ub;
  }
  vdops.set_size(nrows_vdops, nRhs);
  if (compressed) {
    vdops.set_size(nrows_vdops, nRhs);
    loop_ub = nRhs * nrows_vdops;
    for (i = 0; i < loop_ub; i++) {
      vdops[i] = 0.0;
    }
    //  Compress wls.rhs
    nnzops = -1;
    row = 1;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      k = 3 * (row - 1);
      x[0] = iv[k];
      x[1] = iv[k + 1];
      x[2] = iv[k + 2];
      y = false;
      k = 0;
      exitg1 = false;
      while ((!exitg1) && (k < 3)) {
        if (x[k] != 0) {
          y = true;
          exitg1 = true;
        } else {
          k++;
        }
      }
      if (y) {
        nnzops++;
        i = nrows_vdops - b_wls->interp0;
        for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
          vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
              b_wls->rhs[b_i + b_wls->rhs.size(1) * nnzops];
        }
      }
      if (row < 9) {
        row++;
      } else {
        row = 1;
      }
    }
  } else {
    //  Transpose the operator for row-major
    i = nrows_vdops - b_wls->interp0;
    for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
      for (::coder::SizeType j{0}; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (k = 0; k < nRhs; k++) {
      for (::coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      i = b_wls->nstpnts;
      for (::coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      vdops[j] = 0.0 - s;
    }
  }
  ndims = b_wls->us.size(1);
  b_wls->V.set_size(vdops.size(0), vdops.size(1));
  loop_ub = vdops.size(1) * vdops.size(0);
  for (i = 0; i < loop_ub; i++) {
    b_wls->V[i] = vdops[i];
  }
  k = vdops.size(1) / b_wls->us.size(1);
  vdops.set_size(b_wls->nstpnts * b_wls->us.size(1), k);
  loop_ub = k * (b_wls->nstpnts * b_wls->us.size(1));
  for (i = 0; i < loop_ub; i++) {
    vdops[i] = 0.0;
  }
  for (::coder::SizeType b_i{0}; b_i < k; b_i++) {
    i = b_wls->nstpnts;
    for (::coder::SizeType p{0}; p < i; p++) {
      for (::coder::SizeType j{0}; j < ndims; j++) {
        vdops[b_i + vdops.size(1) * (p * ndims + j)] =
            b_wls->V[(static_cast<::coder::SizeType>(
                          static_cast<real_T>(ndims) *
                          ((static_cast<real_T>(b_i) + 1.0) - 1.0)) +
                      j) +
                     b_wls->V.size(1) * p];
      }
    }
  }
}

// wls_solve_sys - Solve Vandermonde system to obtain the operator
static void wls_solve_sys(WlsObject *b_wls, const int8_T diff_idx_data[],
                          const ::coder::SizeType diff_idx_size[2],
                          const ::coder::array<real_T, 1U> &ws,
                          ::coder::array<real_T, 2U> &vdops)
{
  ::coder::SizeType b_loop_ub;
  ::coder::SizeType diff_idx_idx_0_tmp;
  ::coder::SizeType i;
  ::coder::SizeType i1;
  ::coder::SizeType k;
  ::coder::SizeType loop_ub;
  ::coder::SizeType nRhs;
  ::coder::SizeType nnzops;
  ::coder::SizeType nrows;
  ::coder::SizeType nrows_vdops;
  ::coder::SizeType row;
  int8_T tmp_data[9];
  int8_T diff_idx_idx_0;
  boolean_T compressed;
  boolean_T exitg1;
  boolean_T y;
  nRhs = b_wls->rhs.size(0);
  compressed = false;
  diff_idx_idx_0_tmp = diff_idx_size[0] * diff_idx_size[1];
  diff_idx_idx_0 = static_cast<int8_T>(diff_idx_idx_0_tmp);
  i = 0;
  i1 = 0;
  for (k = 0; k < diff_idx_idx_0; k++) {
    tmp_data[k] = diff_idx_data[i1 + diff_idx_size[1] * i];
    i++;
    if (i > diff_idx_size[0] - 1) {
      i = 0;
      i1++;
    }
  }
  y = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k <= static_cast<int8_T>(diff_idx_idx_0_tmp) - 1)) {
    if (tmp_data[k] == 0) {
      y = false;
      exitg1 = true;
    } else {
      k++;
    }
  }
  if (!y) {
    //  Compress wls.rhs
    nnzops = 0;
    row = 1;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      y = false;
      k = 0;
      exitg1 = false;
      while ((!exitg1) && (k <= diff_idx_size[1] - 1)) {
        if (diff_idx_data[k + diff_idx_size[1] * (row - 1)] != 0) {
          y = true;
          exitg1 = true;
        } else {
          k++;
        }
      }
      if (y) {
        nnzops++;
        if (compressed) {
          i = b_wls->rhs.size(1);
          for (k = 0; k < i; k++) {
            b_wls->rhs[k + b_wls->rhs.size(1) * (nnzops - 1)] =
                b_wls->rhs[k + b_wls->rhs.size(1) * j];
          }
        }
      } else {
        compressed = true;
      }
      if (row < diff_idx_size[0]) {
        row++;
      } else {
        row = 1;
      }
    }
  } else {
    nnzops = b_wls->rhs.size(0);
  }
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      b_loop_ub = b_wls->QR.size(0);
      for (i1 = 0; i1 < b_loop_ub; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  }
  b_loop_ub = b_wls->ncols;
  k = b_wls->nrows;
  if (b_loop_ub >= k) {
    nrows_vdops = b_loop_ub;
  } else {
    nrows_vdops = k;
  }
  vdops.set_size(nrows_vdops, nRhs);
  if (compressed) {
    vdops.set_size(nrows_vdops, nRhs);
    loop_ub = nRhs * nrows_vdops;
    for (i = 0; i < loop_ub; i++) {
      vdops[i] = 0.0;
    }
    //  Compress wls.rhs
    nnzops = -1;
    row = 1;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      y = false;
      k = 0;
      exitg1 = false;
      while ((!exitg1) && (k <= diff_idx_size[1] - 1)) {
        if (diff_idx_data[k + diff_idx_size[1] * (row - 1)] != 0) {
          y = true;
          exitg1 = true;
        } else {
          k++;
        }
      }
      if (y) {
        nnzops++;
        i = nrows_vdops - b_wls->interp0;
        for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
          vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
              b_wls->rhs[b_i + b_wls->rhs.size(1) * nnzops];
        }
      }
      if (row < diff_idx_size[0]) {
        row++;
      } else {
        row = 1;
      }
    }
  } else {
    //  Transpose the operator for row-major
    i = nrows_vdops - b_wls->interp0;
    for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
      for (::coder::SizeType j{0}; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (k = 0; k < nRhs; k++) {
      for (::coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    boolean_T b;
    boolean_T b1;
    //  In interp0 mode, set the first entry based on partition of unity
    b = true;
    b1 = (diff_idx_size[1] <= 0) || (diff_idx_size[0] <= 0);
    i = 0;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      real_T s;
      real_T totalw;
      if (b1 || (j >= diff_idx_idx_0_tmp)) {
        i = 0;
        b = true;
      } else if (b) {
        b = false;
        i = j % diff_idx_size[0] * diff_idx_size[1] + j / diff_idx_size[0];
      } else if (i > MAX_int32_T - diff_idx_size[1]) {
        i = j % diff_idx_size[0] * diff_idx_size[1] + j / diff_idx_size[0];
      } else {
        i += diff_idx_size[1];
        if (i > diff_idx_idx_0_tmp - 1) {
          i = (i - diff_idx_idx_0_tmp) + 1;
        }
      }
      s = 0.0;
      i1 = b_wls->nstpnts;
      for (::coder::SizeType b_i{2}; b_i <= i1; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      if ((diff_idx_data[i] != 1) || coder::isequal(ws)) {
        totalw = 0.0;
      } else {
        ::coder::SizeType iEval_ws;
        //  All weights summed together
        totalw = 0.0;
        iEval_ws = 0;
        i1 = b_wls->nevpnts;
        for (::coder::SizeType b_i{0}; b_i < i1; b_i++) {
          totalw += ws[iEval_ws];
          iEval_ws += ws.size(0) > 1;
        }
      }
      vdops[j] = totalw - s;
    }
  }
  if ((diff_idx_size[0] > 1) && (diff_idx_size[1] > 1)) {
    ::coder::SizeType ndims;
    ndims = b_wls->us.size(1);
    b_wls->V.set_size(vdops.size(0), vdops.size(1));
    loop_ub = vdops.size(1) * vdops.size(0);
    for (i = 0; i < loop_ub; i++) {
      b_wls->V[i] = vdops[i];
    }
    k = vdops.size(1) / b_wls->us.size(1);
    vdops.set_size(b_wls->nstpnts * b_wls->us.size(1), k);
    loop_ub = k * (b_wls->nstpnts * b_wls->us.size(1));
    for (i = 0; i < loop_ub; i++) {
      vdops[i] = 0.0;
    }
    for (::coder::SizeType b_i{0}; b_i < k; b_i++) {
      i = b_wls->nstpnts;
      for (::coder::SizeType p{0}; p < i; p++) {
        for (::coder::SizeType j{0}; j < ndims; j++) {
          vdops[b_i + vdops.size(1) * (p * ndims + j)] =
              b_wls->V[(static_cast<::coder::SizeType>(
                            static_cast<real_T>(ndims) *
                            ((static_cast<real_T>(b_i) + 1.0) - 1.0)) +
                        j) +
                       b_wls->V.size(1) * p];
        }
      }
    }
  }
}

// wls_solve_sys - Solve Vandermonde system to obtain the operator
static void wls_solve_sys(WlsObject *b_wls, const int8_T diff_idx_data[],
                          const ::coder::SizeType diff_idx_size[2],
                          const ::coder::array<real_T, 2U> &ws,
                          ::coder::array<real_T, 2U> &vdops)
{
  ::coder::SizeType b_loop_ub;
  ::coder::SizeType diff_idx_idx_0_tmp;
  ::coder::SizeType i;
  ::coder::SizeType i1;
  ::coder::SizeType k;
  ::coder::SizeType loop_ub;
  ::coder::SizeType nRhs;
  ::coder::SizeType nnzops;
  ::coder::SizeType nrows;
  ::coder::SizeType nrows_vdops;
  ::coder::SizeType row;
  int8_T tmp_data[9];
  int8_T diff_idx_idx_0;
  boolean_T compressed;
  boolean_T exitg1;
  boolean_T y;
  nRhs = b_wls->rhs.size(0);
  compressed = false;
  diff_idx_idx_0_tmp = diff_idx_size[0] * diff_idx_size[1];
  diff_idx_idx_0 = static_cast<int8_T>(diff_idx_idx_0_tmp);
  i = 0;
  i1 = 0;
  for (k = 0; k < diff_idx_idx_0; k++) {
    tmp_data[k] = diff_idx_data[i1 + diff_idx_size[1] * i];
    i++;
    if (i > diff_idx_size[0] - 1) {
      i = 0;
      i1++;
    }
  }
  y = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k <= static_cast<int8_T>(diff_idx_idx_0_tmp) - 1)) {
    if (tmp_data[k] == 0) {
      y = false;
      exitg1 = true;
    } else {
      k++;
    }
  }
  if (!y) {
    //  Compress wls.rhs
    nnzops = 0;
    row = 1;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      y = false;
      k = 0;
      exitg1 = false;
      while ((!exitg1) && (k <= diff_idx_size[1] - 1)) {
        if (diff_idx_data[k + diff_idx_size[1] * (row - 1)] != 0) {
          y = true;
          exitg1 = true;
        } else {
          k++;
        }
      }
      if (y) {
        nnzops++;
        if (compressed) {
          i = b_wls->rhs.size(1);
          for (k = 0; k < i; k++) {
            b_wls->rhs[k + b_wls->rhs.size(1) * (nnzops - 1)] =
                b_wls->rhs[k + b_wls->rhs.size(1) * j];
          }
        }
      } else {
        compressed = true;
      }
      if (row < diff_idx_size[0]) {
        row++;
      } else {
        row = 1;
      }
    }
  } else {
    nnzops = b_wls->rhs.size(0);
  }
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      b_loop_ub = b_wls->QR.size(0);
      for (i1 = 0; i1 < b_loop_ub; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, nnzops);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nnzops,
                b_wls->work);
  }
  b_loop_ub = b_wls->ncols;
  k = b_wls->nrows;
  if (b_loop_ub >= k) {
    nrows_vdops = b_loop_ub;
  } else {
    nrows_vdops = k;
  }
  vdops.set_size(nrows_vdops, nRhs);
  if (compressed) {
    vdops.set_size(nrows_vdops, nRhs);
    loop_ub = nRhs * nrows_vdops;
    for (i = 0; i < loop_ub; i++) {
      vdops[i] = 0.0;
    }
    //  Compress wls.rhs
    nnzops = -1;
    row = 1;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      y = false;
      k = 0;
      exitg1 = false;
      while ((!exitg1) && (k <= diff_idx_size[1] - 1)) {
        if (diff_idx_data[k + diff_idx_size[1] * (row - 1)] != 0) {
          y = true;
          exitg1 = true;
        } else {
          k++;
        }
      }
      if (y) {
        nnzops++;
        i = nrows_vdops - b_wls->interp0;
        for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
          vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
              b_wls->rhs[b_i + b_wls->rhs.size(1) * nnzops];
        }
      }
      if (row < diff_idx_size[0]) {
        row++;
      } else {
        row = 1;
      }
    }
  } else {
    //  Transpose the operator for row-major
    i = nrows_vdops - b_wls->interp0;
    for (::coder::SizeType b_i{0}; b_i < i; b_i++) {
      for (::coder::SizeType j{0}; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (k = 0; k < nRhs; k++) {
      for (::coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    ::coder::SizeType iWeight;
    boolean_T b;
    boolean_T b1;
    //  In interp0 mode, set the first entry based on partition of unity
    iWeight = 1;
    b = true;
    b1 = (diff_idx_size[1] <= 0) || (diff_idx_size[0] <= 0);
    i = 0;
    for (::coder::SizeType j{0}; j < nRhs; j++) {
      real_T s;
      real_T totalw;
      if (b1 || (j >= diff_idx_idx_0_tmp)) {
        i = 0;
        b = true;
      } else if (b) {
        b = false;
        i = j % diff_idx_size[0] * diff_idx_size[1] + j / diff_idx_size[0];
      } else if (i > MAX_int32_T - diff_idx_size[1]) {
        i = j % diff_idx_size[0] * diff_idx_size[1] + j / diff_idx_size[0];
      } else {
        i += diff_idx_size[1];
        if (i > diff_idx_idx_0_tmp - 1) {
          i = (i - diff_idx_idx_0_tmp) + 1;
        }
      }
      s = 0.0;
      i1 = b_wls->nstpnts;
      for (::coder::SizeType b_i{2}; b_i <= i1; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      if ((diff_idx_data[i] != 1) || coder::isequal(ws)) {
        totalw = 0.0;
      } else if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
        totalw = b_wls->nevpnts;
        //  Unit weights summed together
      } else {
        ::coder::SizeType iEval_ws;
        //  All weights summed together
        totalw = 0.0;
        iEval_ws = 0;
        i1 = b_wls->nevpnts;
        for (::coder::SizeType b_i{0}; b_i < i1; b_i++) {
          totalw += ws[(iWeight + ws.size(1) * iEval_ws) - 1];
          iEval_ws += ws.size(0) > 1;
        }
        iWeight += iWeight < ws.size(1);
      }
      vdops[j] = totalw - s;
    }
  }
  if ((diff_idx_size[0] > 1) && (diff_idx_size[1] > 1)) {
    ::coder::SizeType ndims;
    ndims = b_wls->us.size(1);
    b_wls->V.set_size(vdops.size(0), vdops.size(1));
    loop_ub = vdops.size(1) * vdops.size(0);
    for (i = 0; i < loop_ub; i++) {
      b_wls->V[i] = vdops[i];
    }
    k = vdops.size(1) / b_wls->us.size(1);
    vdops.set_size(b_wls->nstpnts * b_wls->us.size(1), k);
    loop_ub = k * (b_wls->nstpnts * b_wls->us.size(1));
    for (i = 0; i < loop_ub; i++) {
      vdops[i] = 0.0;
    }
    for (::coder::SizeType b_i{0}; b_i < k; b_i++) {
      i = b_wls->nstpnts;
      for (::coder::SizeType p{0}; p < i; p++) {
        for (::coder::SizeType j{0}; j < ndims; j++) {
          vdops[b_i + vdops.size(1) * (p * ndims + j)] =
              b_wls->V[(static_cast<::coder::SizeType>(
                            static_cast<real_T>(ndims) *
                            ((static_cast<real_T>(b_i) + 1.0) - 1.0)) +
                        j) +
                       b_wls->V.size(1) * p];
        }
      }
    }
  }
}

// wls_update_rhs - Update the RHS vectors
static void wls_update_rhs(WlsObject *b_wls, const int8_T diff_idx_data[],
                           ::coder::SizeType diff_idx_size)
{
  ::coder::SizeType k;
  ::coder::SizeType nevpnts;
  ::coder::SizeType nrows_vdops;
  ::coder::SizeType u1;
  boolean_T exitg1;
  boolean_T y;
  nevpnts = b_wls->nevpnts;
  k = b_wls->ncols;
  u1 = b_wls->nrows;
  if (k >= u1) {
    nrows_vdops = k;
  } else {
    nrows_vdops = u1;
  }
  y = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k <= diff_idx_size - 1)) {
    if (diff_idx_data[k] == 0) {
      y = false;
      exitg1 = true;
    } else {
      k++;
    }
  }
  if (y) {
    k = b_wls->nevpnts * diff_idx_size;
    b_wls->rhs.set_size(k, nrows_vdops - b_wls->interp0);
  } else {
    k = b_wls->nevpnts * diff_idx_size;
    u1 = nrows_vdops - b_wls->interp0;
    b_wls->rhs.set_size(k, u1);
    u1 *= k;
    for (k = 0; k < u1; k++) {
      b_wls->rhs[k] = 0.0;
    }
  }
  //  Summing up rows in the differential operator
  for (::coder::SizeType iOp{0}; iOp < diff_idx_size; iOp++) {
    ::coder::SizeType offset;
    //  Skip padded zeros in the differential operator
    offset = (diff_idx_data[iOp] - 1) * b_wls->us.size(0);
    //  Sum up monomials weighted by weights for each component
    k = b_wls->ncols - b_wls->interp0;
    for (::coder::SizeType iMonomial{0}; iMonomial < k; iMonomial++) {
      ::coder::SizeType j;
      j = b_wls->jpvt[iMonomial] + b_wls->interp0;
      //  Do not sum if nargin<3
      for (::coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
        b_wls->rhs[iMonomial +
                   b_wls->rhs.size(1) * (iEval * diff_idx_size + iOp)] =
            b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
      }
    }
  }
}

// wls_update_rhs - Update the RHS vectors
static void wls_update_rhs(WlsObject *b_wls, const int8_T diff_idx_data[],
                           ::coder::SizeType diff_idx_size,
                           const ::coder::array<real_T, 1U> &ws)
{
  ::coder::SizeType nevpnts;
  ::coder::SizeType u0;
  ::coder::SizeType u1;
  nevpnts = b_wls->nevpnts - 1;
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(diff_idx_size, u0);
  u0 *= diff_idx_size;
  for (u1 = 0; u1 < u0; u1++) {
    b_wls->rhs[u1] = 0.0;
  }
  if (!coder::isequal(ws)) {
    //  Summing up rows in the differential operator
    for (::coder::SizeType iOp{0}; iOp < diff_idx_size; iOp++) {
      ::coder::SizeType offset;
      //  Skip padded zeros in the differential operator
      offset = (diff_idx_data[iOp] - 1) * b_wls->us.size(0);
      //  Sum up monomials weighted by weights for each component
      u1 = b_wls->ncols - b_wls->interp0;
      for (::coder::SizeType iMonomial{0}; iMonomial < u1; iMonomial++) {
        ::coder::SizeType j;
        j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
        if (ws.size(0) == 0) {
          for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
          }
        } else {
          ::coder::SizeType iEval_ws;
          iEval_ws = 0;
          for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                ws[iEval_ws] *
                    b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            iEval_ws += ws.size(0) > 1;
          }
        }
      }
    }
  }
}

// wls_update_rhs - Update the RHS vectors
static void wls_update_rhs(WlsObject *b_wls, ::coder::SizeType diff_idx_size)
{
  ::coder::SizeType u0;
  ::coder::SizeType u1;
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(diff_idx_size, u0);
  u0 *= diff_idx_size;
  for (u1 = 0; u1 < u0; u1++) {
    b_wls->rhs[u1] = 0.0;
  }
}

// wls_update_rhs - Update the RHS vectors
static void wls_update_rhs(WlsObject *b_wls, const int8_T diff_idx_data[],
                           const ::coder::SizeType diff_idx_size[2])
{
  ::coder::SizeType i;
  ::coder::SizeType k;
  ::coder::SizeType nDiff;
  ::coder::SizeType nevpnts;
  ::coder::SizeType nrows_vdops;
  ::coder::SizeType u1;
  int8_T tmp_data[9];
  int8_T diff_idx_idx_0;
  boolean_T exitg1;
  boolean_T y;
  nevpnts = b_wls->nevpnts;
  nDiff = diff_idx_size[0];
  k = b_wls->ncols;
  u1 = b_wls->nrows;
  if (k >= u1) {
    nrows_vdops = k;
  } else {
    nrows_vdops = u1;
  }
  diff_idx_idx_0 = static_cast<int8_T>(diff_idx_size[0] * diff_idx_size[1]);
  i = 0;
  k = 0;
  for (u1 = 0; u1 < diff_idx_idx_0; u1++) {
    tmp_data[u1] = diff_idx_data[k + diff_idx_size[1] * i];
    i++;
    if (i > diff_idx_size[0] - 1) {
      i = 0;
      k++;
    }
  }
  y = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k <= diff_idx_idx_0 - 1)) {
    if (tmp_data[k] == 0) {
      y = false;
      exitg1 = true;
    } else {
      k++;
    }
  }
  if (y) {
    k = b_wls->nevpnts * diff_idx_size[0];
    b_wls->rhs.set_size(k, nrows_vdops - b_wls->interp0);
  } else {
    k = b_wls->nevpnts * diff_idx_size[0];
    u1 = nrows_vdops - b_wls->interp0;
    b_wls->rhs.set_size(k, u1);
    u1 *= k;
    for (i = 0; i < u1; i++) {
      b_wls->rhs[i] = 0.0;
    }
  }
  //  Summing up rows in the differential operator
  i = diff_idx_size[1];
  for (::coder::SizeType jDiff{0}; jDiff < i; jDiff++) {
    //  Loop through the operators
    for (::coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      diff_idx_idx_0 = diff_idx_data[jDiff + diff_idx_size[1] * iOp];
      if (diff_idx_idx_0 > 0) {
        ::coder::SizeType offset;
        offset = (diff_idx_idx_0 - 1) * b_wls->us.size(0);
        //  Sum up monomials weighted by weights for each component
        k = b_wls->ncols - b_wls->interp0;
        for (::coder::SizeType iMonomial{0}; iMonomial < k; iMonomial++) {
          ::coder::SizeType j;
          j = b_wls->jpvt[iMonomial] + b_wls->interp0;
          //  Do not sum if nargin<3
          for (::coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * (iEval * nDiff + iOp)] =
                b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
          }
        }
      }
    }
  }
}

// wls_update_rhs - Update the RHS vectors
static void wls_update_rhs(WlsObject *b_wls, const int8_T diff_idx_data[],
                           const ::coder::SizeType diff_idx_size[2],
                           const ::coder::array<real_T, 1U> &ws)
{
  ::coder::SizeType nDiff;
  ::coder::SizeType nevpnts;
  nevpnts = b_wls->nevpnts - 1;
  nDiff = diff_idx_size[0];
  if (!coder::isequal(ws)) {
    ::coder::SizeType i;
    ::coder::SizeType stride;
    stride = b_wls->us.size(0);
    //  Summing up rows in the differential operator
    i = diff_idx_size[1];
    for (::coder::SizeType jDiff{0}; jDiff < i; jDiff++) {
      //  Loop through the operators
      for (::coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
        int8_T i1;
        //  Skip padded zeros in the differential operator
        i1 = diff_idx_data[jDiff + diff_idx_size[1] * iOp];
        if (i1 > 0) {
          ::coder::SizeType i2;
          ::coder::SizeType offset;
          offset = (i1 - 1) * stride;
          //  Sum up monomials weighted by weights for each component
          i2 = b_wls->ncols - b_wls->interp0;
          for (::coder::SizeType iMonomial{0}; iMonomial < i2; iMonomial++) {
            ::coder::SizeType iEval_ws;
            ::coder::SizeType j;
            j = b_wls->jpvt[iMonomial] + b_wls->interp0;
            iEval_ws = 0;
            for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[iEval_ws] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
              iEval_ws += ws.size(0) > 1;
            }
          }
        } else if (i1 < 0) {
          ::coder::SizeType i2;
          ::coder::SizeType offset;
          offset = (static_cast<int8_T>(-i1) - 1) * stride;
          //  Sum up monomials weighted by weights for each component
          i2 = b_wls->ncols - b_wls->interp0;
          for (::coder::SizeType iMonomial{0}; iMonomial < i2; iMonomial++) {
            ::coder::SizeType iEval_ws;
            ::coder::SizeType j;
            j = b_wls->jpvt[iMonomial] + b_wls->interp0;
            iEval_ws = 0;
            for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] -
                  ws[iEval_ws] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
              iEval_ws += ws.size(0) > 1;
            }
          }
        }
      }
    }
  }
}

// wls_update_rhs - Update the RHS vectors
static void wls_update_rhs(WlsObject *b_wls)
{
  ::coder::SizeType nevpnts;
  ::coder::SizeType ret;
  ::coder::SizeType stride;
  ::coder::SizeType u0;
  ::coder::SizeType u1;
  nevpnts = b_wls->nevpnts - 1;
  ret = b_wls->nevpnts * 9;
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(ret, u0);
  u0 *= ret;
  for (u1 = 0; u1 < u0; u1++) {
    b_wls->rhs[u1] = 0.0;
  }
  stride = b_wls->us.size(0);
  //  Summing up rows in the differential operator
  for (::coder::SizeType jDiff{0}; jDiff < 3; jDiff++) {
    //  Loop through the operators
    for (::coder::SizeType iOp{0}; iOp < 9; iOp++) {
      int8_T i;
      //  Skip padded zeros in the differential operator
      i = iv[jDiff + 3 * iOp];
      if (i > 0) {
        ::coder::SizeType offset;
        offset = (i - 1) * stride;
        //  Sum up monomials weighted by weights for each component
        u1 = b_wls->ncols - b_wls->interp0;
        for (::coder::SizeType iMonomial{0}; iMonomial < u1; iMonomial++) {
          ::coder::SizeType j;
          j = b_wls->jpvt[iMonomial] + b_wls->interp0;
          //  Do not sum if nargin<3
          for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * (iEval * 9 + iOp)] =
                b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
          }
        }
      } else if (i < 0) {
        ::coder::SizeType offset;
        offset = (-i - 1) * stride;
        //  Sum up monomials weighted by weights for each component
        u1 = b_wls->ncols - b_wls->interp0;
        for (::coder::SizeType iMonomial{0}; iMonomial < u1; iMonomial++) {
          ::coder::SizeType j;
          j = b_wls->jpvt[iMonomial] + b_wls->interp0;
          //  Do not sum if nargin<3
          for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * (iEval * 9 + iOp)] =
                -b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
          }
        }
      }
    }
  }
}

// wls_update_rhs - Update the RHS vectors
static void wls_update_rhs(WlsObject *b_wls, const int8_T diff_idx_data[],
                           const ::coder::SizeType diff_idx_size[2],
                           const ::coder::array<real_T, 2U> &ws)
{
  ::coder::SizeType nevpnts;
  ::coder::SizeType u0;
  ::coder::SizeType u1;
  nevpnts = b_wls->nevpnts - 1;
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(1, u0);
  for (u1 = 0; u1 < u0; u1++) {
    b_wls->rhs[u1] = 0.0;
  }
  if (!coder::isequal(ws)) {
    ::coder::SizeType iWeight;
    ::coder::SizeType lenWs;
    if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
      lenWs = 1;
    } else {
      lenWs = ws.size(1);
    }
    //  Summing up rows in the differential operator
    iWeight = 1;
    u1 = diff_idx_size[1];
    for (::coder::SizeType jDiff{0}; jDiff < u1; jDiff++) {
      ::coder::SizeType offset;
      //  Loop through the operators
      offset = (diff_idx_data[jDiff] - 1) * b_wls->us.size(0);
      //  Sum up monomials weighted by weights for each component
      u0 = b_wls->ncols - b_wls->interp0;
      for (::coder::SizeType iMonomial{0}; iMonomial < u0; iMonomial++) {
        ::coder::SizeType j;
        j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
        if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
          for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
            b_wls->rhs[iMonomial] =
                b_wls->rhs[iMonomial] +
                b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
          }
        } else {
          ::coder::SizeType iEval_ws;
          iEval_ws = 0;
          for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
            b_wls->rhs[iMonomial] =
                b_wls->rhs[iMonomial] +
                ws[(iWeight + ws.size(1) * iEval_ws) - 1] *
                    b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            iEval_ws += ws.size(0) > 1;
          }
        }
      }
      if (iWeight == lenWs) {
        iWeight = 1;
      } else {
        iWeight++;
      }
    }
  }
}

// wls_update_rhs - Update the RHS vectors
static void wls_update_rhs(WlsObject *b_wls,
                           const ::coder::array<real_T, 2U> &ws)
{
  ::coder::SizeType nevpnts;
  nevpnts = b_wls->nevpnts - 1;
  if (!coder::isequal(ws)) {
    ::coder::SizeType i;
    //  Summing up rows in the differential operator
    i = b_wls->ncols - b_wls->interp0;
    for (::coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      ::coder::SizeType j;
      j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
      if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
        for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial] =
              b_wls->rhs[iMonomial] + b_wls->V[iEval + b_wls->V.size(1) * j];
        }
      } else {
        ::coder::SizeType iEval_ws;
        iEval_ws = 0;
        for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial] = b_wls->rhs[iMonomial] +
                                  ws[ws.size(1) * iEval_ws] *
                                      b_wls->V[iEval + b_wls->V.size(1) * j];
          iEval_ws += ws.size(0) > 1;
        }
      }
    }
  }
}

// wls_update_rhs - Update the RHS vectors
static void wls_update_rhs(WlsObject *b_wls, const int8_T diff_idx_data[],
                           ::coder::SizeType diff_idx_size,
                           const ::coder::array<real_T, 2U> &ws)
{
  ::coder::SizeType nevpnts;
  ::coder::SizeType u0;
  ::coder::SizeType u1;
  nevpnts = b_wls->nevpnts - 1;
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(diff_idx_size, u0);
  u0 *= diff_idx_size;
  for (u1 = 0; u1 < u0; u1++) {
    b_wls->rhs[u1] = 0.0;
  }
  if (!coder::isequal(ws)) {
    ::coder::SizeType iWeight;
    ::coder::SizeType lenWs;
    if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
      lenWs = 1;
    } else {
      lenWs = ws.size(1);
    }
    //  Summing up rows in the differential operator
    iWeight = 1;
    //  Loop through the operators
    for (::coder::SizeType iOp{0}; iOp < diff_idx_size; iOp++) {
      ::coder::SizeType offset;
      //  Skip padded zeros in the differential operator
      offset = (diff_idx_data[iOp] - 1) * b_wls->us.size(0);
      //  Sum up monomials weighted by weights for each component
      u1 = b_wls->ncols - b_wls->interp0;
      for (::coder::SizeType iMonomial{0}; iMonomial < u1; iMonomial++) {
        ::coder::SizeType j;
        j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
        if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
          for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
          }
        } else {
          ::coder::SizeType iEval_ws;
          iEval_ws = 0;
          for (::coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                ws[(iWeight + ws.size(1) * iEval_ws) - 1] *
                    b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            iEval_ws += ws.size(0) > 1;
          }
        }
      }
      if (iWeight == lenWs) {
        iWeight = 1;
      } else {
        iWeight++;
      }
    }
  }
}

//  wls_var_cdr - Compute convection-diffusion-reaction operator at points
static void wls_var_cdr(WlsObject *b_wls,
                        const ::coder::array<real_T, 2U> &eval_pnts,
                        const ::coder::array<real_T, 2U> &ws_lap,
                        const ::coder::array<real_T, 2U> &ws_grad,
                        const ::coder::array<real_T, 2U> &fs,
                        ::coder::SizeType nevpnts,
                        ::coder::array<real_T, 2U> &vdops,
                        ::coder::array<real_T, 2U> &result)
{
  real_T timestamp;
  ::coder::SizeType grad_size[2];
  ::coder::SizeType lap_size[2];
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  ::coder::SizeType order;
  int8_T grad_data[3];
  int8_T lap_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size[1] = 1;
    grad_size[0] = 1;
    grad_data[0] = 2;
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    break;
  case 2:
    grad_size[1] = 2;
    grad_size[0] = 1;
    lap_size[1] = 2;
    lap_size[0] = 1;
    grad_data[0] = 2;
    lap_data[0] = 4;
    grad_data[1] = 3;
    lap_data[1] = 5;
    break;
  default:
    grad_size[1] = 3;
    grad_size[0] = 1;
    lap_size[1] = 3;
    lap_size[0] = 1;
    grad_data[0] = 2;
    lap_data[0] = 5;
    grad_data[1] = 3;
    lap_data[1] = 6;
    grad_data[2] = 4;
    lap_data[2] = 7;
    break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0) &&
      (!coder::isequal(ws_lap))) {
    order = -2;
  } else if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
             (!coder::isequal(ws_grad))) {
    order = 1;
  } else {
    order = 0;
  }
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, b_nevpnts, b_wls->degree, order, b_wls->hs_inv,
               b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0)) {
    wls_update_rhs(b_wls, lap_data, lap_size, ws_lap);
  } else {
    c_wls_update_rhs(b_wls);
  }
  if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
      (!coder::isequal(ws_grad))) {
    b_wls_update_rhs(b_wls, grad_data, grad_size, ws_grad);
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, vdops);
  //  Step 4: Optionally, evaluate the operator
  wls_eval_ops(b_wls, vdops, fs, result);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_cdr - Compute convection-diffusion-reaction operator at points
static void wls_var_cdr(WlsObject *b_wls,
                        const ::coder::array<real_T, 2U> &eval_pnts,
                        ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  nevpnts = eval_pnts.size(0);
  //  The operators are row vectors, so they will be summed up before solve
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  b_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->unimono,
               b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  c_wls_update_rhs(b_wls);
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, vdops);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_cdr - Compute convection-diffusion-reaction operator at points
static void wls_var_cdr(WlsObject *b_wls,
                        const ::coder::array<real_T, 2U> &eval_pnts,
                        const ::coder::array<real_T, 2U> &ws_lap,
                        const ::coder::array<real_T, 2U> &fs,
                        ::coder::SizeType nevpnts,
                        ::coder::array<real_T, 2U> &vdops,
                        ::coder::array<real_T, 2U> &result)
{
  real_T timestamp;
  ::coder::SizeType lap_size[2];
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  ::coder::SizeType order;
  int8_T lap_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    break;
  case 2:
    lap_size[1] = 2;
    lap_size[0] = 1;
    lap_data[0] = 4;
    lap_data[1] = 5;
    break;
  default:
    lap_size[1] = 3;
    lap_size[0] = 1;
    lap_data[0] = 5;
    lap_data[1] = 6;
    lap_data[2] = 7;
    break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0) &&
      (!coder::isequal(ws_lap))) {
    order = -2;
  } else {
    order = 0;
  }
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, b_nevpnts, b_wls->degree, order, b_wls->hs_inv,
               b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0)) {
    wls_update_rhs(b_wls, lap_data, lap_size, ws_lap);
  } else {
    c_wls_update_rhs(b_wls);
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, vdops);
  //  Step 4: Optionally, evaluate the operator
  wls_eval_ops(b_wls, vdops, fs, result);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_cdr - Compute convection-diffusion-reaction operator at points
static void wls_var_cdr(WlsObject *b_wls,
                        const ::coder::array<real_T, 2U> &eval_pnts,
                        const ::coder::array<real_T, 2U> &ws_lap,
                        const ::coder::array<real_T, 2U> &fs,
                        ::coder::array<real_T, 2U> &vdops,
                        ::coder::array<real_T, 2U> &result)
{
  real_T timestamp;
  ::coder::SizeType lap_size[2];
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  ::coder::SizeType order;
  int8_T lap_data[3];
  nevpnts = eval_pnts.size(0);
  //  The operators are row vectors, so they will be summed up before solve
  switch (b_wls->us.size(1)) {
  case 1:
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    break;
  case 2:
    lap_size[1] = 2;
    lap_size[0] = 1;
    lap_data[0] = 4;
    lap_data[1] = 5;
    break;
  default:
    lap_size[1] = 3;
    lap_size[0] = 1;
    lap_data[0] = 5;
    lap_data[1] = 6;
    lap_data[2] = 7;
    break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0) &&
      (!coder::isequal(ws_lap))) {
    order = -2;
  } else {
    order = 0;
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, order,
               b_wls->hs_inv, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0)) {
    wls_update_rhs(b_wls, lap_data, lap_size, ws_lap);
  } else {
    c_wls_update_rhs(b_wls);
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, vdops);
  //  Step 4: Optionally, evaluate the operator
  wls_eval_ops(b_wls, vdops, fs, result);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_cdr - Compute convection-diffusion-reaction operator at points
static void wls_var_cdr(WlsObject *b_wls,
                        const ::coder::array<real_T, 2U> &eval_pnts,
                        const ::coder::array<real_T, 2U> &ws_lap,
                        ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType lap_size[2];
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  ::coder::SizeType order;
  int8_T lap_data[3];
  nevpnts = eval_pnts.size(0);
  //  The operators are row vectors, so they will be summed up before solve
  switch (b_wls->us.size(1)) {
  case 1:
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    break;
  case 2:
    lap_size[1] = 2;
    lap_size[0] = 1;
    lap_data[0] = 4;
    lap_data[1] = 5;
    break;
  default:
    lap_size[1] = 3;
    lap_size[0] = 1;
    lap_data[0] = 5;
    lap_data[1] = 6;
    lap_data[2] = 7;
    break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0) &&
      (!coder::isequal(ws_lap))) {
    order = -2;
  } else {
    order = 0;
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, order,
               b_wls->hs_inv, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0)) {
    wls_update_rhs(b_wls, lap_data, lap_size, ws_lap);
  } else {
    c_wls_update_rhs(b_wls);
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, vdops);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_cdr - Compute convection-diffusion-reaction operator at points
static void wls_var_cdr(WlsObject *b_wls,
                        const ::coder::array<real_T, 2U> &eval_pnts,
                        const ::coder::array<real_T, 2U> &ws_lap,
                        const ::coder::array<real_T, 2U> &ws_grad,
                        const ::coder::array<real_T, 2U> &fs,
                        ::coder::array<real_T, 2U> &vdops,
                        ::coder::array<real_T, 2U> &result)
{
  real_T timestamp;
  ::coder::SizeType grad_size[2];
  ::coder::SizeType lap_size[2];
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  ::coder::SizeType order;
  int8_T grad_data[3];
  int8_T lap_data[3];
  nevpnts = eval_pnts.size(0);
  //  The operators are row vectors, so they will be summed up before solve
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size[1] = 1;
    grad_size[0] = 1;
    grad_data[0] = 2;
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    break;
  case 2:
    grad_size[1] = 2;
    grad_size[0] = 1;
    lap_size[1] = 2;
    lap_size[0] = 1;
    grad_data[0] = 2;
    lap_data[0] = 4;
    grad_data[1] = 3;
    lap_data[1] = 5;
    break;
  default:
    grad_size[1] = 3;
    grad_size[0] = 1;
    lap_size[1] = 3;
    lap_size[0] = 1;
    grad_data[0] = 2;
    lap_data[0] = 5;
    grad_data[1] = 3;
    lap_data[1] = 6;
    grad_data[2] = 4;
    lap_data[2] = 7;
    break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0) &&
      (!coder::isequal(ws_lap))) {
    order = -2;
  } else if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
             (!coder::isequal(ws_grad))) {
    order = 1;
  } else {
    order = 0;
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, order,
               b_wls->hs_inv, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0)) {
    wls_update_rhs(b_wls, lap_data, lap_size, ws_lap);
  } else {
    c_wls_update_rhs(b_wls);
  }
  if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
      (!coder::isequal(ws_grad))) {
    b_wls_update_rhs(b_wls, grad_data, grad_size, ws_grad);
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, vdops);
  //  Step 4: Optionally, evaluate the operator
  wls_eval_ops(b_wls, vdops, fs, result);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_cdr - Compute convection-diffusion-reaction operator at points
static void wls_var_cdr(WlsObject *b_wls,
                        const ::coder::array<real_T, 2U> &eval_pnts,
                        const ::coder::array<real_T, 2U> &ws_lap,
                        const ::coder::array<real_T, 2U> &ws_grad,
                        ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType grad_size[2];
  ::coder::SizeType lap_size[2];
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  ::coder::SizeType order;
  int8_T grad_data[3];
  int8_T lap_data[3];
  nevpnts = eval_pnts.size(0);
  //  The operators are row vectors, so they will be summed up before solve
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size[1] = 1;
    grad_size[0] = 1;
    grad_data[0] = 2;
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    break;
  case 2:
    grad_size[1] = 2;
    grad_size[0] = 1;
    lap_size[1] = 2;
    lap_size[0] = 1;
    grad_data[0] = 2;
    lap_data[0] = 4;
    grad_data[1] = 3;
    lap_data[1] = 5;
    break;
  default:
    grad_size[1] = 3;
    grad_size[0] = 1;
    lap_size[1] = 3;
    lap_size[0] = 1;
    grad_data[0] = 2;
    lap_data[0] = 5;
    grad_data[1] = 3;
    lap_data[1] = 6;
    grad_data[2] = 4;
    lap_data[2] = 7;
    break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0) &&
      (!coder::isequal(ws_lap))) {
    order = -2;
  } else if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
             (!coder::isequal(ws_grad))) {
    order = 1;
  } else {
    order = 0;
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, order,
               b_wls->hs_inv, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0)) {
    wls_update_rhs(b_wls, lap_data, lap_size, ws_lap);
  } else {
    c_wls_update_rhs(b_wls);
  }
  if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
      (!coder::isequal(ws_grad))) {
    b_wls_update_rhs(b_wls, grad_data, grad_size, ws_grad);
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, vdops);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_uno - Compute the unified Navier operator at evaluation points
static void wls_var_uno(WlsObject *b_wls,
                        const ::coder::array<real_T, 2U> &eval_pnts,
                        const ::coder::array<real_T, 1U> &ws_graddiv,
                        const ::coder::array<real_T, 1U> &ws_lap,
                        ::coder::array<real_T, 2U> &vdops)
{
  static const int8_T b_iv[8]{4, 6, 0, 0, 0, 0, 4, 6};
  static const int8_T b_iv1[8]{4, 5, 0, 0, 0, 0, 4, 5};
  real_T timestamp;
  ::coder::SizeType func_size[2];
  ::coder::SizeType lap_size[2];
  ::coder::SizeType grad_div_size;
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  ::coder::SizeType order;
  int8_T lap_data[27];
  int8_T func_data[9];
  int8_T grad_div_data[9];
  nevpnts = eval_pnts.size(0);
  //  The rows in the operators will be summed up before for each point
  switch (b_wls->us.size(1)) {
  case 1:
    grad_div_size = 1;
    grad_div_data[0] = 3;
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    func_size[1] = 1;
    func_size[0] = 1;
    func_data[0] = 1;
    break;
  case 2:
    grad_div_size = 4;
    grad_div_data[0] = 4;
    grad_div_data[1] = 5;
    grad_div_data[2] = 5;
    grad_div_data[3] = 6;
    lap_size[1] = 2;
    lap_size[0] = 4;
    for (::coder::SizeType i{0}; i < 8; i++) {
      lap_data[i] = b_iv[i];
    }
    func_size[1] = 2;
    func_size[0] = 2;
    func_data[0] = 1;
    func_data[1] = 0;
    func_data[2] = 0;
    func_data[3] = 1;
    break;
  default: {
    int8_T b_I[9];
    grad_div_size = 9;
    for (::coder::SizeType i{0}; i < 9; i++) {
      grad_div_data[i] = iv5[i];
    }
    lap_size[1] = 3;
    lap_size[0] = 9;
    for (::coder::SizeType i{0}; i < 27; i++) {
      lap_data[i] = iv6[i];
    }
    for (::coder::SizeType i{0}; i < 9; i++) {
      b_I[i] = 0;
    }
    b_I[0] = 1;
    b_I[4] = 1;
    b_I[8] = 1;
    func_size[1] = 3;
    func_size[0] = 3;
    for (::coder::SizeType i{0}; i < 9; i++) {
      func_data[i] = b_I[i];
    }
  } break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if (!coder::isequal(ws_graddiv)) {
    order = 2;
    //  With full Hessian
  } else if (!coder::isequal(ws_lap)) {
    order = -2;
    //  With Laplacian only
    if (b_wls->us.size(1) == 2) {
      lap_size[1] = 2;
      lap_size[0] = 4;
      for (::coder::SizeType i{0}; i < 8; i++) {
        lap_data[i] = b_iv1[i];
      }
    } else if (b_wls->us.size(1) == 3) {
      lap_size[1] = 3;
      lap_size[0] = 9;
      for (::coder::SizeType i{0}; i < 27; i++) {
        lap_data[i] = iv4[i];
      }
    }
  } else {
    order = 0;
    //  Function-values only
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, order,
               b_wls->hs_inv, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if (order == 2) {
    wls_update_rhs(b_wls, grad_div_data, grad_div_size, ws_graddiv);
    //  grad-div
  } else {
    wls_update_rhs(b_wls, grad_div_size);
  }
  if (!coder::isequal(ws_lap)) {
    wls_update_rhs(b_wls, lap_data, lap_size, ws_lap);
    //  laplacian
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, func_data, func_size, vdops);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_uno - Compute the unified Navier operator at evaluation points
static void wls_var_uno(WlsObject *b_wls,
                        const ::coder::array<real_T, 2U> &eval_pnts,
                        const ::coder::array<real_T, 1U> &ws_graddiv,
                        const ::coder::array<real_T, 2U> &fs,
                        ::coder::SizeType nevpnts,
                        ::coder::array<real_T, 2U> &vdops,
                        ::coder::array<real_T, 2U> &result)
{
  real_T timestamp;
  ::coder::SizeType func_size[2];
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType grad_div_size;
  ::coder::SizeType nDims;
  ::coder::SizeType order;
  int8_T func_data[9];
  int8_T grad_div_data[9];
  switch (b_wls->us.size(1)) {
  case 1:
    grad_div_size = 1;
    grad_div_data[0] = 3;
    func_size[1] = 1;
    func_size[0] = 1;
    func_data[0] = 1;
    break;
  case 2:
    grad_div_size = 4;
    grad_div_data[0] = 4;
    grad_div_data[1] = 5;
    grad_div_data[2] = 5;
    grad_div_data[3] = 6;
    func_size[1] = 2;
    func_size[0] = 2;
    func_data[0] = 1;
    func_data[1] = 0;
    func_data[2] = 0;
    func_data[3] = 1;
    break;
  default: {
    int8_T b_I[9];
    grad_div_size = 9;
    for (b_nevpnts = 0; b_nevpnts < 9; b_nevpnts++) {
      grad_div_data[b_nevpnts] = iv5[b_nevpnts];
      b_I[b_nevpnts] = 0;
    }
    b_I[0] = 1;
    b_I[4] = 1;
    b_I[8] = 1;
    func_size[1] = 3;
    func_size[0] = 3;
    for (b_nevpnts = 0; b_nevpnts < 9; b_nevpnts++) {
      func_data[b_nevpnts] = b_I[b_nevpnts];
    }
  } break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if (!coder::isequal(ws_graddiv)) {
    order = 2;
    //  With full Hessian
  } else {
    order = 0;
    //  Function-values only
  }
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, b_nevpnts, b_wls->degree, order, b_wls->hs_inv,
               b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if (order == 2) {
    wls_update_rhs(b_wls, grad_div_data, grad_div_size, ws_graddiv);
    //  grad-div
  } else {
    wls_update_rhs(b_wls, grad_div_size);
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, func_data, func_size, vdops);
  //  Step 4: Optionally, evaluate the operator
  wls_eval_ops(b_wls, vdops, fs, result);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_uno - Compute the unified Navier operator at evaluation points
static void wls_var_uno(WlsObject *b_wls,
                        const ::coder::array<real_T, 2U> &eval_pnts,
                        ::coder::array<real_T, 2U> &vdops)
{
  static const int8_T b_iv[8]{4, 6, 0, 0, 0, 0, 4, 6};
  real_T timestamp;
  ::coder::SizeType func_size[2];
  ::coder::SizeType lap_size[2];
  ::coder::SizeType grad_div_size;
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  int8_T lap_data[27];
  int8_T func_data[9];
  int8_T grad_div_data[9];
  nevpnts = eval_pnts.size(0);
  //  The rows in the operators will be summed up before for each point
  switch (b_wls->us.size(1)) {
  case 1:
    grad_div_size = 1;
    grad_div_data[0] = 3;
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    func_size[1] = 1;
    func_size[0] = 1;
    func_data[0] = 1;
    break;
  case 2:
    grad_div_size = 4;
    grad_div_data[0] = 4;
    grad_div_data[1] = 5;
    grad_div_data[2] = 5;
    grad_div_data[3] = 6;
    lap_size[1] = 2;
    lap_size[0] = 4;
    for (::coder::SizeType i{0}; i < 8; i++) {
      lap_data[i] = b_iv[i];
    }
    func_size[1] = 2;
    func_size[0] = 2;
    func_data[0] = 1;
    func_data[1] = 0;
    func_data[2] = 0;
    func_data[3] = 1;
    break;
  default: {
    int8_T b_I[9];
    grad_div_size = 9;
    for (::coder::SizeType i{0}; i < 9; i++) {
      grad_div_data[i] = iv5[i];
    }
    lap_size[1] = 3;
    lap_size[0] = 9;
    for (::coder::SizeType i{0}; i < 27; i++) {
      lap_data[i] = iv6[i];
    }
    for (::coder::SizeType i{0}; i < 9; i++) {
      b_I[i] = 0;
    }
    b_I[0] = 1;
    b_I[4] = 1;
    b_I[8] = 1;
    func_size[1] = 3;
    func_size[0] = 3;
    for (::coder::SizeType i{0}; i < 9; i++) {
      func_data[i] = b_I[i];
    }
  } break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  g_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv,
               b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  b_wls_update_rhs(b_wls, grad_div_data, grad_div_size);
  //  grad-div
  c_wls_update_rhs(b_wls, lap_data, lap_size);
  //  laplacian
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, func_data, func_size, vdops);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_uno - Compute the unified Navier operator at evaluation points
static void wls_var_uno(WlsObject *b_wls,
                        const ::coder::array<real_T, 2U> &eval_pnts,
                        const ::coder::array<real_T, 1U> &ws_graddiv,
                        const ::coder::array<real_T, 1U> &ws_lap,
                        const ::coder::array<real_T, 2U> &fs,
                        ::coder::array<real_T, 2U> &vdops,
                        ::coder::array<real_T, 2U> &result)
{
  static const int8_T b_iv[8]{4, 6, 0, 0, 0, 0, 4, 6};
  static const int8_T b_iv1[8]{4, 5, 0, 0, 0, 0, 4, 5};
  real_T timestamp;
  ::coder::SizeType func_size[2];
  ::coder::SizeType lap_size[2];
  ::coder::SizeType grad_div_size;
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  ::coder::SizeType order;
  int8_T lap_data[27];
  int8_T func_data[9];
  int8_T grad_div_data[9];
  nevpnts = eval_pnts.size(0);
  //  The rows in the operators will be summed up before for each point
  switch (b_wls->us.size(1)) {
  case 1:
    grad_div_size = 1;
    grad_div_data[0] = 3;
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    func_size[1] = 1;
    func_size[0] = 1;
    func_data[0] = 1;
    break;
  case 2:
    grad_div_size = 4;
    grad_div_data[0] = 4;
    grad_div_data[1] = 5;
    grad_div_data[2] = 5;
    grad_div_data[3] = 6;
    lap_size[1] = 2;
    lap_size[0] = 4;
    for (::coder::SizeType i{0}; i < 8; i++) {
      lap_data[i] = b_iv[i];
    }
    func_size[1] = 2;
    func_size[0] = 2;
    func_data[0] = 1;
    func_data[1] = 0;
    func_data[2] = 0;
    func_data[3] = 1;
    break;
  default: {
    int8_T b_I[9];
    grad_div_size = 9;
    for (::coder::SizeType i{0}; i < 9; i++) {
      grad_div_data[i] = iv5[i];
    }
    lap_size[1] = 3;
    lap_size[0] = 9;
    for (::coder::SizeType i{0}; i < 27; i++) {
      lap_data[i] = iv6[i];
    }
    for (::coder::SizeType i{0}; i < 9; i++) {
      b_I[i] = 0;
    }
    b_I[0] = 1;
    b_I[4] = 1;
    b_I[8] = 1;
    func_size[1] = 3;
    func_size[0] = 3;
    for (::coder::SizeType i{0}; i < 9; i++) {
      func_data[i] = b_I[i];
    }
  } break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if (!coder::isequal(ws_graddiv)) {
    order = 2;
    //  With full Hessian
  } else if (!coder::isequal(ws_lap)) {
    order = -2;
    //  With Laplacian only
    if (b_wls->us.size(1) == 2) {
      lap_size[1] = 2;
      lap_size[0] = 4;
      for (::coder::SizeType i{0}; i < 8; i++) {
        lap_data[i] = b_iv1[i];
      }
    } else if (b_wls->us.size(1) == 3) {
      lap_size[1] = 3;
      lap_size[0] = 9;
      for (::coder::SizeType i{0}; i < 27; i++) {
        lap_data[i] = iv4[i];
      }
    }
  } else {
    order = 0;
    //  Function-values only
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, order,
               b_wls->hs_inv, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if (order == 2) {
    wls_update_rhs(b_wls, grad_div_data, grad_div_size, ws_graddiv);
    //  grad-div
  } else {
    wls_update_rhs(b_wls, grad_div_size);
  }
  if (!coder::isequal(ws_lap)) {
    wls_update_rhs(b_wls, lap_data, lap_size, ws_lap);
    //  laplacian
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, func_data, func_size, vdops);
  //  Step 4: Optionally, evaluate the operator
  wls_eval_ops(b_wls, vdops, fs, result);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_uno - Compute the unified Navier operator at evaluation points
static void wls_var_uno(WlsObject *b_wls,
                        const ::coder::array<real_T, 2U> &eval_pnts,
                        const ::coder::array<real_T, 1U> &ws_graddiv,
                        const ::coder::array<real_T, 1U> &ws_lap,
                        const ::coder::array<real_T, 2U> &fs,
                        ::coder::SizeType nevpnts,
                        ::coder::array<real_T, 2U> &vdops,
                        ::coder::array<real_T, 2U> &result)
{
  static const int8_T b_iv[8]{4, 6, 0, 0, 0, 0, 4, 6};
  static const int8_T b_iv1[8]{4, 5, 0, 0, 0, 0, 4, 5};
  real_T timestamp;
  ::coder::SizeType func_size[2];
  ::coder::SizeType lap_size[2];
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType grad_div_size;
  ::coder::SizeType nDims;
  ::coder::SizeType order;
  int8_T lap_data[27];
  int8_T func_data[9];
  int8_T grad_div_data[9];
  switch (b_wls->us.size(1)) {
  case 1:
    grad_div_size = 1;
    grad_div_data[0] = 3;
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    func_size[1] = 1;
    func_size[0] = 1;
    func_data[0] = 1;
    break;
  case 2:
    grad_div_size = 4;
    grad_div_data[0] = 4;
    grad_div_data[1] = 5;
    grad_div_data[2] = 5;
    grad_div_data[3] = 6;
    lap_size[1] = 2;
    lap_size[0] = 4;
    for (b_nevpnts = 0; b_nevpnts < 8; b_nevpnts++) {
      lap_data[b_nevpnts] = b_iv[b_nevpnts];
    }
    func_size[1] = 2;
    func_size[0] = 2;
    func_data[0] = 1;
    func_data[1] = 0;
    func_data[2] = 0;
    func_data[3] = 1;
    break;
  default: {
    int8_T b_I[9];
    grad_div_size = 9;
    for (b_nevpnts = 0; b_nevpnts < 9; b_nevpnts++) {
      grad_div_data[b_nevpnts] = iv5[b_nevpnts];
    }
    lap_size[1] = 3;
    lap_size[0] = 9;
    for (b_nevpnts = 0; b_nevpnts < 27; b_nevpnts++) {
      lap_data[b_nevpnts] = iv6[b_nevpnts];
    }
    for (b_nevpnts = 0; b_nevpnts < 9; b_nevpnts++) {
      b_I[b_nevpnts] = 0;
    }
    b_I[0] = 1;
    b_I[4] = 1;
    b_I[8] = 1;
    func_size[1] = 3;
    func_size[0] = 3;
    for (b_nevpnts = 0; b_nevpnts < 9; b_nevpnts++) {
      func_data[b_nevpnts] = b_I[b_nevpnts];
    }
  } break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if (!coder::isequal(ws_graddiv)) {
    order = 2;
    //  With full Hessian
  } else if (!coder::isequal(ws_lap)) {
    order = -2;
    //  With Laplacian only
    if (b_wls->us.size(1) == 2) {
      lap_size[1] = 2;
      lap_size[0] = 4;
      for (b_nevpnts = 0; b_nevpnts < 8; b_nevpnts++) {
        lap_data[b_nevpnts] = b_iv1[b_nevpnts];
      }
    } else if (b_wls->us.size(1) == 3) {
      lap_size[1] = 3;
      lap_size[0] = 9;
      for (b_nevpnts = 0; b_nevpnts < 27; b_nevpnts++) {
        lap_data[b_nevpnts] = iv4[b_nevpnts];
      }
    }
  } else {
    order = 0;
    //  Function-values only
  }
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, b_nevpnts, b_wls->degree, order, b_wls->hs_inv,
               b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if (order == 2) {
    wls_update_rhs(b_wls, grad_div_data, grad_div_size, ws_graddiv);
    //  grad-div
  } else {
    wls_update_rhs(b_wls, grad_div_size);
  }
  if (!coder::isequal(ws_lap)) {
    wls_update_rhs(b_wls, lap_data, lap_size, ws_lap);
    //  laplacian
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, func_data, func_size, vdops);
  //  Step 4: Optionally, evaluate the operator
  wls_eval_ops(b_wls, vdops, fs, result);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_uno - Compute the unified Navier operator at evaluation points
static void wls_var_uno(WlsObject *b_wls,
                        const ::coder::array<real_T, 2U> &eval_pnts,
                        const ::coder::array<real_T, 1U> &ws_graddiv,
                        ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType func_size[2];
  ::coder::SizeType grad_div_size;
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  ::coder::SizeType order;
  int8_T func_data[9];
  int8_T grad_div_data[9];
  nevpnts = eval_pnts.size(0);
  //  The rows in the operators will be summed up before for each point
  switch (b_wls->us.size(1)) {
  case 1:
    grad_div_size = 1;
    grad_div_data[0] = 3;
    func_size[1] = 1;
    func_size[0] = 1;
    func_data[0] = 1;
    break;
  case 2:
    grad_div_size = 4;
    grad_div_data[0] = 4;
    grad_div_data[1] = 5;
    grad_div_data[2] = 5;
    grad_div_data[3] = 6;
    func_size[1] = 2;
    func_size[0] = 2;
    func_data[0] = 1;
    func_data[1] = 0;
    func_data[2] = 0;
    func_data[3] = 1;
    break;
  default: {
    int8_T b_I[9];
    grad_div_size = 9;
    for (::coder::SizeType i{0}; i < 9; i++) {
      grad_div_data[i] = iv5[i];
      b_I[i] = 0;
    }
    b_I[0] = 1;
    b_I[4] = 1;
    b_I[8] = 1;
    func_size[1] = 3;
    func_size[0] = 3;
    for (::coder::SizeType i{0}; i < 9; i++) {
      func_data[i] = b_I[i];
    }
  } break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if (!coder::isequal(ws_graddiv)) {
    order = 2;
    //  With full Hessian
  } else {
    order = 0;
    //  Function-values only
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, order,
               b_wls->hs_inv, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if (order == 2) {
    wls_update_rhs(b_wls, grad_div_data, grad_div_size, ws_graddiv);
    //  grad-div
  } else {
    wls_update_rhs(b_wls, grad_div_size);
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, func_data, func_size, vdops);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_uno - Compute the unified Navier operator at evaluation points
static void wls_var_uno(WlsObject *b_wls,
                        const ::coder::array<real_T, 2U> &eval_pnts,
                        const ::coder::array<real_T, 1U> &ws_graddiv,
                        const ::coder::array<real_T, 2U> &fs,
                        ::coder::array<real_T, 2U> &vdops,
                        ::coder::array<real_T, 2U> &result)
{
  real_T timestamp;
  ::coder::SizeType func_size[2];
  ::coder::SizeType grad_div_size;
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  ::coder::SizeType order;
  int8_T func_data[9];
  int8_T grad_div_data[9];
  nevpnts = eval_pnts.size(0);
  //  The rows in the operators will be summed up before for each point
  switch (b_wls->us.size(1)) {
  case 1:
    grad_div_size = 1;
    grad_div_data[0] = 3;
    func_size[1] = 1;
    func_size[0] = 1;
    func_data[0] = 1;
    break;
  case 2:
    grad_div_size = 4;
    grad_div_data[0] = 4;
    grad_div_data[1] = 5;
    grad_div_data[2] = 5;
    grad_div_data[3] = 6;
    func_size[1] = 2;
    func_size[0] = 2;
    func_data[0] = 1;
    func_data[1] = 0;
    func_data[2] = 0;
    func_data[3] = 1;
    break;
  default: {
    int8_T b_I[9];
    grad_div_size = 9;
    for (::coder::SizeType i{0}; i < 9; i++) {
      grad_div_data[i] = iv5[i];
      b_I[i] = 0;
    }
    b_I[0] = 1;
    b_I[4] = 1;
    b_I[8] = 1;
    func_size[1] = 3;
    func_size[0] = 3;
    for (::coder::SizeType i{0}; i < 9; i++) {
      func_data[i] = b_I[i];
    }
  } break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if (!coder::isequal(ws_graddiv)) {
    order = 2;
    //  With full Hessian
  } else {
    order = 0;
    //  Function-values only
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, order,
               b_wls->hs_inv, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if (order == 2) {
    wls_update_rhs(b_wls, grad_div_data, grad_div_size, ws_graddiv);
    //  grad-div
  } else {
    wls_update_rhs(b_wls, grad_div_size);
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, func_data, func_size, vdops);
  //  Step 4: Optionally, evaluate the operator
  wls_eval_ops(b_wls, vdops, fs, result);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_curl - Variational curl operators at evaluation points
static inline void wls_curl(WlsObject *b_wls,
                            const ::coder::array<real_T, 2U> &eval_pnts,
                            const ::coder::array<real_T, 2U> &,
                            ::coder::SizeType varargin_2,
                            ::coder::array<real_T, 2U> &varargout_1)
{
  wls_kernel(b_wls, eval_pnts, varargin_2, varargout_1);
}

//  wls_curl - Variational curl operators at evaluation points
static inline void wls_curl(WlsObject *b_wls,
                            const ::coder::array<real_T, 2U> &eval_pnts,
                            const ::coder::array<real_T, 2U> &,
                            ::coder::array<real_T, 2U> &varargout_1)
{
  wls_kernel(b_wls, eval_pnts, varargout_1);
}

//  wls_curl - Variational curl operators at evaluation points
static inline void wls_curl(WlsObject *b_wls,
                            const ::coder::array<real_T, 2U> &eval_pnts,
                            ::coder::array<real_T, 2U> &varargout_1)
{
  wls_kernel(b_wls, eval_pnts, varargout_1);
}

//  wls_div  Compute divergence operators at evaluation points
void wls_div(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
             const ::coder::array<real_T, 2U> &varargin_1,
             ::coder::SizeType varargin_2,
             ::coder::array<real_T, 2U> &varargout_1,
             ::coder::array<real_T, 2U> &varargout_2)
{
  ::coder::SizeType div_size[2];
  int8_T div_data[9];
  switch (b_wls->us.size(1)) {
  case 1:
    div_size[1] = 1;
    div_size[0] = 1;
    div_data[0] = 2;
    break;
  case 2:
    div_size[1] = 2;
    div_size[0] = 2;
    div_data[0] = 2;
    div_data[1] = 0;
    div_data[2] = 0;
    div_data[3] = 3;
    break;
  default:
    div_size[1] = 3;
    div_size[0] = 3;
    for (::coder::SizeType i{0}; i < 9; i++) {
      div_data[i] = iv1[i];
    }
    break;
  }
  wls_kernel(b_wls, eval_pnts, div_data, div_size, varargin_1, varargin_2,
             varargout_1, varargout_2);
}

//  wls_div  Compute divergence operators at evaluation points
void wls_div(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
             const ::coder::array<real_T, 2U> &varargin_1,
             ::coder::array<real_T, 2U> &varargout_1,
             ::coder::array<real_T, 2U> &varargout_2)
{
  ::coder::SizeType div_size[2];
  int8_T div_data[9];
  switch (b_wls->us.size(1)) {
  case 1:
    div_size[1] = 1;
    div_size[0] = 1;
    div_data[0] = 2;
    break;
  case 2:
    div_size[1] = 2;
    div_size[0] = 2;
    div_data[0] = 2;
    div_data[1] = 0;
    div_data[2] = 0;
    div_data[3] = 3;
    break;
  default:
    div_size[1] = 3;
    div_size[0] = 3;
    for (::coder::SizeType i{0}; i < 9; i++) {
      div_data[i] = iv1[i];
    }
    break;
  }
  wls_kernel(b_wls, eval_pnts, div_data, div_size, varargin_1, varargout_1,
             varargout_2);
}

//  wls_div  Compute divergence operators at evaluation points
void wls_div(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
             ::coder::array<real_T, 2U> &varargout_1)
{
  ::coder::SizeType div_size[2];
  int8_T div_data[9];
  switch (b_wls->us.size(1)) {
  case 1:
    div_size[1] = 1;
    div_size[0] = 1;
    div_data[0] = 2;
    break;
  case 2:
    div_size[1] = 2;
    div_size[0] = 2;
    div_data[0] = 2;
    div_data[1] = 0;
    div_data[2] = 0;
    div_data[3] = 3;
    break;
  default:
    div_size[1] = 3;
    div_size[0] = 3;
    for (::coder::SizeType i{0}; i < 9; i++) {
      div_data[i] = iv1[i];
    }
    break;
  }
  wls_kernel(b_wls, eval_pnts, div_data, div_size, varargout_1);
}

//  wls_func - Evaluate wls-fitting at one or more points.
static inline void wls_func(WlsObject *b_wls,
                            const ::coder::array<real_T, 2U> &eval_pnts,
                            const ::coder::array<real_T, 2U> &varargin_1,
                            ::coder::SizeType varargin_2,
                            ::coder::array<real_T, 2U> &varargout_1,
                            ::coder::array<real_T, 2U> &varargout_2)
{
  wls_kernel(b_wls, eval_pnts, varargin_1, varargin_2, varargout_1,
             varargout_2);
}

//  wls_func - Evaluate wls-fitting at one or more points.
static inline void wls_func(WlsObject *b_wls,
                            const ::coder::array<real_T, 2U> &eval_pnts,
                            const ::coder::array<real_T, 2U> &varargin_1,
                            ::coder::array<real_T, 2U> &varargout_1,
                            ::coder::array<real_T, 2U> &varargout_2)
{
  wls_kernel(b_wls, eval_pnts, varargin_1, varargout_1, varargout_2);
}

//  wls_func - Evaluate wls-fitting at one or more points.
static inline void wls_func(WlsObject *b_wls,
                            const ::coder::array<real_T, 2U> &eval_pnts,
                            ::coder::array<real_T, 2U> &varargout_1)
{
  b_wls_kernel(b_wls, eval_pnts, varargout_1);
}

//  wls_grad - Evaluate gradient at one or more points using wls fitting.
void wls_grad(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
              const ::coder::array<real_T, 2U> &varargin_1,
              ::coder::SizeType varargin_2,
              ::coder::array<real_T, 2U> &varargout_1,
              ::coder::array<real_T, 2U> &varargout_2)
{
  ::coder::SizeType grad_size;
  int8_T grad_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size = 1;
    grad_data[0] = 2;
    break;
  case 2:
    grad_size = 2;
    grad_data[0] = 2;
    grad_data[1] = 3;
    break;
  default:
    grad_size = 3;
    grad_data[0] = 2;
    grad_data[1] = 3;
    grad_data[2] = 4;
    break;
  }
  wls_kernel(b_wls, eval_pnts, grad_data, grad_size, varargin_1, varargin_2,
             varargout_1, varargout_2);
}

//  wls_grad - Evaluate gradient at one or more points using wls fitting.
void wls_grad(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
              const ::coder::array<real_T, 2U> &varargin_1,
              ::coder::array<real_T, 2U> &varargout_1,
              ::coder::array<real_T, 2U> &varargout_2)
{
  ::coder::SizeType grad_size;
  int8_T grad_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size = 1;
    grad_data[0] = 2;
    break;
  case 2:
    grad_size = 2;
    grad_data[0] = 2;
    grad_data[1] = 3;
    break;
  default:
    grad_size = 3;
    grad_data[0] = 2;
    grad_data[1] = 3;
    grad_data[2] = 4;
    break;
  }
  wls_kernel(b_wls, eval_pnts, grad_data, grad_size, varargin_1, varargout_1,
             varargout_2);
}

//  wls_grad - Evaluate gradient at one or more points using wls fitting.
void wls_grad(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
              ::coder::array<real_T, 2U> &varargout_1)
{
  ::coder::SizeType grad_size;
  int8_T grad_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size = 1;
    grad_data[0] = 2;
    break;
  case 2:
    grad_size = 2;
    grad_data[0] = 2;
    grad_data[1] = 3;
    break;
  default:
    grad_size = 3;
    grad_data[0] = 2;
    grad_data[1] = 3;
    grad_data[2] = 4;
    break;
  }
  wls_kernel(b_wls, eval_pnts, grad_data, grad_size, varargout_1);
}

//  wls_init  Initialize WlsObject in 1D, 2D, or 3D.
void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const WlsWeight *weight, ::coder::SizeType degree,
              ::coder::SizeType order, ::coder::SizeType interp0,
              ::coder::SizeType unimono)
{
  real_T timestamp;
  ::coder::SizeType dim;
  ::coder::SizeType nstpnts;
  boolean_T b_unimono;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  b_wls->interp0 = interp0;
  b_wls->unimono = unimono != 0;
  b_unimono = b_wls->unimono;
  nstpnts = us.size(0) - 1;
  if (b_wls->unimono && (!onaxes(us, us.size(0)))) {
    m2cErrMsgIdAndTxt(
        "wlslib:NotAxesAlignedStencils",
        "To use univariate-monomial mode, all points must be on axes.");
  }
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), degree, order);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    ::coder::SizeType b_i;
    ::coder::SizeType loop_ub;
    ::coder::SizeType ncols;
    ::coder::SizeType nrblks;
    ::coder::SizeType src;
    ::coder::SizeType trg;
    ::coder::SizeType u0;
    ::coder::SizeType u1;
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        u0 = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          if (b1 || (i >= b_i)) {
            u0 = 0;
            b = true;
          } else if (b) {
            b = false;
            u0 = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            loop_ub = us.size(1) * us.size(0) - 1;
            if (u0 > MAX_int32_T - us.size(1)) {
              u0 = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              u0 += us.size(1);
              if (u0 > loop_ub) {
                u0 -= loop_ub;
              }
            }
          }
          loop_ub = b_wls->us.size(0);
          b_wls->us[i % loop_ub * b_wls->us.size(1) + i / loop_ub] =
              us[u0] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        b_wls->origin[2] = us[2];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        u0 = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          if (b1 || (i >= b_i)) {
            u0 = 0;
            b = true;
          } else if (b) {
            b = false;
            u0 = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            loop_ub = us.size(1) * us.size(0) - 1;
            if (u0 > MAX_int32_T - us.size(1)) {
              u0 = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              u0 += us.size(1);
              if (u0 > loop_ub) {
                u0 -= loop_ub;
              }
            }
          }
          loop_ub = b_wls->us.size(0);
          b_wls->us[i % loop_ub * b_wls->us.size(1) + i / loop_ub] = us[u0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        b_wls->origin[2] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      b_i = b_wls->us.size(0);
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[i % b_i * b_wls->us.size(1) + i / b_i]));
      }
      break;
    case 2:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * i + 1])));
      }
      break;
    default:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                                std::abs(b_wls->us[b_wls->us.size(1) * i + 1])),
                      std::abs(b_wls->us[b_wls->us.size(1) * i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (::coder::SizeType i{0}; i <= dim; i++) {
      b_wls->hs_inv[i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
        }
        break;
      case 2:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
        }
        break;
      default:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 2] =
              b_wls->us[b_wls->us.size(1) * i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight->name.size(1) == 0) || (weight->name[0] == 'U')) &&
        (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight->name.size(1) == 0) || (weight->name[0] == 'U')) {
        //  unit weights
        loop_ub = b_wls->rweights.size(0);
        for (b_i = 0; b_i < loop_ub; b_i++) {
          b_wls->rweights[b_i] = 1.0;
        }
      } else if ((weight->name[0] == 'I') || (weight->name[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else if ((weight->name[0] == 'B') || (weight->name[0] == 'b')) {
        //  Buhmann weights. All points share same parameters
        wls_buhmann_weights(b_wls->us, us.size(0), degree, b_unimono,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else {
        if ((weight->name[0] != 'E') && (weight->name[0] != 'e')) {
          m2cErrMsgIdAndTxt(
              "wlslib:WrongWeightName",
              "Weighting scheme must be Unit, InvDist, Buhmann, or ENO.");
        }
        //  WLS-ENO
        wls_eno_weights(b_wls->us, us.size(0), degree, us,
                        weight->params_shared, weight->params_pointwise,
                        b_wls->rweights);
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      timestamp = static_cast<std::chrono::duration<double>>(
                      std::chrono::system_clock::now().time_since_epoch())
                      .count();
    }
    //  Compute Vandermonde system
    c_gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights,
                 b_unimono, b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_i = b_wls->V.size(0);
          for (::coder::SizeType j{0}; j < b_i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    //  Omit rows in CVM if needed
    u0 = weight->omit_rows.size(0);
    u1 = b_wls->nrows;
    if (u0 <= u1) {
      u1 = u0;
    }
    for (::coder::SizeType i{0}; i < u1; i++) {
      if (weight->omit_rows[i]) {
        loop_ub = b_wls->V.size(0);
        for (b_i = 0; b_i < loop_ub; b_i++) {
          b_wls->V[i + b_wls->V.size(1) * b_i] = 0.0;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T timestamp1;
      timestamp1 = static_cast<std::chrono::duration<double>>(
                       std::chrono::system_clock::now().time_since_epoch())
                       .count();
      b_wls->runtimes[0] = timestamp1 - timestamp;
      timestamp = timestamp1;
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        ::coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (::coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          b_i = us.size(1) + 2;
          for (::coder::SizeType blk{b_i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (::coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        d_gen_vander(b_wls->hs_inv, order, b_wls->V);
        for (::coder::SizeType blk{2}; blk <= nrblks; blk++) {
          ::coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (::coder::SizeType i{0}; i <= nstpnts; i++) {
            b_wls->rweights[trg + i] = b_wls->rweights[src + i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T t;
      t = static_cast<std::chrono::duration<double>>(
              std::chrono::system_clock::now().time_since_epoch())
              .count();
      b_wls->runtimes[1] = t - timestamp;
    }
  }
}

void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const ::coder::array<char_T, 2U> &weight)
{
  real_T timestamp;
  ::coder::SizeType degree;
  ::coder::SizeType dim;
  ::coder::SizeType interp0;
  ::coder::SizeType nstpnts;
  ::coder::SizeType order;
  boolean_T unimono;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  degree = b_wls->degree;
  order = b_wls->order;
  interp0 = b_wls->interp0;
  unimono = b_wls->unimono;
  nstpnts = us.size(0) - 1;
  if (b_wls->unimono && (!onaxes(us, us.size(0)))) {
    m2cErrMsgIdAndTxt(
        "wlslib:NotAxesAlignedStencils",
        "To use univariate-monomial mode, all points must be on axes.");
  }
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), b_wls->degree, b_wls->order);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    ::coder::SizeType b_i;
    ::coder::SizeType b_us;
    ::coder::SizeType ncols;
    ::coder::SizeType nrblks;
    ::coder::SizeType src;
    ::coder::SizeType trg;
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        b_us = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          ::coder::SizeType i1;
          if (b1 || (i >= b_i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[i % i1 * b_wls->us.size(1) + i / i1] = us[b_us] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        b_wls->origin[2] = us[2];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        b_us = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          ::coder::SizeType i1;
          if (b1 || (i >= b_i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[i % i1 * b_wls->us.size(1) + i / i1] = us[b_us];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        b_wls->origin[2] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      b_i = b_wls->us.size(0);
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[i % b_i * b_wls->us.size(1) + i / b_i]));
      }
      break;
    case 2:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * i + 1])));
      }
      break;
    default:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                                std::abs(b_wls->us[b_wls->us.size(1) * i + 1])),
                      std::abs(b_wls->us[b_wls->us.size(1) * i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (::coder::SizeType i{0}; i <= dim; i++) {
      b_wls->hs_inv[i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
        }
        break;
      case 2:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
        }
        break;
      default:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 2] =
              b_wls->us[b_wls->us.size(1) * i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight.size(1) == 0) || (weight[0] == 'U')) && (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight.size(1) == 0) || (weight[0] == 'U')) {
        //  unit weights
        b_us = b_wls->rweights.size(0);
        b_wls->rweights.set_size(b_us);
        for (b_i = 0; b_i < b_us; b_i++) {
          b_wls->rweights[b_i] = 1.0;
        }
      } else if ((weight[0] == 'I') || (weight[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree, b_wls->rweights);
      } else {
        if ((weight[0] != 'B') && (weight[0] != 'b')) {
          m2cErrMsgIdAndTxt("wlslib:WrongWeightName",
                            "When using a character string, weighting scheme "
                            "must be Unit, InvDist, or Buhmann.");
        }
        //  Buhmann weights with default parameters
        b_wls_buhmann_weights(b_wls->us, us.size(0), degree, unimono,
                              b_wls->rweights);
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      timestamp = static_cast<std::chrono::duration<double>>(
                      std::chrono::system_clock::now().time_since_epoch())
                      .count();
    }
    //  Compute Vandermonde system
    c_gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, unimono,
                 b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_i = b_wls->V.size(0);
          for (::coder::SizeType j{0}; j < b_i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    //  Omit rows in CVM if needed
    if (b_wls->runtimes.size(0) != 0) {
      real_T timestamp1;
      timestamp1 = static_cast<std::chrono::duration<double>>(
                       std::chrono::system_clock::now().time_since_epoch())
                       .count();
      b_wls->runtimes[0] = timestamp1 - timestamp;
      timestamp = timestamp1;
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        ::coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (::coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          b_i = us.size(1) + 2;
          for (::coder::SizeType blk{b_i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (::coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        d_gen_vander(b_wls->hs_inv, order, b_wls->V);
        for (::coder::SizeType blk{2}; blk <= nrblks; blk++) {
          ::coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (::coder::SizeType i{0}; i <= nstpnts; i++) {
            b_wls->rweights[trg + i] = b_wls->rweights[src + i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T t;
      t = static_cast<std::chrono::duration<double>>(
              std::chrono::system_clock::now().time_since_epoch())
              .count();
      b_wls->runtimes[1] = t - timestamp;
    }
  }
}

void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const ::coder::array<char_T, 2U> &weight,
              ::coder::SizeType degree)
{
  real_T timestamp;
  ::coder::SizeType dim;
  ::coder::SizeType interp0;
  ::coder::SizeType nstpnts;
  ::coder::SizeType order;
  boolean_T unimono;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  order = b_wls->order;
  interp0 = b_wls->interp0;
  unimono = b_wls->unimono;
  nstpnts = us.size(0) - 1;
  if (b_wls->unimono && (!onaxes(us, us.size(0)))) {
    m2cErrMsgIdAndTxt(
        "wlslib:NotAxesAlignedStencils",
        "To use univariate-monomial mode, all points must be on axes.");
  }
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), degree, b_wls->order);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    ::coder::SizeType b_i;
    ::coder::SizeType b_us;
    ::coder::SizeType ncols;
    ::coder::SizeType nrblks;
    ::coder::SizeType src;
    ::coder::SizeType trg;
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        b_us = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          ::coder::SizeType i1;
          if (b1 || (i >= b_i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[i % i1 * b_wls->us.size(1) + i / i1] = us[b_us] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        b_wls->origin[2] = us[2];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        b_us = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          ::coder::SizeType i1;
          if (b1 || (i >= b_i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[i % i1 * b_wls->us.size(1) + i / i1] = us[b_us];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        b_wls->origin[2] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      b_i = b_wls->us.size(0);
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[i % b_i * b_wls->us.size(1) + i / b_i]));
      }
      break;
    case 2:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * i + 1])));
      }
      break;
    default:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                                std::abs(b_wls->us[b_wls->us.size(1) * i + 1])),
                      std::abs(b_wls->us[b_wls->us.size(1) * i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (::coder::SizeType i{0}; i <= dim; i++) {
      b_wls->hs_inv[i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
        }
        break;
      case 2:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
        }
        break;
      default:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 2] =
              b_wls->us[b_wls->us.size(1) * i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight.size(1) == 0) || (weight[0] == 'U')) && (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight.size(1) == 0) || (weight[0] == 'U')) {
        //  unit weights
        b_us = b_wls->rweights.size(0);
        b_wls->rweights.set_size(b_us);
        for (b_i = 0; b_i < b_us; b_i++) {
          b_wls->rweights[b_i] = 1.0;
        }
      } else if ((weight[0] == 'I') || (weight[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree, b_wls->rweights);
      } else {
        if ((weight[0] != 'B') && (weight[0] != 'b')) {
          m2cErrMsgIdAndTxt("wlslib:WrongWeightName",
                            "When using a character string, weighting scheme "
                            "must be Unit, InvDist, or Buhmann.");
        }
        //  Buhmann weights with default parameters
        b_wls_buhmann_weights(b_wls->us, us.size(0), degree, unimono,
                              b_wls->rweights);
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      timestamp = static_cast<std::chrono::duration<double>>(
                      std::chrono::system_clock::now().time_since_epoch())
                      .count();
    }
    //  Compute Vandermonde system
    c_gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, unimono,
                 b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_i = b_wls->V.size(0);
          for (::coder::SizeType j{0}; j < b_i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    //  Omit rows in CVM if needed
    if (b_wls->runtimes.size(0) != 0) {
      real_T timestamp1;
      timestamp1 = static_cast<std::chrono::duration<double>>(
                       std::chrono::system_clock::now().time_since_epoch())
                       .count();
      b_wls->runtimes[0] = timestamp1 - timestamp;
      timestamp = timestamp1;
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        ::coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (::coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          b_i = us.size(1) + 2;
          for (::coder::SizeType blk{b_i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (::coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        d_gen_vander(b_wls->hs_inv, order, b_wls->V);
        for (::coder::SizeType blk{2}; blk <= nrblks; blk++) {
          ::coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (::coder::SizeType i{0}; i <= nstpnts; i++) {
            b_wls->rweights[trg + i] = b_wls->rweights[src + i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T t;
      t = static_cast<std::chrono::duration<double>>(
              std::chrono::system_clock::now().time_since_epoch())
              .count();
      b_wls->runtimes[1] = t - timestamp;
    }
  }
}

void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const ::coder::array<char_T, 2U> &weight,
              ::coder::SizeType degree, ::coder::SizeType order)
{
  real_T timestamp;
  ::coder::SizeType dim;
  ::coder::SizeType interp0;
  ::coder::SizeType nstpnts;
  boolean_T unimono;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  interp0 = b_wls->interp0;
  unimono = b_wls->unimono;
  nstpnts = us.size(0) - 1;
  if (b_wls->unimono && (!onaxes(us, us.size(0)))) {
    m2cErrMsgIdAndTxt(
        "wlslib:NotAxesAlignedStencils",
        "To use univariate-monomial mode, all points must be on axes.");
  }
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), degree, order);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    ::coder::SizeType b_i;
    ::coder::SizeType b_us;
    ::coder::SizeType ncols;
    ::coder::SizeType nrblks;
    ::coder::SizeType src;
    ::coder::SizeType trg;
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        b_us = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          ::coder::SizeType i1;
          if (b1 || (i >= b_i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[i % i1 * b_wls->us.size(1) + i / i1] = us[b_us] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        b_wls->origin[2] = us[2];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        b_us = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          ::coder::SizeType i1;
          if (b1 || (i >= b_i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[i % i1 * b_wls->us.size(1) + i / i1] = us[b_us];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        b_wls->origin[2] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      b_i = b_wls->us.size(0);
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[i % b_i * b_wls->us.size(1) + i / b_i]));
      }
      break;
    case 2:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * i + 1])));
      }
      break;
    default:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                                std::abs(b_wls->us[b_wls->us.size(1) * i + 1])),
                      std::abs(b_wls->us[b_wls->us.size(1) * i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (::coder::SizeType i{0}; i <= dim; i++) {
      b_wls->hs_inv[i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
        }
        break;
      case 2:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
        }
        break;
      default:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 2] =
              b_wls->us[b_wls->us.size(1) * i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight.size(1) == 0) || (weight[0] == 'U')) && (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight.size(1) == 0) || (weight[0] == 'U')) {
        //  unit weights
        b_us = b_wls->rweights.size(0);
        b_wls->rweights.set_size(b_us);
        for (b_i = 0; b_i < b_us; b_i++) {
          b_wls->rweights[b_i] = 1.0;
        }
      } else if ((weight[0] == 'I') || (weight[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree, b_wls->rweights);
      } else {
        if ((weight[0] != 'B') && (weight[0] != 'b')) {
          m2cErrMsgIdAndTxt("wlslib:WrongWeightName",
                            "When using a character string, weighting scheme "
                            "must be Unit, InvDist, or Buhmann.");
        }
        //  Buhmann weights with default parameters
        b_wls_buhmann_weights(b_wls->us, us.size(0), degree, unimono,
                              b_wls->rweights);
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      timestamp = static_cast<std::chrono::duration<double>>(
                      std::chrono::system_clock::now().time_since_epoch())
                      .count();
    }
    //  Compute Vandermonde system
    c_gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, unimono,
                 b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_i = b_wls->V.size(0);
          for (::coder::SizeType j{0}; j < b_i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    //  Omit rows in CVM if needed
    if (b_wls->runtimes.size(0) != 0) {
      real_T timestamp1;
      timestamp1 = static_cast<std::chrono::duration<double>>(
                       std::chrono::system_clock::now().time_since_epoch())
                       .count();
      b_wls->runtimes[0] = timestamp1 - timestamp;
      timestamp = timestamp1;
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        ::coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (::coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          b_i = us.size(1) + 2;
          for (::coder::SizeType blk{b_i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (::coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        d_gen_vander(b_wls->hs_inv, order, b_wls->V);
        for (::coder::SizeType blk{2}; blk <= nrblks; blk++) {
          ::coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (::coder::SizeType i{0}; i <= nstpnts; i++) {
            b_wls->rweights[trg + i] = b_wls->rweights[src + i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T t;
      t = static_cast<std::chrono::duration<double>>(
              std::chrono::system_clock::now().time_since_epoch())
              .count();
      b_wls->runtimes[1] = t - timestamp;
    }
  }
}

void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const ::coder::array<char_T, 2U> &weight,
              ::coder::SizeType degree, ::coder::SizeType order,
              ::coder::SizeType interp0)
{
  real_T timestamp;
  ::coder::SizeType dim;
  ::coder::SizeType nstpnts;
  boolean_T unimono;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  b_wls->interp0 = interp0;
  unimono = b_wls->unimono;
  nstpnts = us.size(0) - 1;
  if (b_wls->unimono && (!onaxes(us, us.size(0)))) {
    m2cErrMsgIdAndTxt(
        "wlslib:NotAxesAlignedStencils",
        "To use univariate-monomial mode, all points must be on axes.");
  }
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), degree, order);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    ::coder::SizeType b_i;
    ::coder::SizeType b_us;
    ::coder::SizeType ncols;
    ::coder::SizeType nrblks;
    ::coder::SizeType src;
    ::coder::SizeType trg;
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        b_us = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          ::coder::SizeType i1;
          if (b1 || (i >= b_i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[i % i1 * b_wls->us.size(1) + i / i1] = us[b_us] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        b_wls->origin[2] = us[2];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        b_us = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          ::coder::SizeType i1;
          if (b1 || (i >= b_i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[i % i1 * b_wls->us.size(1) + i / i1] = us[b_us];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        b_wls->origin[2] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      b_i = b_wls->us.size(0);
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[i % b_i * b_wls->us.size(1) + i / b_i]));
      }
      break;
    case 2:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * i + 1])));
      }
      break;
    default:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                                std::abs(b_wls->us[b_wls->us.size(1) * i + 1])),
                      std::abs(b_wls->us[b_wls->us.size(1) * i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (::coder::SizeType i{0}; i <= dim; i++) {
      b_wls->hs_inv[i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
        }
        break;
      case 2:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
        }
        break;
      default:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 2] =
              b_wls->us[b_wls->us.size(1) * i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight.size(1) == 0) || (weight[0] == 'U')) && (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight.size(1) == 0) || (weight[0] == 'U')) {
        //  unit weights
        b_us = b_wls->rweights.size(0);
        b_wls->rweights.set_size(b_us);
        for (b_i = 0; b_i < b_us; b_i++) {
          b_wls->rweights[b_i] = 1.0;
        }
      } else if ((weight[0] == 'I') || (weight[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree, b_wls->rweights);
      } else {
        if ((weight[0] != 'B') && (weight[0] != 'b')) {
          m2cErrMsgIdAndTxt("wlslib:WrongWeightName",
                            "When using a character string, weighting scheme "
                            "must be Unit, InvDist, or Buhmann.");
        }
        //  Buhmann weights with default parameters
        b_wls_buhmann_weights(b_wls->us, us.size(0), degree, unimono,
                              b_wls->rweights);
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      timestamp = static_cast<std::chrono::duration<double>>(
                      std::chrono::system_clock::now().time_since_epoch())
                      .count();
    }
    //  Compute Vandermonde system
    c_gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, unimono,
                 b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_i = b_wls->V.size(0);
          for (::coder::SizeType j{0}; j < b_i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    //  Omit rows in CVM if needed
    if (b_wls->runtimes.size(0) != 0) {
      real_T timestamp1;
      timestamp1 = static_cast<std::chrono::duration<double>>(
                       std::chrono::system_clock::now().time_since_epoch())
                       .count();
      b_wls->runtimes[0] = timestamp1 - timestamp;
      timestamp = timestamp1;
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        ::coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (::coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          b_i = us.size(1) + 2;
          for (::coder::SizeType blk{b_i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (::coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        d_gen_vander(b_wls->hs_inv, order, b_wls->V);
        for (::coder::SizeType blk{2}; blk <= nrblks; blk++) {
          ::coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (::coder::SizeType i{0}; i <= nstpnts; i++) {
            b_wls->rweights[trg + i] = b_wls->rweights[src + i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T t;
      t = static_cast<std::chrono::duration<double>>(
              std::chrono::system_clock::now().time_since_epoch())
              .count();
      b_wls->runtimes[1] = t - timestamp;
    }
  }
}

void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const ::coder::array<char_T, 2U> &weight,
              ::coder::SizeType degree, ::coder::SizeType order,
              ::coder::SizeType interp0, boolean_T unimono)
{
  real_T timestamp;
  ::coder::SizeType dim;
  ::coder::SizeType nstpnts;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  b_wls->interp0 = interp0;
  b_wls->unimono = unimono;
  nstpnts = us.size(0) - 1;
  if (unimono && (!onaxes(us, us.size(0)))) {
    m2cErrMsgIdAndTxt(
        "wlslib:NotAxesAlignedStencils",
        "To use univariate-monomial mode, all points must be on axes.");
  }
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), degree, order);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    ::coder::SizeType b_i;
    ::coder::SizeType b_us;
    ::coder::SizeType ncols;
    ::coder::SizeType nrblks;
    ::coder::SizeType src;
    ::coder::SizeType trg;
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        b_us = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          ::coder::SizeType i1;
          if (b1 || (i >= b_i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[i % i1 * b_wls->us.size(1) + i / i1] = us[b_us] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        b_wls->origin[2] = us[2];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        b_us = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          ::coder::SizeType i1;
          if (b1 || (i >= b_i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[i % i1 * b_wls->us.size(1) + i / i1] = us[b_us];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        b_wls->origin[2] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      b_i = b_wls->us.size(0);
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[i % b_i * b_wls->us.size(1) + i / b_i]));
      }
      break;
    case 2:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * i + 1])));
      }
      break;
    default:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                                std::abs(b_wls->us[b_wls->us.size(1) * i + 1])),
                      std::abs(b_wls->us[b_wls->us.size(1) * i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (::coder::SizeType i{0}; i <= dim; i++) {
      b_wls->hs_inv[i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
        }
        break;
      case 2:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
        }
        break;
      default:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 2] =
              b_wls->us[b_wls->us.size(1) * i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight.size(1) == 0) || (weight[0] == 'U')) && (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight.size(1) == 0) || (weight[0] == 'U')) {
        //  unit weights
        b_us = b_wls->rweights.size(0);
        b_wls->rweights.set_size(b_us);
        for (b_i = 0; b_i < b_us; b_i++) {
          b_wls->rweights[b_i] = 1.0;
        }
      } else if ((weight[0] == 'I') || (weight[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree, b_wls->rweights);
      } else {
        if ((weight[0] != 'B') && (weight[0] != 'b')) {
          m2cErrMsgIdAndTxt("wlslib:WrongWeightName",
                            "When using a character string, weighting scheme "
                            "must be Unit, InvDist, or Buhmann.");
        }
        //  Buhmann weights with default parameters
        b_wls_buhmann_weights(b_wls->us, us.size(0), degree, unimono,
                              b_wls->rweights);
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      timestamp = static_cast<std::chrono::duration<double>>(
                      std::chrono::system_clock::now().time_since_epoch())
                      .count();
    }
    //  Compute Vandermonde system
    c_gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, unimono,
                 b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_i = b_wls->V.size(0);
          for (::coder::SizeType j{0}; j < b_i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    //  Omit rows in CVM if needed
    if (b_wls->runtimes.size(0) != 0) {
      real_T timestamp1;
      timestamp1 = static_cast<std::chrono::duration<double>>(
                       std::chrono::system_clock::now().time_since_epoch())
                       .count();
      b_wls->runtimes[0] = timestamp1 - timestamp;
      timestamp = timestamp1;
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        ::coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (::coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          b_i = us.size(1) + 2;
          for (::coder::SizeType blk{b_i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (::coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        d_gen_vander(b_wls->hs_inv, order, b_wls->V);
        for (::coder::SizeType blk{2}; blk <= nrblks; blk++) {
          ::coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (::coder::SizeType i{0}; i <= nstpnts; i++) {
            b_wls->rweights[trg + i] = b_wls->rweights[src + i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T t;
      t = static_cast<std::chrono::duration<double>>(
              std::chrono::system_clock::now().time_since_epoch())
              .count();
      b_wls->runtimes[1] = t - timestamp;
    }
  }
}

void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const ::coder::array<char_T, 2U> &weight,
              ::coder::SizeType degree, ::coder::SizeType order,
              ::coder::SizeType interp0, boolean_T unimono,
              ::coder::SizeType nstpnts)
{
  real_T timestamp;
  ::coder::SizeType dim;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  b_wls->interp0 = interp0;
  b_wls->unimono = unimono;
  if (nstpnts <= 0) {
    nstpnts = us.size(0);
  } else {
    m2cAssert(
        nstpnts <= us.size(0),
        "Number of points cannot be greater than the first dimension of `us`.");
  }
  if (unimono && (!onaxes(us, nstpnts))) {
    m2cErrMsgIdAndTxt(
        "wlslib:NotAxesAlignedStencils",
        "To use univariate-monomial mode, all points must be on axes.");
  }
  //  Resize buffers
  wls_resize(b_wls, us.size(1), nstpnts, degree, order);
  if (nstpnts != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    ::coder::SizeType b_i;
    ::coder::SizeType b_us;
    ::coder::SizeType ncols;
    ::coder::SizeType nrblks;
    ::coder::SizeType src;
    ::coder::SizeType trg;
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = us[0];
        b = true;
        b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
        b_i = us.size(1) * us.size(0);
        b_us = 0;
        for (::coder::SizeType i{0}; i < nstpnts; i++) {
          ::coder::SizeType i1;
          if (b1 || (i >= b_i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[i % i1 * b_wls->us.size(1) + i / i1] = us[b_us] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        for (::coder::SizeType i{0}; i < nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        b_wls->origin[2] = us[2];
        for (::coder::SizeType i{0}; i < nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = 0.0;
        b = true;
        b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
        b_i = us.size(1) * us.size(0);
        b_us = 0;
        for (::coder::SizeType i{0}; i < nstpnts; i++) {
          ::coder::SizeType i1;
          if (b1 || (i >= b_i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[i % i1 * b_wls->us.size(1) + i / i1] = us[b_us];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        for (::coder::SizeType i{0}; i < nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        b_wls->origin[2] = 0.0;
        for (::coder::SizeType i{0}; i < nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      b_i = b_wls->us.size(0);
      for (::coder::SizeType i{0}; i < nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[i % b_i * b_wls->us.size(1) + i / b_i]));
      }
      break;
    case 2:
      for (::coder::SizeType i{0}; i < nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * i + 1])));
      }
      break;
    default:
      for (::coder::SizeType i{0}; i < nstpnts; i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                                std::abs(b_wls->us[b_wls->us.size(1) * i + 1])),
                      std::abs(b_wls->us[b_wls->us.size(1) * i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (::coder::SizeType i{0}; i <= dim; i++) {
      b_wls->hs_inv[i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (::coder::SizeType i{0}; i < nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
        }
        break;
      case 2:
        for (::coder::SizeType i{0}; i < nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
        }
        break;
      default:
        for (::coder::SizeType i{0}; i < nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 2] =
              b_wls->us[b_wls->us.size(1) * i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight.size(1) == 0) || (weight[0] == 'U')) && (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight.size(1) == 0) || (weight[0] == 'U')) {
        //  unit weights
        b_us = b_wls->rweights.size(0);
        b_wls->rweights.set_size(b_us);
        for (b_i = 0; b_i < b_us; b_i++) {
          b_wls->rweights[b_i] = 1.0;
        }
      } else if ((weight[0] == 'I') || (weight[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, nstpnts, degree, b_wls->rweights);
      } else {
        if ((weight[0] != 'B') && (weight[0] != 'b')) {
          m2cErrMsgIdAndTxt("wlslib:WrongWeightName",
                            "When using a character string, weighting scheme "
                            "must be Unit, InvDist, or Buhmann.");
        }
        //  Buhmann weights with default parameters
        b_wls_buhmann_weights(b_wls->us, nstpnts, degree, unimono,
                              b_wls->rweights);
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      timestamp = static_cast<std::chrono::duration<double>>(
                      std::chrono::system_clock::now().time_since_epoch())
                      .count();
    }
    //  Compute Vandermonde system
    c_gen_vander(b_wls->us, nstpnts, degree, order, b_wls->rweights, unimono,
                 b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (nstpnts != b_wls->stride) &&
        (nstpnts != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = nstpnts;
      for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (::coder::SizeType i{0}; i < nstpnts; i++) {
          b_i = b_wls->V.size(0);
          for (::coder::SizeType j{0}; j < b_i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    //  Omit rows in CVM if needed
    if (b_wls->runtimes.size(0) != 0) {
      real_T timestamp1;
      timestamp1 = static_cast<std::chrono::duration<double>>(
                       std::chrono::system_clock::now().time_since_epoch())
                       .count();
      b_wls->runtimes[0] = timestamp1 - timestamp;
      timestamp = timestamp1;
    }
    b_wls->nrows = nrblks * nstpnts;
    b_wls->ncols = ncols;
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        ::coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (::coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j < nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          b_i = us.size(1) + 2;
          for (::coder::SizeType blk{b_i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (::coder::SizeType j{0}; j < nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        d_gen_vander(b_wls->hs_inv, order, b_wls->V);
        for (::coder::SizeType blk{2}; blk <= nrblks; blk++) {
          ::coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j < nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (nstpnts != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = nstpnts;
        for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (::coder::SizeType i{0}; i < nstpnts; i++) {
            b_wls->rweights[trg + i] = b_wls->rweights[src + i];
          }
          trg += nstpnts;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T t;
      t = static_cast<std::chrono::duration<double>>(
              std::chrono::system_clock::now().time_since_epoch())
              .count();
      b_wls->runtimes[1] = t - timestamp;
    }
  }
}

//  wls_init  Initialize WlsObject in 1D, 2D, or 3D.
void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us)
{
  real_T timestamp;
  ::coder::SizeType degree;
  ::coder::SizeType dim;
  ::coder::SizeType interp0;
  ::coder::SizeType nstpnts;
  ::coder::SizeType order;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  degree = b_wls->degree;
  order = b_wls->order;
  interp0 = b_wls->interp0;
  nstpnts = us.size(0) - 1;
  if (b_wls->unimono && (!onaxes(us, us.size(0)))) {
    m2cErrMsgIdAndTxt(
        "wlslib:NotAxesAlignedStencils",
        "To use univariate-monomial mode, all points must be on axes.");
  }
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), b_wls->degree, b_wls->order);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    ::coder::SizeType b_i;
    ::coder::SizeType loop_ub;
    ::coder::SizeType ncols;
    ::coder::SizeType nrblks;
    ::coder::SizeType src;
    ::coder::SizeType trg;
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        loop_ub = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          ::coder::SizeType i1;
          if (b1 || (i >= b_i)) {
            loop_ub = 0;
            b = true;
          } else if (b) {
            b = false;
            loop_ub = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (loop_ub > MAX_int32_T - us.size(1)) {
              loop_ub = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              loop_ub += us.size(1);
              if (loop_ub > i1) {
                loop_ub -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[i % i1 * b_wls->us.size(1) + i / i1] = us[loop_ub] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        b_wls->origin[2] = us[2];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        loop_ub = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          ::coder::SizeType i1;
          if (b1 || (i >= b_i)) {
            loop_ub = 0;
            b = true;
          } else if (b) {
            b = false;
            loop_ub = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (loop_ub > MAX_int32_T - us.size(1)) {
              loop_ub = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              loop_ub += us.size(1);
              if (loop_ub > i1) {
                loop_ub -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[i % i1 * b_wls->us.size(1) + i / i1] = us[loop_ub];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        b_wls->origin[2] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      b_i = b_wls->us.size(0);
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[i % b_i * b_wls->us.size(1) + i / b_i]));
      }
      break;
    case 2:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * i + 1])));
      }
      break;
    default:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                                std::abs(b_wls->us[b_wls->us.size(1) * i + 1])),
                      std::abs(b_wls->us[b_wls->us.size(1) * i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (::coder::SizeType i{0}; i <= dim; i++) {
      b_wls->hs_inv[i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
        }
        break;
      case 2:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
        }
        break;
      default:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 2] =
              b_wls->us[b_wls->us.size(1) * i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (order == 0) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      loop_ub = b_wls->rweights.size(0);
      for (b_i = 0; b_i < loop_ub; b_i++) {
        b_wls->rweights[b_i] = 1.0;
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      timestamp = static_cast<std::chrono::duration<double>>(
                      std::chrono::system_clock::now().time_since_epoch())
                      .count();
    }
    //  Compute Vandermonde system
    c_gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights,
                 b_wls->unimono, b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_i = b_wls->V.size(0);
          for (::coder::SizeType j{0}; j < b_i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    //  Omit rows in CVM if needed
    if (b_wls->runtimes.size(0) != 0) {
      real_T timestamp1;
      timestamp1 = static_cast<std::chrono::duration<double>>(
                       std::chrono::system_clock::now().time_since_epoch())
                       .count();
      b_wls->runtimes[0] = timestamp1 - timestamp;
      timestamp = timestamp1;
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        ::coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (::coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          b_i = us.size(1) + 2;
          for (::coder::SizeType blk{b_i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (::coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        d_gen_vander(b_wls->hs_inv, order, b_wls->V);
        for (::coder::SizeType blk{2}; blk <= nrblks; blk++) {
          ::coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (::coder::SizeType i{0}; i <= nstpnts; i++) {
            b_wls->rweights[trg + i] = b_wls->rweights[src + i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T t;
      t = static_cast<std::chrono::duration<double>>(
              std::chrono::system_clock::now().time_since_epoch())
              .count();
      b_wls->runtimes[1] = t - timestamp;
    }
  }
}

//  wls_init  Initialize WlsObject in 1D, 2D, or 3D.
void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const WlsWeight *weight)
{
  real_T timestamp;
  ::coder::SizeType degree;
  ::coder::SizeType dim;
  ::coder::SizeType interp0;
  ::coder::SizeType nstpnts;
  ::coder::SizeType order;
  boolean_T unimono;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  degree = b_wls->degree;
  order = b_wls->order;
  interp0 = b_wls->interp0;
  unimono = b_wls->unimono;
  nstpnts = us.size(0) - 1;
  if (b_wls->unimono && (!onaxes(us, us.size(0)))) {
    m2cErrMsgIdAndTxt(
        "wlslib:NotAxesAlignedStencils",
        "To use univariate-monomial mode, all points must be on axes.");
  }
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), b_wls->degree, b_wls->order);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    ::coder::SizeType b_i;
    ::coder::SizeType loop_ub;
    ::coder::SizeType ncols;
    ::coder::SizeType nrblks;
    ::coder::SizeType src;
    ::coder::SizeType trg;
    ::coder::SizeType u0;
    ::coder::SizeType u1;
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        u0 = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          if (b1 || (i >= b_i)) {
            u0 = 0;
            b = true;
          } else if (b) {
            b = false;
            u0 = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            loop_ub = us.size(1) * us.size(0) - 1;
            if (u0 > MAX_int32_T - us.size(1)) {
              u0 = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              u0 += us.size(1);
              if (u0 > loop_ub) {
                u0 -= loop_ub;
              }
            }
          }
          loop_ub = b_wls->us.size(0);
          b_wls->us[i % loop_ub * b_wls->us.size(1) + i / loop_ub] =
              us[u0] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        b_wls->origin[2] = us[2];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        u0 = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          if (b1 || (i >= b_i)) {
            u0 = 0;
            b = true;
          } else if (b) {
            b = false;
            u0 = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            loop_ub = us.size(1) * us.size(0) - 1;
            if (u0 > MAX_int32_T - us.size(1)) {
              u0 = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              u0 += us.size(1);
              if (u0 > loop_ub) {
                u0 -= loop_ub;
              }
            }
          }
          loop_ub = b_wls->us.size(0);
          b_wls->us[i % loop_ub * b_wls->us.size(1) + i / loop_ub] = us[u0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        b_wls->origin[2] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      b_i = b_wls->us.size(0);
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[i % b_i * b_wls->us.size(1) + i / b_i]));
      }
      break;
    case 2:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * i + 1])));
      }
      break;
    default:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                                std::abs(b_wls->us[b_wls->us.size(1) * i + 1])),
                      std::abs(b_wls->us[b_wls->us.size(1) * i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (::coder::SizeType i{0}; i <= dim; i++) {
      b_wls->hs_inv[i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
        }
        break;
      case 2:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
        }
        break;
      default:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 2] =
              b_wls->us[b_wls->us.size(1) * i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight->name.size(1) == 0) || (weight->name[0] == 'U')) &&
        (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight->name.size(1) == 0) || (weight->name[0] == 'U')) {
        //  unit weights
        loop_ub = b_wls->rweights.size(0);
        for (b_i = 0; b_i < loop_ub; b_i++) {
          b_wls->rweights[b_i] = 1.0;
        }
      } else if ((weight->name[0] == 'I') || (weight->name[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else if ((weight->name[0] == 'B') || (weight->name[0] == 'b')) {
        //  Buhmann weights. All points share same parameters
        wls_buhmann_weights(b_wls->us, us.size(0), degree, unimono,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else {
        if ((weight->name[0] != 'E') && (weight->name[0] != 'e')) {
          m2cErrMsgIdAndTxt(
              "wlslib:WrongWeightName",
              "Weighting scheme must be Unit, InvDist, Buhmann, or ENO.");
        }
        //  WLS-ENO
        wls_eno_weights(b_wls->us, us.size(0), degree, us,
                        weight->params_shared, weight->params_pointwise,
                        b_wls->rweights);
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      timestamp = static_cast<std::chrono::duration<double>>(
                      std::chrono::system_clock::now().time_since_epoch())
                      .count();
    }
    //  Compute Vandermonde system
    c_gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, unimono,
                 b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_i = b_wls->V.size(0);
          for (::coder::SizeType j{0}; j < b_i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    //  Omit rows in CVM if needed
    u0 = weight->omit_rows.size(0);
    u1 = b_wls->nrows;
    if (u0 <= u1) {
      u1 = u0;
    }
    for (::coder::SizeType i{0}; i < u1; i++) {
      if (weight->omit_rows[i]) {
        loop_ub = b_wls->V.size(0);
        for (b_i = 0; b_i < loop_ub; b_i++) {
          b_wls->V[i + b_wls->V.size(1) * b_i] = 0.0;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T timestamp1;
      timestamp1 = static_cast<std::chrono::duration<double>>(
                       std::chrono::system_clock::now().time_since_epoch())
                       .count();
      b_wls->runtimes[0] = timestamp1 - timestamp;
      timestamp = timestamp1;
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        ::coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (::coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          b_i = us.size(1) + 2;
          for (::coder::SizeType blk{b_i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (::coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        d_gen_vander(b_wls->hs_inv, order, b_wls->V);
        for (::coder::SizeType blk{2}; blk <= nrblks; blk++) {
          ::coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (::coder::SizeType i{0}; i <= nstpnts; i++) {
            b_wls->rweights[trg + i] = b_wls->rweights[src + i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T t;
      t = static_cast<std::chrono::duration<double>>(
              std::chrono::system_clock::now().time_since_epoch())
              .count();
      b_wls->runtimes[1] = t - timestamp;
    }
  }
}

//  wls_init  Initialize WlsObject in 1D, 2D, or 3D.
void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const WlsWeight *weight, ::coder::SizeType degree)
{
  real_T timestamp;
  ::coder::SizeType dim;
  ::coder::SizeType interp0;
  ::coder::SizeType nstpnts;
  ::coder::SizeType order;
  boolean_T unimono;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  order = b_wls->order;
  interp0 = b_wls->interp0;
  unimono = b_wls->unimono;
  nstpnts = us.size(0) - 1;
  if (b_wls->unimono && (!onaxes(us, us.size(0)))) {
    m2cErrMsgIdAndTxt(
        "wlslib:NotAxesAlignedStencils",
        "To use univariate-monomial mode, all points must be on axes.");
  }
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), degree, b_wls->order);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    ::coder::SizeType b_i;
    ::coder::SizeType loop_ub;
    ::coder::SizeType ncols;
    ::coder::SizeType nrblks;
    ::coder::SizeType src;
    ::coder::SizeType trg;
    ::coder::SizeType u0;
    ::coder::SizeType u1;
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        u0 = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          if (b1 || (i >= b_i)) {
            u0 = 0;
            b = true;
          } else if (b) {
            b = false;
            u0 = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            loop_ub = us.size(1) * us.size(0) - 1;
            if (u0 > MAX_int32_T - us.size(1)) {
              u0 = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              u0 += us.size(1);
              if (u0 > loop_ub) {
                u0 -= loop_ub;
              }
            }
          }
          loop_ub = b_wls->us.size(0);
          b_wls->us[i % loop_ub * b_wls->us.size(1) + i / loop_ub] =
              us[u0] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        b_wls->origin[2] = us[2];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        u0 = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          if (b1 || (i >= b_i)) {
            u0 = 0;
            b = true;
          } else if (b) {
            b = false;
            u0 = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            loop_ub = us.size(1) * us.size(0) - 1;
            if (u0 > MAX_int32_T - us.size(1)) {
              u0 = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              u0 += us.size(1);
              if (u0 > loop_ub) {
                u0 -= loop_ub;
              }
            }
          }
          loop_ub = b_wls->us.size(0);
          b_wls->us[i % loop_ub * b_wls->us.size(1) + i / loop_ub] = us[u0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        b_wls->origin[2] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      b_i = b_wls->us.size(0);
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[i % b_i * b_wls->us.size(1) + i / b_i]));
      }
      break;
    case 2:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * i + 1])));
      }
      break;
    default:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                                std::abs(b_wls->us[b_wls->us.size(1) * i + 1])),
                      std::abs(b_wls->us[b_wls->us.size(1) * i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (::coder::SizeType i{0}; i <= dim; i++) {
      b_wls->hs_inv[i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
        }
        break;
      case 2:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
        }
        break;
      default:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 2] =
              b_wls->us[b_wls->us.size(1) * i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight->name.size(1) == 0) || (weight->name[0] == 'U')) &&
        (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight->name.size(1) == 0) || (weight->name[0] == 'U')) {
        //  unit weights
        loop_ub = b_wls->rweights.size(0);
        for (b_i = 0; b_i < loop_ub; b_i++) {
          b_wls->rweights[b_i] = 1.0;
        }
      } else if ((weight->name[0] == 'I') || (weight->name[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else if ((weight->name[0] == 'B') || (weight->name[0] == 'b')) {
        //  Buhmann weights. All points share same parameters
        wls_buhmann_weights(b_wls->us, us.size(0), degree, unimono,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else {
        if ((weight->name[0] != 'E') && (weight->name[0] != 'e')) {
          m2cErrMsgIdAndTxt(
              "wlslib:WrongWeightName",
              "Weighting scheme must be Unit, InvDist, Buhmann, or ENO.");
        }
        //  WLS-ENO
        wls_eno_weights(b_wls->us, us.size(0), degree, us,
                        weight->params_shared, weight->params_pointwise,
                        b_wls->rweights);
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      timestamp = static_cast<std::chrono::duration<double>>(
                      std::chrono::system_clock::now().time_since_epoch())
                      .count();
    }
    //  Compute Vandermonde system
    c_gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, unimono,
                 b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_i = b_wls->V.size(0);
          for (::coder::SizeType j{0}; j < b_i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    //  Omit rows in CVM if needed
    u0 = weight->omit_rows.size(0);
    u1 = b_wls->nrows;
    if (u0 <= u1) {
      u1 = u0;
    }
    for (::coder::SizeType i{0}; i < u1; i++) {
      if (weight->omit_rows[i]) {
        loop_ub = b_wls->V.size(0);
        for (b_i = 0; b_i < loop_ub; b_i++) {
          b_wls->V[i + b_wls->V.size(1) * b_i] = 0.0;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T timestamp1;
      timestamp1 = static_cast<std::chrono::duration<double>>(
                       std::chrono::system_clock::now().time_since_epoch())
                       .count();
      b_wls->runtimes[0] = timestamp1 - timestamp;
      timestamp = timestamp1;
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        ::coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (::coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          b_i = us.size(1) + 2;
          for (::coder::SizeType blk{b_i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (::coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        d_gen_vander(b_wls->hs_inv, order, b_wls->V);
        for (::coder::SizeType blk{2}; blk <= nrblks; blk++) {
          ::coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (::coder::SizeType i{0}; i <= nstpnts; i++) {
            b_wls->rweights[trg + i] = b_wls->rweights[src + i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T t;
      t = static_cast<std::chrono::duration<double>>(
              std::chrono::system_clock::now().time_since_epoch())
              .count();
      b_wls->runtimes[1] = t - timestamp;
    }
  }
}

//  wls_init  Initialize WlsObject in 1D, 2D, or 3D.
void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const WlsWeight *weight, ::coder::SizeType degree,
              ::coder::SizeType order)
{
  real_T timestamp;
  ::coder::SizeType dim;
  ::coder::SizeType interp0;
  ::coder::SizeType nstpnts;
  boolean_T unimono;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  interp0 = b_wls->interp0;
  unimono = b_wls->unimono;
  nstpnts = us.size(0) - 1;
  if (b_wls->unimono && (!onaxes(us, us.size(0)))) {
    m2cErrMsgIdAndTxt(
        "wlslib:NotAxesAlignedStencils",
        "To use univariate-monomial mode, all points must be on axes.");
  }
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), degree, order);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    ::coder::SizeType b_i;
    ::coder::SizeType loop_ub;
    ::coder::SizeType ncols;
    ::coder::SizeType nrblks;
    ::coder::SizeType src;
    ::coder::SizeType trg;
    ::coder::SizeType u0;
    ::coder::SizeType u1;
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        u0 = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          if (b1 || (i >= b_i)) {
            u0 = 0;
            b = true;
          } else if (b) {
            b = false;
            u0 = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            loop_ub = us.size(1) * us.size(0) - 1;
            if (u0 > MAX_int32_T - us.size(1)) {
              u0 = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              u0 += us.size(1);
              if (u0 > loop_ub) {
                u0 -= loop_ub;
              }
            }
          }
          loop_ub = b_wls->us.size(0);
          b_wls->us[i % loop_ub * b_wls->us.size(1) + i / loop_ub] =
              us[u0] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        b_wls->origin[2] = us[2];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        u0 = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          if (b1 || (i >= b_i)) {
            u0 = 0;
            b = true;
          } else if (b) {
            b = false;
            u0 = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            loop_ub = us.size(1) * us.size(0) - 1;
            if (u0 > MAX_int32_T - us.size(1)) {
              u0 = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              u0 += us.size(1);
              if (u0 > loop_ub) {
                u0 -= loop_ub;
              }
            }
          }
          loop_ub = b_wls->us.size(0);
          b_wls->us[i % loop_ub * b_wls->us.size(1) + i / loop_ub] = us[u0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        b_wls->origin[2] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      b_i = b_wls->us.size(0);
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[i % b_i * b_wls->us.size(1) + i / b_i]));
      }
      break;
    case 2:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * i + 1])));
      }
      break;
    default:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                                std::abs(b_wls->us[b_wls->us.size(1) * i + 1])),
                      std::abs(b_wls->us[b_wls->us.size(1) * i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (::coder::SizeType i{0}; i <= dim; i++) {
      b_wls->hs_inv[i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
        }
        break;
      case 2:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
        }
        break;
      default:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 2] =
              b_wls->us[b_wls->us.size(1) * i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight->name.size(1) == 0) || (weight->name[0] == 'U')) &&
        (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight->name.size(1) == 0) || (weight->name[0] == 'U')) {
        //  unit weights
        loop_ub = b_wls->rweights.size(0);
        for (b_i = 0; b_i < loop_ub; b_i++) {
          b_wls->rweights[b_i] = 1.0;
        }
      } else if ((weight->name[0] == 'I') || (weight->name[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else if ((weight->name[0] == 'B') || (weight->name[0] == 'b')) {
        //  Buhmann weights. All points share same parameters
        wls_buhmann_weights(b_wls->us, us.size(0), degree, unimono,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else {
        if ((weight->name[0] != 'E') && (weight->name[0] != 'e')) {
          m2cErrMsgIdAndTxt(
              "wlslib:WrongWeightName",
              "Weighting scheme must be Unit, InvDist, Buhmann, or ENO.");
        }
        //  WLS-ENO
        wls_eno_weights(b_wls->us, us.size(0), degree, us,
                        weight->params_shared, weight->params_pointwise,
                        b_wls->rweights);
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      timestamp = static_cast<std::chrono::duration<double>>(
                      std::chrono::system_clock::now().time_since_epoch())
                      .count();
    }
    //  Compute Vandermonde system
    c_gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, unimono,
                 b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_i = b_wls->V.size(0);
          for (::coder::SizeType j{0}; j < b_i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    //  Omit rows in CVM if needed
    u0 = weight->omit_rows.size(0);
    u1 = b_wls->nrows;
    if (u0 <= u1) {
      u1 = u0;
    }
    for (::coder::SizeType i{0}; i < u1; i++) {
      if (weight->omit_rows[i]) {
        loop_ub = b_wls->V.size(0);
        for (b_i = 0; b_i < loop_ub; b_i++) {
          b_wls->V[i + b_wls->V.size(1) * b_i] = 0.0;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T timestamp1;
      timestamp1 = static_cast<std::chrono::duration<double>>(
                       std::chrono::system_clock::now().time_since_epoch())
                       .count();
      b_wls->runtimes[0] = timestamp1 - timestamp;
      timestamp = timestamp1;
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        ::coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (::coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          b_i = us.size(1) + 2;
          for (::coder::SizeType blk{b_i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (::coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        d_gen_vander(b_wls->hs_inv, order, b_wls->V);
        for (::coder::SizeType blk{2}; blk <= nrblks; blk++) {
          ::coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (::coder::SizeType i{0}; i <= nstpnts; i++) {
            b_wls->rweights[trg + i] = b_wls->rweights[src + i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T t;
      t = static_cast<std::chrono::duration<double>>(
              std::chrono::system_clock::now().time_since_epoch())
              .count();
      b_wls->runtimes[1] = t - timestamp;
    }
  }
}

//  wls_init  Initialize WlsObject in 1D, 2D, or 3D.
void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const WlsWeight *weight, ::coder::SizeType degree,
              ::coder::SizeType order, ::coder::SizeType interp0)
{
  real_T timestamp;
  ::coder::SizeType dim;
  ::coder::SizeType nstpnts;
  boolean_T unimono;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  b_wls->interp0 = interp0;
  unimono = b_wls->unimono;
  nstpnts = us.size(0) - 1;
  if (b_wls->unimono && (!onaxes(us, us.size(0)))) {
    m2cErrMsgIdAndTxt(
        "wlslib:NotAxesAlignedStencils",
        "To use univariate-monomial mode, all points must be on axes.");
  }
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), degree, order);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    ::coder::SizeType b_i;
    ::coder::SizeType loop_ub;
    ::coder::SizeType ncols;
    ::coder::SizeType nrblks;
    ::coder::SizeType src;
    ::coder::SizeType trg;
    ::coder::SizeType u0;
    ::coder::SizeType u1;
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        u0 = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          if (b1 || (i >= b_i)) {
            u0 = 0;
            b = true;
          } else if (b) {
            b = false;
            u0 = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            loop_ub = us.size(1) * us.size(0) - 1;
            if (u0 > MAX_int32_T - us.size(1)) {
              u0 = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              u0 += us.size(1);
              if (u0 > loop_ub) {
                u0 -= loop_ub;
              }
            }
          }
          loop_ub = b_wls->us.size(0);
          b_wls->us[i % loop_ub * b_wls->us.size(1) + i / loop_ub] =
              us[u0] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        b_wls->origin[2] = us[2];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        u0 = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          if (b1 || (i >= b_i)) {
            u0 = 0;
            b = true;
          } else if (b) {
            b = false;
            u0 = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            loop_ub = us.size(1) * us.size(0) - 1;
            if (u0 > MAX_int32_T - us.size(1)) {
              u0 = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              u0 += us.size(1);
              if (u0 > loop_ub) {
                u0 -= loop_ub;
              }
            }
          }
          loop_ub = b_wls->us.size(0);
          b_wls->us[i % loop_ub * b_wls->us.size(1) + i / loop_ub] = us[u0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        b_wls->origin[2] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      b_i = b_wls->us.size(0);
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[i % b_i * b_wls->us.size(1) + i / b_i]));
      }
      break;
    case 2:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * i + 1])));
      }
      break;
    default:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                                std::abs(b_wls->us[b_wls->us.size(1) * i + 1])),
                      std::abs(b_wls->us[b_wls->us.size(1) * i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (::coder::SizeType i{0}; i <= dim; i++) {
      b_wls->hs_inv[i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
        }
        break;
      case 2:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
        }
        break;
      default:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 2] =
              b_wls->us[b_wls->us.size(1) * i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight->name.size(1) == 0) || (weight->name[0] == 'U')) &&
        (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight->name.size(1) == 0) || (weight->name[0] == 'U')) {
        //  unit weights
        loop_ub = b_wls->rweights.size(0);
        for (b_i = 0; b_i < loop_ub; b_i++) {
          b_wls->rweights[b_i] = 1.0;
        }
      } else if ((weight->name[0] == 'I') || (weight->name[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else if ((weight->name[0] == 'B') || (weight->name[0] == 'b')) {
        //  Buhmann weights. All points share same parameters
        wls_buhmann_weights(b_wls->us, us.size(0), degree, unimono,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else {
        if ((weight->name[0] != 'E') && (weight->name[0] != 'e')) {
          m2cErrMsgIdAndTxt(
              "wlslib:WrongWeightName",
              "Weighting scheme must be Unit, InvDist, Buhmann, or ENO.");
        }
        //  WLS-ENO
        wls_eno_weights(b_wls->us, us.size(0), degree, us,
                        weight->params_shared, weight->params_pointwise,
                        b_wls->rweights);
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      timestamp = static_cast<std::chrono::duration<double>>(
                      std::chrono::system_clock::now().time_since_epoch())
                      .count();
    }
    //  Compute Vandermonde system
    c_gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, unimono,
                 b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_i = b_wls->V.size(0);
          for (::coder::SizeType j{0}; j < b_i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    //  Omit rows in CVM if needed
    u0 = weight->omit_rows.size(0);
    u1 = b_wls->nrows;
    if (u0 <= u1) {
      u1 = u0;
    }
    for (::coder::SizeType i{0}; i < u1; i++) {
      if (weight->omit_rows[i]) {
        loop_ub = b_wls->V.size(0);
        for (b_i = 0; b_i < loop_ub; b_i++) {
          b_wls->V[i + b_wls->V.size(1) * b_i] = 0.0;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T timestamp1;
      timestamp1 = static_cast<std::chrono::duration<double>>(
                       std::chrono::system_clock::now().time_since_epoch())
                       .count();
      b_wls->runtimes[0] = timestamp1 - timestamp;
      timestamp = timestamp1;
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        ::coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (::coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          b_i = us.size(1) + 2;
          for (::coder::SizeType blk{b_i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (::coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        d_gen_vander(b_wls->hs_inv, order, b_wls->V);
        for (::coder::SizeType blk{2}; blk <= nrblks; blk++) {
          ::coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (::coder::SizeType i{0}; i <= nstpnts; i++) {
            b_wls->rweights[trg + i] = b_wls->rweights[src + i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T t;
      t = static_cast<std::chrono::duration<double>>(
              std::chrono::system_clock::now().time_since_epoch())
              .count();
      b_wls->runtimes[1] = t - timestamp;
    }
  }
}

//  wls_init  Initialize WlsObject in 1D, 2D, or 3D.
void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const WlsWeight *weight, ::coder::SizeType degree,
              ::coder::SizeType order, ::coder::SizeType interp0,
              boolean_T unimono)
{
  real_T timestamp;
  ::coder::SizeType dim;
  ::coder::SizeType nstpnts;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  b_wls->interp0 = interp0;
  b_wls->unimono = unimono;
  nstpnts = us.size(0) - 1;
  if (unimono && (!onaxes(us, us.size(0)))) {
    m2cErrMsgIdAndTxt(
        "wlslib:NotAxesAlignedStencils",
        "To use univariate-monomial mode, all points must be on axes.");
  }
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), degree, order);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    ::coder::SizeType b_i;
    ::coder::SizeType loop_ub;
    ::coder::SizeType ncols;
    ::coder::SizeType nrblks;
    ::coder::SizeType src;
    ::coder::SizeType trg;
    ::coder::SizeType u0;
    ::coder::SizeType u1;
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        u0 = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          if (b1 || (i >= b_i)) {
            u0 = 0;
            b = true;
          } else if (b) {
            b = false;
            u0 = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            loop_ub = us.size(1) * us.size(0) - 1;
            if (u0 > MAX_int32_T - us.size(1)) {
              u0 = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              u0 += us.size(1);
              if (u0 > loop_ub) {
                u0 -= loop_ub;
              }
            }
          }
          loop_ub = b_wls->us.size(0);
          b_wls->us[i % loop_ub * b_wls->us.size(1) + i / loop_ub] =
              us[u0] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        b_wls->origin[2] = us[2];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        u0 = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          if (b1 || (i >= b_i)) {
            u0 = 0;
            b = true;
          } else if (b) {
            b = false;
            u0 = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            loop_ub = us.size(1) * us.size(0) - 1;
            if (u0 > MAX_int32_T - us.size(1)) {
              u0 = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              u0 += us.size(1);
              if (u0 > loop_ub) {
                u0 -= loop_ub;
              }
            }
          }
          loop_ub = b_wls->us.size(0);
          b_wls->us[i % loop_ub * b_wls->us.size(1) + i / loop_ub] = us[u0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        b_wls->origin[2] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      b_i = b_wls->us.size(0);
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[i % b_i * b_wls->us.size(1) + i / b_i]));
      }
      break;
    case 2:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * i + 1])));
      }
      break;
    default:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                                std::abs(b_wls->us[b_wls->us.size(1) * i + 1])),
                      std::abs(b_wls->us[b_wls->us.size(1) * i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (::coder::SizeType i{0}; i <= dim; i++) {
      b_wls->hs_inv[i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
        }
        break;
      case 2:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
        }
        break;
      default:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 2] =
              b_wls->us[b_wls->us.size(1) * i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight->name.size(1) == 0) || (weight->name[0] == 'U')) &&
        (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight->name.size(1) == 0) || (weight->name[0] == 'U')) {
        //  unit weights
        loop_ub = b_wls->rweights.size(0);
        for (b_i = 0; b_i < loop_ub; b_i++) {
          b_wls->rweights[b_i] = 1.0;
        }
      } else if ((weight->name[0] == 'I') || (weight->name[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else if ((weight->name[0] == 'B') || (weight->name[0] == 'b')) {
        //  Buhmann weights. All points share same parameters
        wls_buhmann_weights(b_wls->us, us.size(0), degree, unimono,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else {
        if ((weight->name[0] != 'E') && (weight->name[0] != 'e')) {
          m2cErrMsgIdAndTxt(
              "wlslib:WrongWeightName",
              "Weighting scheme must be Unit, InvDist, Buhmann, or ENO.");
        }
        //  WLS-ENO
        wls_eno_weights(b_wls->us, us.size(0), degree, us,
                        weight->params_shared, weight->params_pointwise,
                        b_wls->rweights);
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      timestamp = static_cast<std::chrono::duration<double>>(
                      std::chrono::system_clock::now().time_since_epoch())
                      .count();
    }
    //  Compute Vandermonde system
    c_gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, unimono,
                 b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_i = b_wls->V.size(0);
          for (::coder::SizeType j{0}; j < b_i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    //  Omit rows in CVM if needed
    u0 = weight->omit_rows.size(0);
    u1 = b_wls->nrows;
    if (u0 <= u1) {
      u1 = u0;
    }
    for (::coder::SizeType i{0}; i < u1; i++) {
      if (weight->omit_rows[i]) {
        loop_ub = b_wls->V.size(0);
        for (b_i = 0; b_i < loop_ub; b_i++) {
          b_wls->V[i + b_wls->V.size(1) * b_i] = 0.0;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T timestamp1;
      timestamp1 = static_cast<std::chrono::duration<double>>(
                       std::chrono::system_clock::now().time_since_epoch())
                       .count();
      b_wls->runtimes[0] = timestamp1 - timestamp;
      timestamp = timestamp1;
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        ::coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (::coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          b_i = us.size(1) + 2;
          for (::coder::SizeType blk{b_i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (::coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        d_gen_vander(b_wls->hs_inv, order, b_wls->V);
        for (::coder::SizeType blk{2}; blk <= nrblks; blk++) {
          ::coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (::coder::SizeType i{0}; i <= nstpnts; i++) {
            b_wls->rweights[trg + i] = b_wls->rweights[src + i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T t;
      t = static_cast<std::chrono::duration<double>>(
              std::chrono::system_clock::now().time_since_epoch())
              .count();
      b_wls->runtimes[1] = t - timestamp;
    }
  }
}

//  wls_init  Initialize WlsObject in 1D, 2D, or 3D.
void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const WlsWeight *weight, ::coder::SizeType degree,
              ::coder::SizeType order, ::coder::SizeType interp0,
              boolean_T unimono, ::coder::SizeType nstpnts)
{
  real_T timestamp;
  ::coder::SizeType dim;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  b_wls->interp0 = interp0;
  b_wls->unimono = unimono;
  if (nstpnts <= 0) {
    nstpnts = us.size(0);
  } else {
    m2cAssert(
        nstpnts <= us.size(0),
        "Number of points cannot be greater than the first dimension of `us`.");
  }
  if (unimono && (!onaxes(us, nstpnts))) {
    m2cErrMsgIdAndTxt(
        "wlslib:NotAxesAlignedStencils",
        "To use univariate-monomial mode, all points must be on axes.");
  }
  //  Resize buffers
  wls_resize(b_wls, us.size(1), nstpnts, degree, order);
  if (nstpnts != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    ::coder::SizeType b_i;
    ::coder::SizeType loop_ub;
    ::coder::SizeType ncols;
    ::coder::SizeType nrblks;
    ::coder::SizeType src;
    ::coder::SizeType trg;
    ::coder::SizeType u0;
    ::coder::SizeType u1;
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = us[0];
        b = true;
        b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
        b_i = us.size(1) * us.size(0);
        u0 = 0;
        for (::coder::SizeType i{0}; i < nstpnts; i++) {
          if (b1 || (i >= b_i)) {
            u0 = 0;
            b = true;
          } else if (b) {
            b = false;
            u0 = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            loop_ub = us.size(1) * us.size(0) - 1;
            if (u0 > MAX_int32_T - us.size(1)) {
              u0 = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              u0 += us.size(1);
              if (u0 > loop_ub) {
                u0 -= loop_ub;
              }
            }
          }
          loop_ub = b_wls->us.size(0);
          b_wls->us[i % loop_ub * b_wls->us.size(1) + i / loop_ub] =
              us[u0] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        for (::coder::SizeType i{0}; i < nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        b_wls->origin[2] = us[2];
        for (::coder::SizeType i{0}; i < nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = 0.0;
        b = true;
        b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
        b_i = us.size(1) * us.size(0);
        u0 = 0;
        for (::coder::SizeType i{0}; i < nstpnts; i++) {
          if (b1 || (i >= b_i)) {
            u0 = 0;
            b = true;
          } else if (b) {
            b = false;
            u0 = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            loop_ub = us.size(1) * us.size(0) - 1;
            if (u0 > MAX_int32_T - us.size(1)) {
              u0 = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              u0 += us.size(1);
              if (u0 > loop_ub) {
                u0 -= loop_ub;
              }
            }
          }
          loop_ub = b_wls->us.size(0);
          b_wls->us[i % loop_ub * b_wls->us.size(1) + i / loop_ub] = us[u0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        for (::coder::SizeType i{0}; i < nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        b_wls->origin[2] = 0.0;
        for (::coder::SizeType i{0}; i < nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      b_i = b_wls->us.size(0);
      for (::coder::SizeType i{0}; i < nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[i % b_i * b_wls->us.size(1) + i / b_i]));
      }
      break;
    case 2:
      for (::coder::SizeType i{0}; i < nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * i + 1])));
      }
      break;
    default:
      for (::coder::SizeType i{0}; i < nstpnts; i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                                std::abs(b_wls->us[b_wls->us.size(1) * i + 1])),
                      std::abs(b_wls->us[b_wls->us.size(1) * i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (::coder::SizeType i{0}; i <= dim; i++) {
      b_wls->hs_inv[i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (::coder::SizeType i{0}; i < nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
        }
        break;
      case 2:
        for (::coder::SizeType i{0}; i < nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
        }
        break;
      default:
        for (::coder::SizeType i{0}; i < nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 2] =
              b_wls->us[b_wls->us.size(1) * i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight->name.size(1) == 0) || (weight->name[0] == 'U')) &&
        (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight->name.size(1) == 0) || (weight->name[0] == 'U')) {
        //  unit weights
        loop_ub = b_wls->rweights.size(0);
        for (b_i = 0; b_i < loop_ub; b_i++) {
          b_wls->rweights[b_i] = 1.0;
        }
      } else if ((weight->name[0] == 'I') || (weight->name[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, nstpnts, degree, weight->params_shared,
                            weight->params_pointwise, b_wls->rweights);
      } else if ((weight->name[0] == 'B') || (weight->name[0] == 'b')) {
        //  Buhmann weights. All points share same parameters
        wls_buhmann_weights(b_wls->us, nstpnts, degree, unimono,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else {
        if ((weight->name[0] != 'E') && (weight->name[0] != 'e')) {
          m2cErrMsgIdAndTxt(
              "wlslib:WrongWeightName",
              "Weighting scheme must be Unit, InvDist, Buhmann, or ENO.");
        }
        //  WLS-ENO
        wls_eno_weights(b_wls->us, nstpnts, degree, us, weight->params_shared,
                        weight->params_pointwise, b_wls->rweights);
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      timestamp = static_cast<std::chrono::duration<double>>(
                      std::chrono::system_clock::now().time_since_epoch())
                      .count();
    }
    //  Compute Vandermonde system
    c_gen_vander(b_wls->us, nstpnts, degree, order, b_wls->rweights, unimono,
                 b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (nstpnts != b_wls->stride) &&
        (nstpnts != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = nstpnts;
      for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (::coder::SizeType i{0}; i < nstpnts; i++) {
          b_i = b_wls->V.size(0);
          for (::coder::SizeType j{0}; j < b_i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    //  Omit rows in CVM if needed
    u0 = weight->omit_rows.size(0);
    u1 = b_wls->nrows;
    if (u0 <= u1) {
      u1 = u0;
    }
    for (::coder::SizeType i{0}; i < u1; i++) {
      if (weight->omit_rows[i]) {
        loop_ub = b_wls->V.size(0);
        for (b_i = 0; b_i < loop_ub; b_i++) {
          b_wls->V[i + b_wls->V.size(1) * b_i] = 0.0;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T timestamp1;
      timestamp1 = static_cast<std::chrono::duration<double>>(
                       std::chrono::system_clock::now().time_since_epoch())
                       .count();
      b_wls->runtimes[0] = timestamp1 - timestamp;
      timestamp = timestamp1;
    }
    b_wls->nrows = nrblks * nstpnts;
    b_wls->ncols = ncols;
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        ::coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (::coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j < nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          b_i = us.size(1) + 2;
          for (::coder::SizeType blk{b_i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (::coder::SizeType j{0}; j < nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        d_gen_vander(b_wls->hs_inv, order, b_wls->V);
        for (::coder::SizeType blk{2}; blk <= nrblks; blk++) {
          ::coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j < nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (nstpnts != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = nstpnts;
        for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (::coder::SizeType i{0}; i < nstpnts; i++) {
            b_wls->rweights[trg + i] = b_wls->rweights[src + i];
          }
          trg += nstpnts;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T t;
      t = static_cast<std::chrono::duration<double>>(
              std::chrono::system_clock::now().time_since_epoch())
              .count();
      b_wls->runtimes[1] = t - timestamp;
    }
  }
}

//  wls_init  Initialize WlsObject in 1D, 2D, or 3D.
void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const ::coder::array<char_T, 2U> &weight,
              ::coder::SizeType degree, ::coder::SizeType order,
              ::coder::SizeType interp0, ::coder::SizeType unimono)
{
  real_T timestamp;
  ::coder::SizeType dim;
  ::coder::SizeType nstpnts;
  boolean_T b_unimono;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  b_wls->interp0 = interp0;
  b_wls->unimono = unimono != 0;
  b_unimono = b_wls->unimono;
  nstpnts = us.size(0) - 1;
  if (b_wls->unimono && (!onaxes(us, us.size(0)))) {
    m2cErrMsgIdAndTxt(
        "wlslib:NotAxesAlignedStencils",
        "To use univariate-monomial mode, all points must be on axes.");
  }
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), degree, order);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    ::coder::SizeType b_i;
    ::coder::SizeType b_us;
    ::coder::SizeType ncols;
    ::coder::SizeType nrblks;
    ::coder::SizeType src;
    ::coder::SizeType trg;
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        b_us = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          ::coder::SizeType i1;
          if (b1 || (i >= b_i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[i % i1 * b_wls->us.size(1) + i / i1] = us[b_us] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = us[0];
        b_wls->origin[1] = us[1];
        b_wls->origin[2] = us[2];
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i] - us[0];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.set_size(1, 1);
        b_wls->origin[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        b_i = us.size(1) * us.size(0);
        b_us = 0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          ::coder::SizeType i1;
          if (b1 || (i >= b_i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = i % us.size(0) * us.size(1) + i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = i % us.size(0) * us.size(1) + i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[i % i1 * b_wls->us.size(1) + i / i1] = us[b_us];
        }
      } break;
      case 2:
        b_wls->origin.set_size(1, 2);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
        }
        break;
      default:
        b_wls->origin.set_size(1, 3);
        b_wls->origin[0] = 0.0;
        b_wls->origin[1] = 0.0;
        b_wls->origin[2] = 0.0;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] = us[us.size(1) * i];
          b_wls->us[b_wls->us.size(1) * i + 1] = us[us.size(1) * i + 1];
          b_wls->us[b_wls->us.size(1) * i + 2] = us[us.size(1) * i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      b_i = b_wls->us.size(0);
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[i % b_i * b_wls->us.size(1) + i / b_i]));
      }
      break;
    case 2:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * i + 1])));
      }
      break;
    default:
      for (::coder::SizeType i{0}; i <= nstpnts; i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * i]),
                                std::abs(b_wls->us[b_wls->us.size(1) * i + 1])),
                      std::abs(b_wls->us[b_wls->us.size(1) * i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (::coder::SizeType i{0}; i <= dim; i++) {
      b_wls->hs_inv[i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
        }
        break;
      case 2:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
        }
        break;
      default:
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_wls->us[b_wls->us.size(1) * i] =
              b_wls->us[b_wls->us.size(1) * i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 1] =
              b_wls->us[b_wls->us.size(1) * i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * i + 2] =
              b_wls->us[b_wls->us.size(1) * i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight.size(1) == 0) || (weight[0] == 'U')) && (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight.size(1) == 0) || (weight[0] == 'U')) {
        //  unit weights
        b_us = b_wls->rweights.size(0);
        b_wls->rweights.set_size(b_us);
        for (b_i = 0; b_i < b_us; b_i++) {
          b_wls->rweights[b_i] = 1.0;
        }
      } else if ((weight[0] == 'I') || (weight[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree, b_wls->rweights);
      } else {
        if ((weight[0] != 'B') && (weight[0] != 'b')) {
          m2cErrMsgIdAndTxt("wlslib:WrongWeightName",
                            "When using a character string, weighting scheme "
                            "must be Unit, InvDist, or Buhmann.");
        }
        //  Buhmann weights with default parameters
        b_wls_buhmann_weights(b_wls->us, us.size(0), degree, b_unimono,
                              b_wls->rweights);
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      timestamp = static_cast<std::chrono::duration<double>>(
                      std::chrono::system_clock::now().time_since_epoch())
                      .count();
    }
    //  Compute Vandermonde system
    c_gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights,
                 b_unimono, b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (::coder::SizeType i{0}; i <= nstpnts; i++) {
          b_i = b_wls->V.size(0);
          for (::coder::SizeType j{0}; j < b_i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    //  Omit rows in CVM if needed
    if (b_wls->runtimes.size(0) != 0) {
      real_T timestamp1;
      timestamp1 = static_cast<std::chrono::duration<double>>(
                       std::chrono::system_clock::now().time_since_epoch())
                       .count();
      b_wls->runtimes[0] = timestamp1 - timestamp;
      timestamp = timestamp1;
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        ::coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (::coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          b_i = us.size(1) + 2;
          for (::coder::SizeType blk{b_i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (::coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        d_gen_vander(b_wls->hs_inv, order, b_wls->V);
        for (::coder::SizeType blk{2}; blk <= nrblks; blk++) {
          ::coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (::coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (::coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (::coder::SizeType i{0}; i <= nstpnts; i++) {
            b_wls->rweights[trg + i] = b_wls->rweights[src + i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
    if (b_wls->runtimes.size(0) != 0) {
      real_T t;
      t = static_cast<std::chrono::duration<double>>(
              std::chrono::system_clock::now().time_since_epoch())
              .count();
      b_wls->runtimes[1] = t - timestamp;
    }
  }
}

//  wls_var_bilap  Compute bi-Laplacian operators as weighted sum at
void wls_var_bilap(WlsObject *b_wls,
                   const ::coder::array<real_T, 2U> &eval_pnts,
                   const ::coder::array<real_T, 2U> &varargin_1,
                   const ::coder::array<real_T, 2U> &varargin_2,
                   ::coder::SizeType varargin_3,
                   ::coder::array<real_T, 2U> &varargout_1,
                   ::coder::array<real_T, 2U> &varargout_2)
{
  ::coder::SizeType bilap_size[2];
  int8_T bilap_data[9];
  switch (b_wls->us.size(1)) {
  case 1:
    bilap_size[1] = 1;
    bilap_size[0] = 1;
    bilap_data[0] = 4;
    break;
  case 2:
    if (b_wls->degree > 0) {
      bilap_size[1] = 4;
      bilap_size[0] = 1;
      bilap_data[0] = 6;
      bilap_data[1] = 7;
      bilap_data[2] = 7;
      bilap_data[3] = 8;
    } else {
      bilap_size[1] = 4;
      bilap_size[0] = 1;
      bilap_data[0] = 9;
      bilap_data[1] = 10;
      bilap_data[2] = 10;
      bilap_data[3] = 11;
    }
    break;
  default:
    if (b_wls->degree > 0) {
      bilap_size[1] = 9;
      bilap_size[0] = 1;
      for (::coder::SizeType i{0}; i < 9; i++) {
        bilap_data[i] = iv2[i];
      }
    } else {
      bilap_size[1] = 9;
      bilap_size[0] = 1;
      for (::coder::SizeType i{0}; i < 9; i++) {
        bilap_data[i] = iv3[i];
      }
    }
    break;
  }
  wls_kernel(b_wls, eval_pnts, bilap_data, bilap_size, varargin_2, varargin_3,
             varargin_1, varargout_1, varargout_2);
}

//  wls_var_bilap  Compute bi-Laplacian operators as weighted sum at
void wls_var_bilap(WlsObject *b_wls,
                   const ::coder::array<real_T, 2U> &eval_pnts,
                   const ::coder::array<real_T, 2U> &varargin_1,
                   const ::coder::array<real_T, 2U> &varargin_2,
                   ::coder::array<real_T, 2U> &varargout_1,
                   ::coder::array<real_T, 2U> &varargout_2)
{
  ::coder::SizeType bilap_size[2];
  int8_T bilap_data[9];
  switch (b_wls->us.size(1)) {
  case 1:
    bilap_size[1] = 1;
    bilap_size[0] = 1;
    bilap_data[0] = 4;
    break;
  case 2:
    if (b_wls->degree > 0) {
      bilap_size[1] = 4;
      bilap_size[0] = 1;
      bilap_data[0] = 6;
      bilap_data[1] = 7;
      bilap_data[2] = 7;
      bilap_data[3] = 8;
    } else {
      bilap_size[1] = 4;
      bilap_size[0] = 1;
      bilap_data[0] = 9;
      bilap_data[1] = 10;
      bilap_data[2] = 10;
      bilap_data[3] = 11;
    }
    break;
  default:
    if (b_wls->degree > 0) {
      bilap_size[1] = 9;
      bilap_size[0] = 1;
      for (::coder::SizeType i{0}; i < 9; i++) {
        bilap_data[i] = iv2[i];
      }
    } else {
      bilap_size[1] = 9;
      bilap_size[0] = 1;
      for (::coder::SizeType i{0}; i < 9; i++) {
        bilap_data[i] = iv3[i];
      }
    }
    break;
  }
  wls_kernel(b_wls, eval_pnts, bilap_data, bilap_size, varargin_2,
             eval_pnts.size(0), varargin_1, varargout_1, varargout_2);
}

//  wls_var_bilap  Compute bi-Laplacian operators as weighted sum at
void wls_var_bilap(WlsObject *b_wls,
                   const ::coder::array<real_T, 2U> &eval_pnts,
                   ::coder::array<real_T, 2U> &varargout_1)
{
  ::coder::SizeType bilap_size[2];
  int8_T bilap_data[9];
  switch (b_wls->us.size(1)) {
  case 1:
    bilap_size[1] = 1;
    bilap_size[0] = 1;
    bilap_data[0] = 4;
    break;
  case 2:
    if (b_wls->degree > 0) {
      bilap_size[1] = 4;
      bilap_size[0] = 1;
      bilap_data[0] = 6;
      bilap_data[1] = 7;
      bilap_data[2] = 7;
      bilap_data[3] = 8;
    } else {
      bilap_size[1] = 4;
      bilap_size[0] = 1;
      bilap_data[0] = 9;
      bilap_data[1] = 10;
      bilap_data[2] = 10;
      bilap_data[3] = 11;
    }
    break;
  default:
    if (b_wls->degree > 0) {
      bilap_size[1] = 9;
      bilap_size[0] = 1;
      for (::coder::SizeType i{0}; i < 9; i++) {
        bilap_data[i] = iv2[i];
      }
    } else {
      bilap_size[1] = 9;
      bilap_size[0] = 1;
      for (::coder::SizeType i{0}; i < 9; i++) {
        bilap_data[i] = iv3[i];
      }
    }
    break;
  }
  wls_kernel(b_wls, eval_pnts, bilap_data, bilap_size, eval_pnts.size(0),
             varargout_1);
}

//  wls_var_bilap  Compute bi-Laplacian operators as weighted sum at
void wls_var_bilap(WlsObject *b_wls,
                   const ::coder::array<real_T, 2U> &eval_pnts,
                   const ::coder::array<real_T, 2U> &varargin_1,
                   ::coder::array<real_T, 2U> &varargout_1)
{
  ::coder::SizeType bilap_size[2];
  int8_T bilap_data[9];
  switch (b_wls->us.size(1)) {
  case 1:
    bilap_size[1] = 1;
    bilap_size[0] = 1;
    bilap_data[0] = 4;
    break;
  case 2:
    if (b_wls->degree > 0) {
      bilap_size[1] = 4;
      bilap_size[0] = 1;
      bilap_data[0] = 6;
      bilap_data[1] = 7;
      bilap_data[2] = 7;
      bilap_data[3] = 8;
    } else {
      bilap_size[1] = 4;
      bilap_size[0] = 1;
      bilap_data[0] = 9;
      bilap_data[1] = 10;
      bilap_data[2] = 10;
      bilap_data[3] = 11;
    }
    break;
  default:
    if (b_wls->degree > 0) {
      bilap_size[1] = 9;
      bilap_size[0] = 1;
      for (::coder::SizeType i{0}; i < 9; i++) {
        bilap_data[i] = iv2[i];
      }
    } else {
      bilap_size[1] = 9;
      bilap_size[0] = 1;
      for (::coder::SizeType i{0}; i < 9; i++) {
        bilap_data[i] = iv3[i];
      }
    }
    break;
  }
  wls_kernel(b_wls, eval_pnts, bilap_data, bilap_size, eval_pnts.size(0),
             varargin_1, varargout_1);
}

//  wls_var_cdr - Compute convection-diffusion-reaction operator at points
void wls_var_cdr(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                 const ::coder::array<real_T, 2U> &ws_lap,
                 const ::coder::array<real_T, 2U> &ws_grad,
                 const ::coder::array<real_T, 2U> &ws_rho,
                 const ::coder::array<real_T, 2U> &fs,
                 ::coder::SizeType nevpnts, ::coder::array<real_T, 2U> &vdops,
                 ::coder::array<real_T, 2U> &result)
{
  real_T timestamp;
  ::coder::SizeType grad_size[2];
  ::coder::SizeType lap_size[2];
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType nDims;
  ::coder::SizeType order;
  int8_T grad_data[3];
  int8_T lap_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size[1] = 1;
    grad_size[0] = 1;
    grad_data[0] = 2;
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    break;
  case 2:
    grad_size[1] = 2;
    grad_size[0] = 1;
    lap_size[1] = 2;
    lap_size[0] = 1;
    grad_data[0] = 2;
    lap_data[0] = 4;
    grad_data[1] = 3;
    lap_data[1] = 5;
    break;
  default:
    grad_size[1] = 3;
    grad_size[0] = 1;
    lap_size[1] = 3;
    lap_size[0] = 1;
    grad_data[0] = 2;
    lap_data[0] = 5;
    grad_data[1] = 3;
    lap_data[1] = 6;
    grad_data[2] = 4;
    lap_data[2] = 7;
    break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0) &&
      (!coder::isequal(ws_lap))) {
    order = -2;
  } else if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
             (!coder::isequal(ws_grad))) {
    order = 1;
  } else {
    order = 0;
  }
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, b_nevpnts, b_wls->degree, order, b_wls->hs_inv,
               b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0)) {
    wls_update_rhs(b_wls, lap_data, lap_size, ws_lap);
  } else {
    c_wls_update_rhs(b_wls);
  }
  if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
      (!coder::isequal(ws_grad))) {
    b_wls_update_rhs(b_wls, grad_data, grad_size, ws_grad);
  }
  if ((ws_rho.size(0) != 0) && (ws_rho.size(1) != 0) &&
      (!coder::isequal(ws_rho))) {
    wls_update_rhs(b_wls, ws_rho);
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  if ((ws_rho.size(0) != 0) && (ws_rho.size(1) != 0)) {
    wls_solve_sys(b_wls, ws_rho, vdops);
  } else {
    c_wls_solve_sys(b_wls, vdops);
  }
  //  Step 4: Optionally, evaluate the operator
  wls_eval_ops(b_wls, vdops, fs, result);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_cdr - Compute convection-diffusion-reaction operator at points
void wls_var_cdr(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                 const ::coder::array<real_T, 2U> &ws_lap,
                 const ::coder::array<real_T, 2U> &ws_grad,
                 const ::coder::array<real_T, 2U> &ws_rho,
                 const ::coder::array<real_T, 2U> &fs,
                 ::coder::array<real_T, 2U> &vdops,
                 ::coder::array<real_T, 2U> &result)
{
  real_T timestamp;
  ::coder::SizeType grad_size[2];
  ::coder::SizeType lap_size[2];
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  ::coder::SizeType order;
  int8_T grad_data[3];
  int8_T lap_data[3];
  nevpnts = eval_pnts.size(0);
  //  The operators are row vectors, so they will be summed up before solve
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size[1] = 1;
    grad_size[0] = 1;
    grad_data[0] = 2;
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    break;
  case 2:
    grad_size[1] = 2;
    grad_size[0] = 1;
    lap_size[1] = 2;
    lap_size[0] = 1;
    grad_data[0] = 2;
    lap_data[0] = 4;
    grad_data[1] = 3;
    lap_data[1] = 5;
    break;
  default:
    grad_size[1] = 3;
    grad_size[0] = 1;
    lap_size[1] = 3;
    lap_size[0] = 1;
    grad_data[0] = 2;
    lap_data[0] = 5;
    grad_data[1] = 3;
    lap_data[1] = 6;
    grad_data[2] = 4;
    lap_data[2] = 7;
    break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0) &&
      (!coder::isequal(ws_lap))) {
    order = -2;
  } else if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
             (!coder::isequal(ws_grad))) {
    order = 1;
  } else {
    order = 0;
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, order,
               b_wls->hs_inv, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0)) {
    wls_update_rhs(b_wls, lap_data, lap_size, ws_lap);
  } else {
    c_wls_update_rhs(b_wls);
  }
  if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
      (!coder::isequal(ws_grad))) {
    b_wls_update_rhs(b_wls, grad_data, grad_size, ws_grad);
  }
  if ((ws_rho.size(0) != 0) && (ws_rho.size(1) != 0) &&
      (!coder::isequal(ws_rho))) {
    wls_update_rhs(b_wls, ws_rho);
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  if ((ws_rho.size(0) != 0) && (ws_rho.size(1) != 0)) {
    wls_solve_sys(b_wls, ws_rho, vdops);
  } else {
    c_wls_solve_sys(b_wls, vdops);
  }
  //  Step 4: Optionally, evaluate the operator
  wls_eval_ops(b_wls, vdops, fs, result);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_cdr - Compute convection-diffusion-reaction operator at points
void wls_var_cdr(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                 const ::coder::array<real_T, 2U> &ws_lap,
                 const ::coder::array<real_T, 2U> &ws_grad,
                 const ::coder::array<real_T, 2U> &ws_rho,
                 ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType grad_size[2];
  ::coder::SizeType lap_size[2];
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  ::coder::SizeType order;
  int8_T grad_data[3];
  int8_T lap_data[3];
  nevpnts = eval_pnts.size(0);
  //  The operators are row vectors, so they will be summed up before solve
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size[1] = 1;
    grad_size[0] = 1;
    grad_data[0] = 2;
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    break;
  case 2:
    grad_size[1] = 2;
    grad_size[0] = 1;
    lap_size[1] = 2;
    lap_size[0] = 1;
    grad_data[0] = 2;
    lap_data[0] = 4;
    grad_data[1] = 3;
    lap_data[1] = 5;
    break;
  default:
    grad_size[1] = 3;
    grad_size[0] = 1;
    lap_size[1] = 3;
    lap_size[0] = 1;
    grad_data[0] = 2;
    lap_data[0] = 5;
    grad_data[1] = 3;
    lap_data[1] = 6;
    grad_data[2] = 4;
    lap_data[2] = 7;
    break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0) &&
      (!coder::isequal(ws_lap))) {
    order = -2;
  } else if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
             (!coder::isequal(ws_grad))) {
    order = 1;
  } else {
    order = 0;
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, order,
               b_wls->hs_inv, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0)) {
    wls_update_rhs(b_wls, lap_data, lap_size, ws_lap);
  } else {
    c_wls_update_rhs(b_wls);
  }
  if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
      (!coder::isequal(ws_grad))) {
    b_wls_update_rhs(b_wls, grad_data, grad_size, ws_grad);
  }
  if ((ws_rho.size(0) != 0) && (ws_rho.size(1) != 0) &&
      (!coder::isequal(ws_rho))) {
    wls_update_rhs(b_wls, ws_rho);
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  if ((ws_rho.size(0) != 0) && (ws_rho.size(1) != 0)) {
    wls_solve_sys(b_wls, ws_rho, vdops);
  } else {
    c_wls_solve_sys(b_wls, vdops);
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_cdr - Compute convection-diffusion-reaction operator at points
void wls_var_cdr4(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  const ::coder::array<real_T, 2U> &ws_lap,
                  const ::coder::array<real_T, 2U> &ws_grad,
                  ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType grad_size[2];
  ::coder::SizeType lap_size[2];
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  ::coder::SizeType order;
  int8_T grad_data[3];
  int8_T lap_data[3];
  nevpnts = eval_pnts.size(0);
  //  The operators are row vectors, so they will be summed up before solve
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size[1] = 1;
    grad_size[0] = 1;
    grad_data[0] = 2;
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    break;
  case 2:
    grad_size[1] = 2;
    grad_size[0] = 1;
    lap_size[1] = 2;
    lap_size[0] = 1;
    grad_data[0] = 2;
    lap_data[0] = 4;
    grad_data[1] = 3;
    lap_data[1] = 5;
    break;
  default:
    grad_size[1] = 3;
    grad_size[0] = 1;
    lap_size[1] = 3;
    lap_size[0] = 1;
    grad_data[0] = 2;
    lap_data[0] = 5;
    grad_data[1] = 3;
    lap_data[1] = 6;
    grad_data[2] = 4;
    lap_data[2] = 7;
    break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0) &&
      (!coder::isequal(ws_lap))) {
    order = -2;
  } else if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
             (!coder::isequal(ws_grad))) {
    order = 1;
  } else {
    order = 0;
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, order,
               b_wls->hs_inv, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0)) {
    wls_update_rhs(b_wls, lap_data, lap_size, ws_lap);
  } else {
    c_wls_update_rhs(b_wls);
  }
  if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
      (!coder::isequal(ws_grad))) {
    b_wls_update_rhs(b_wls, grad_data, grad_size, ws_grad);
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, vdops);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_cdr - Compute convection-diffusion-reaction operator at points
void wls_var_cdr5(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  const ::coder::array<real_T, 2U> &ws_lap,
                  ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType lap_size[2];
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  ::coder::SizeType order;
  int8_T lap_data[3];
  nevpnts = eval_pnts.size(0);
  //  The operators are row vectors, so they will be summed up before solve
  switch (b_wls->us.size(1)) {
  case 1:
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    break;
  case 2:
    lap_size[1] = 2;
    lap_size[0] = 1;
    lap_data[0] = 4;
    lap_data[1] = 5;
    break;
  default:
    lap_size[1] = 3;
    lap_size[0] = 1;
    lap_data[0] = 5;
    lap_data[1] = 6;
    lap_data[2] = 7;
    break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0) &&
      (!coder::isequal(ws_lap))) {
    order = -2;
  } else {
    order = 0;
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, order,
               b_wls->hs_inv, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if ((ws_lap.size(0) != 0) && (ws_lap.size(1) != 0)) {
    wls_update_rhs(b_wls, lap_data, lap_size, ws_lap);
  } else {
    c_wls_update_rhs(b_wls);
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, vdops);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_convdiff - Compute convection-diffusion operator at evaluation
static inline void wls_var_convdiff(
    WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
    ::coder::array<real_T, 2U> &ws_lap, ::coder::array<real_T, 2U> &ws_grad,
    const ::coder::array<real_T, 2U> &varargin_1, ::coder::SizeType varargin_2,
    ::coder::array<real_T, 2U> &vdops, ::coder::array<real_T, 2U> &varargout_1)
{
  if ((ws_lap.size(0) == 0) || (ws_lap.size(1) == 0)) {
    ws_lap.set_size(1, 1);
    ws_lap[0] = 0.0;
  }
  if ((ws_grad.size(0) == 0) || (ws_grad.size(1) == 0)) {
    ws_grad.set_size(1, 1);
    ws_grad[0] = 0.0;
  }
  wls_var_cdr(b_wls, eval_pnts, ws_lap, ws_grad, varargin_1, varargin_2, vdops,
              varargout_1);
}

//  wls_var_convdiff - Compute convection-diffusion operator at evaluation
static inline void wls_var_convdiff(
    WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
    ::coder::array<real_T, 2U> &ws_lap, ::coder::array<real_T, 2U> &ws_grad,
    const ::coder::array<real_T, 2U> &varargin_1,
    ::coder::array<real_T, 2U> &vdops, ::coder::array<real_T, 2U> &varargout_1)
{
  if ((ws_lap.size(0) == 0) || (ws_lap.size(1) == 0)) {
    ws_lap.set_size(1, 1);
    ws_lap[0] = 0.0;
  }
  if ((ws_grad.size(0) == 0) || (ws_grad.size(1) == 0)) {
    ws_grad.set_size(1, 1);
    ws_grad[0] = 0.0;
  }
  wls_var_cdr(b_wls, eval_pnts, ws_lap, ws_grad, varargin_1, vdops,
              varargout_1);
}

//  wls_var_convdiff - Compute convection-diffusion operator at evaluation
static inline void wls_var_convdiff(WlsObject *b_wls,
                                    const ::coder::array<real_T, 2U> &eval_pnts,
                                    ::coder::array<real_T, 2U> &ws_lap,
                                    ::coder::array<real_T, 2U> &ws_grad,
                                    ::coder::array<real_T, 2U> &vdops)
{
  if ((ws_lap.size(0) == 0) || (ws_lap.size(1) == 0)) {
    ws_lap.set_size(1, 1);
    ws_lap[0] = 0.0;
  }
  if ((ws_grad.size(0) == 0) || (ws_grad.size(1) == 0)) {
    ws_grad.set_size(1, 1);
    ws_grad[0] = 0.0;
  }
  wls_var_cdr(b_wls, eval_pnts, ws_lap, ws_grad, vdops);
}

//  wls_var_convdiff - Compute convection-diffusion operator at evaluation
static inline void wls_var_convdiff(WlsObject *b_wls,
                                    const ::coder::array<real_T, 2U> &eval_pnts,
                                    ::coder::array<real_T, 2U> &vdops)
{
  wls_var_cdr(b_wls, eval_pnts, vdops);
}

//  wls_var_convdiff - Compute convection-diffusion operator at evaluation
static inline void wls_var_convdiff(WlsObject *b_wls,
                                    const ::coder::array<real_T, 2U> &eval_pnts,
                                    ::coder::array<real_T, 2U> &ws_lap,
                                    ::coder::array<real_T, 2U> &vdops)
{
  if ((ws_lap.size(0) == 0) || (ws_lap.size(1) == 0)) {
    ws_lap.set_size(1, 1);
    ws_lap[0] = 0.0;
  }
  wls_var_cdr(b_wls, eval_pnts, ws_lap, vdops);
}

//  wls_var_curl  Variational curl operators as weighted sum at evaluation
static inline void wls_var_curl(WlsObject *b_wls,
                                const ::coder::array<real_T, 2U> &eval_pnts,
                                const ::coder::array<real_T, 2U> &ws,
                                const ::coder::array<real_T, 2U> &varargin_1,
                                ::coder::SizeType varargin_2,
                                ::coder::array<real_T, 2U> &varargout_1,
                                ::coder::array<real_T, 2U> &varargout_2)
{
  wls_kernel(b_wls, eval_pnts, varargin_1, varargin_2, ws, varargout_1,
             varargout_2);
}

//  wls_var_curl  Variational curl operators as weighted sum at evaluation
static inline void wls_var_curl(WlsObject *b_wls,
                                const ::coder::array<real_T, 2U> &eval_pnts,
                                const ::coder::array<real_T, 2U> &ws,
                                const ::coder::array<real_T, 2U> &varargin_1,
                                ::coder::array<real_T, 2U> &varargout_1,
                                ::coder::array<real_T, 2U> &varargout_2)
{
  wls_kernel(b_wls, eval_pnts, varargin_1, eval_pnts.size(0), ws, varargout_1,
             varargout_2);
}

//  wls_var_curl  Variational curl operators as weighted sum at evaluation
static inline void wls_var_curl(WlsObject *b_wls,
                                const ::coder::array<real_T, 2U> &eval_pnts,
                                ::coder::array<real_T, 2U> &varargout_1)
{
  b_wls_kernel(b_wls, eval_pnts, eval_pnts.size(0), varargout_1);
}

//  wls_var_curl  Variational curl operators as weighted sum at evaluation
static inline void wls_var_curl(WlsObject *b_wls,
                                const ::coder::array<real_T, 2U> &eval_pnts,
                                const ::coder::array<real_T, 2U> &ws,
                                ::coder::array<real_T, 2U> &varargout_1)
{
  wls_kernel(b_wls, eval_pnts, eval_pnts.size(0), ws, varargout_1);
}

//  wls_var_curl_curl  Variational curl-curl operators as weighted sum at
void wls_var_curl_curl(WlsObject *b_wls,
                       const ::coder::array<real_T, 2U> &eval_pnts,
                       ::coder::array<real_T, 1U> &ws,
                       const ::coder::array<real_T, 2U> &varargin_1,
                       ::coder::SizeType varargin_2,
                       ::coder::array<real_T, 2U> &vdops,
                       ::coder::array<real_T, 2U> &varargout_1)
{
  ::coder::array<real_T, 1U> b_ws;
  ::coder::SizeType loop_ub;
  if (ws.size(0) == 0) {
    ws.set_size(1);
    ws[0] = 1.0;
  }
  b_ws.set_size(ws.size(0));
  loop_ub = ws.size(0);
  for (::coder::SizeType i{0}; i < loop_ub; i++) {
    b_ws[i] = -ws[i];
  }
  wls_var_uno(b_wls, eval_pnts, ws, b_ws, varargin_1, varargin_2, vdops,
              varargout_1);
  // Local buffers with patterns "\w+_ws" are legitimate
}

//  wls_var_curl_curl  Variational curl-curl operators as weighted sum at
void wls_var_curl_curl(WlsObject *b_wls,
                       const ::coder::array<real_T, 2U> &eval_pnts,
                       ::coder::array<real_T, 1U> &ws,
                       const ::coder::array<real_T, 2U> &varargin_1,
                       ::coder::array<real_T, 2U> &vdops,
                       ::coder::array<real_T, 2U> &varargout_1)
{
  ::coder::array<real_T, 1U> b_ws;
  ::coder::SizeType loop_ub;
  if (ws.size(0) == 0) {
    ws.set_size(1);
    ws[0] = 1.0;
  }
  b_ws.set_size(ws.size(0));
  loop_ub = ws.size(0);
  for (::coder::SizeType i{0}; i < loop_ub; i++) {
    b_ws[i] = -ws[i];
  }
  wls_var_uno(b_wls, eval_pnts, ws, b_ws, varargin_1, vdops, varargout_1);
  // Local buffers with patterns "\w+_ws" are legitimate
}

//  wls_var_curl_curl  Variational curl-curl operators as weighted sum at
static inline void
wls_var_curl_curl(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  ::coder::array<real_T, 2U> &vdops)
{
  wls_var_uno(b_wls, eval_pnts, vdops);
  // Local buffers with patterns "\w+_ws" are legitimate
}

//  wls_var_curl_curl  Variational curl-curl operators as weighted sum at
void wls_var_curl_curl(WlsObject *b_wls,
                       const ::coder::array<real_T, 2U> &eval_pnts,
                       ::coder::array<real_T, 1U> &ws,
                       ::coder::array<real_T, 2U> &vdops)
{
  ::coder::array<real_T, 1U> b_ws;
  ::coder::SizeType loop_ub;
  if (ws.size(0) == 0) {
    ws.set_size(1);
    ws[0] = 1.0;
  }
  b_ws.set_size(ws.size(0));
  loop_ub = ws.size(0);
  for (::coder::SizeType i{0}; i < loop_ub; i++) {
    b_ws[i] = -ws[i];
  }
  wls_var_uno(b_wls, eval_pnts, ws, b_ws, vdops);
  // Local buffers with patterns "\w+_ws" are legitimate
}

//  wls_var_div  Compute variational divergence operators as weighted sum at
void wls_var_div(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                 const ::coder::array<real_T, 2U> &ws,
                 const ::coder::array<real_T, 2U> &varargin_1,
                 ::coder::SizeType varargin_2,
                 ::coder::array<real_T, 2U> &vdops,
                 ::coder::array<real_T, 2U> &varargout_1)
{
  ::coder::SizeType div_size[2];
  int8_T div_data[9];
  switch (b_wls->us.size(1)) {
  case 1:
    div_size[1] = 1;
    div_size[0] = 1;
    div_data[0] = 2;
    break;
  case 2:
    div_size[1] = 2;
    div_size[0] = 2;
    div_data[0] = 2;
    div_data[1] = 0;
    div_data[2] = 0;
    div_data[3] = 3;
    break;
  default:
    div_size[1] = 3;
    div_size[0] = 3;
    for (::coder::SizeType i{0}; i < 9; i++) {
      div_data[i] = iv1[i];
    }
    break;
  }
  b_wls_kernel(b_wls, eval_pnts, div_data, div_size, varargin_1, varargin_2, ws,
               vdops, varargout_1);
}

//  wls_var_div  Compute variational divergence operators as weighted sum at
void wls_var_div(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                 const ::coder::array<real_T, 2U> &ws,
                 const ::coder::array<real_T, 2U> &varargin_1,
                 ::coder::array<real_T, 2U> &vdops,
                 ::coder::array<real_T, 2U> &varargout_1)
{
  ::coder::SizeType div_size[2];
  int8_T div_data[9];
  switch (b_wls->us.size(1)) {
  case 1:
    div_size[1] = 1;
    div_size[0] = 1;
    div_data[0] = 2;
    break;
  case 2:
    div_size[1] = 2;
    div_size[0] = 2;
    div_data[0] = 2;
    div_data[1] = 0;
    div_data[2] = 0;
    div_data[3] = 3;
    break;
  default:
    div_size[1] = 3;
    div_size[0] = 3;
    for (::coder::SizeType i{0}; i < 9; i++) {
      div_data[i] = iv1[i];
    }
    break;
  }
  b_wls_kernel(b_wls, eval_pnts, div_data, div_size, varargin_1,
               eval_pnts.size(0), ws, vdops, varargout_1);
}

//  wls_var_div  Compute variational divergence operators as weighted sum at
void wls_var_div(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                 ::coder::array<real_T, 2U> &vdops)
{
  ::coder::SizeType div_size[2];
  int8_T div_data[9];
  switch (b_wls->us.size(1)) {
  case 1:
    div_size[1] = 1;
    div_size[0] = 1;
    div_data[0] = 2;
    break;
  case 2:
    div_size[1] = 2;
    div_size[0] = 2;
    div_data[0] = 2;
    div_data[1] = 0;
    div_data[2] = 0;
    div_data[3] = 3;
    break;
  default:
    div_size[1] = 3;
    div_size[0] = 3;
    for (::coder::SizeType i{0}; i < 9; i++) {
      div_data[i] = iv1[i];
    }
    break;
  }
  b_wls_kernel(b_wls, eval_pnts, div_data, div_size, eval_pnts.size(0), vdops);
}

//  wls_var_div  Compute variational divergence operators as weighted sum at
void wls_var_div(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                 const ::coder::array<real_T, 2U> &ws,
                 ::coder::array<real_T, 2U> &vdops)
{
  ::coder::SizeType div_size[2];
  int8_T div_data[9];
  switch (b_wls->us.size(1)) {
  case 1:
    div_size[1] = 1;
    div_size[0] = 1;
    div_data[0] = 2;
    break;
  case 2:
    div_size[1] = 2;
    div_size[0] = 2;
    div_data[0] = 2;
    div_data[1] = 0;
    div_data[2] = 0;
    div_data[3] = 3;
    break;
  default:
    div_size[1] = 3;
    div_size[0] = 3;
    for (::coder::SizeType i{0}; i < 9; i++) {
      div_data[i] = iv1[i];
    }
    break;
  }
  b_wls_kernel(b_wls, eval_pnts, div_data, div_size, eval_pnts.size(0), ws,
               vdops);
}

//  wls_var_func  Compute variational WLS-fitting as weighted sum at
static inline void wls_var_func(WlsObject *b_wls,
                                const ::coder::array<real_T, 2U> &eval_pnts,
                                const ::coder::array<real_T, 2U> &varargin_1,
                                const ::coder::array<real_T, 2U> &varargin_2,
                                ::coder::SizeType varargin_3,
                                ::coder::array<real_T, 2U> &varargout_1,
                                ::coder::array<real_T, 2U> &varargout_2)
{
  b_wls_kernel(b_wls, eval_pnts, varargin_2, varargin_3, varargin_1,
               varargout_1, varargout_2);
}

//  wls_var_func  Compute variational WLS-fitting as weighted sum at
static inline void wls_var_func(WlsObject *b_wls,
                                const ::coder::array<real_T, 2U> &eval_pnts,
                                const ::coder::array<real_T, 2U> &varargin_1,
                                const ::coder::array<real_T, 2U> &varargin_2,
                                ::coder::array<real_T, 2U> &varargout_1,
                                ::coder::array<real_T, 2U> &varargout_2)
{
  b_wls_kernel(b_wls, eval_pnts, varargin_2, eval_pnts.size(0), varargin_1,
               varargout_1, varargout_2);
}

//  wls_var_func  Compute variational WLS-fitting as weighted sum at
static inline void wls_var_func(WlsObject *b_wls,
                                const ::coder::array<real_T, 2U> &eval_pnts,
                                ::coder::array<real_T, 2U> &varargout_1)
{
  c_wls_kernel(b_wls, eval_pnts, eval_pnts.size(0), varargout_1);
}

//  wls_var_func  Compute variational WLS-fitting as weighted sum at
static inline void wls_var_func(WlsObject *b_wls,
                                const ::coder::array<real_T, 2U> &eval_pnts,
                                const ::coder::array<real_T, 2U> &varargin_1,
                                ::coder::array<real_T, 2U> &varargout_1)
{
  b_wls_kernel(b_wls, eval_pnts, eval_pnts.size(0), varargin_1, varargout_1);
}

//  wls_var_grad  Compute variational gradient operators as weighted sum at
void wls_var_grad(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  const ::coder::array<real_T, 2U> &varargin_1,
                  const ::coder::array<real_T, 2U> &varargin_2,
                  ::coder::SizeType varargin_3,
                  ::coder::array<real_T, 2U> &varargout_1,
                  ::coder::array<real_T, 2U> &varargout_2)
{
  ::coder::SizeType grad_size;
  int8_T grad_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size = 1;
    grad_data[0] = 2;
    break;
  case 2:
    grad_size = 2;
    grad_data[0] = 2;
    grad_data[1] = 3;
    break;
  default:
    grad_size = 3;
    grad_data[0] = 2;
    grad_data[1] = 3;
    grad_data[2] = 4;
    break;
  }
  wls_kernel(b_wls, eval_pnts, grad_data, grad_size, varargin_2, varargin_3,
             varargin_1, varargout_1, varargout_2);
}

//  wls_var_grad  Compute variational gradient operators as weighted sum at
void wls_var_grad(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  const ::coder::array<real_T, 2U> &varargin_1,
                  const ::coder::array<real_T, 2U> &varargin_2,
                  ::coder::array<real_T, 2U> &varargout_1,
                  ::coder::array<real_T, 2U> &varargout_2)
{
  ::coder::SizeType grad_size;
  int8_T grad_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size = 1;
    grad_data[0] = 2;
    break;
  case 2:
    grad_size = 2;
    grad_data[0] = 2;
    grad_data[1] = 3;
    break;
  default:
    grad_size = 3;
    grad_data[0] = 2;
    grad_data[1] = 3;
    grad_data[2] = 4;
    break;
  }
  wls_kernel(b_wls, eval_pnts, grad_data, grad_size, varargin_2,
             eval_pnts.size(0), varargin_1, varargout_1, varargout_2);
}

//  wls_var_grad  Compute variational gradient operators as weighted sum at
void wls_var_grad(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  ::coder::array<real_T, 2U> &varargout_1)
{
  ::coder::SizeType grad_size;
  int8_T grad_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size = 1;
    grad_data[0] = 2;
    break;
  case 2:
    grad_size = 2;
    grad_data[0] = 2;
    grad_data[1] = 3;
    break;
  default:
    grad_size = 3;
    grad_data[0] = 2;
    grad_data[1] = 3;
    grad_data[2] = 4;
    break;
  }
  wls_kernel(b_wls, eval_pnts, grad_data, grad_size, eval_pnts.size(0),
             varargout_1);
}

//  wls_var_grad  Compute variational gradient operators as weighted sum at
void wls_var_grad(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  const ::coder::array<real_T, 2U> &varargin_1,
                  ::coder::array<real_T, 2U> &varargout_1)
{
  ::coder::SizeType grad_size;
  int8_T grad_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size = 1;
    grad_data[0] = 2;
    break;
  case 2:
    grad_size = 2;
    grad_data[0] = 2;
    grad_data[1] = 3;
    break;
  default:
    grad_size = 3;
    grad_data[0] = 2;
    grad_data[1] = 3;
    grad_data[2] = 4;
    break;
  }
  wls_kernel(b_wls, eval_pnts, grad_data, grad_size, eval_pnts.size(0),
             varargin_1, varargout_1);
}

//  wls_var_grad_div  Variational grad-div operators as weighted sum at
static inline void wls_var_grad_div(
    WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
    ::coder::array<real_T, 1U> &ws,
    const ::coder::array<real_T, 2U> &varargin_1, ::coder::SizeType varargin_2,
    ::coder::array<real_T, 2U> &vdops, ::coder::array<real_T, 2U> &varargout_1)
{
  if (ws.size(0) == 0) {
    ws.set_size(1);
    ws[0] = 1.0;
  }
  wls_var_uno(b_wls, eval_pnts, ws, varargin_1, varargin_2, vdops, varargout_1);
}

//  wls_var_grad_div  Variational grad-div operators as weighted sum at
static inline void
wls_var_grad_div(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                 ::coder::array<real_T, 1U> &ws,
                 const ::coder::array<real_T, 2U> &varargin_1,
                 ::coder::array<real_T, 2U> &vdops,
                 ::coder::array<real_T, 2U> &varargout_1)
{
  if (ws.size(0) == 0) {
    ws.set_size(1);
    ws[0] = 1.0;
  }
  wls_var_uno(b_wls, eval_pnts, ws, varargin_1, vdops, varargout_1);
}

//  wls_var_grad_div  Variational grad-div operators as weighted sum at
static inline void wls_var_grad_div(WlsObject *b_wls,
                                    const ::coder::array<real_T, 2U> &eval_pnts,
                                    ::coder::array<real_T, 2U> &vdops)
{
  b_wls_var_uno(b_wls, eval_pnts, vdops);
}

//  wls_var_grad_div  Variational grad-div operators as weighted sum at
static inline void wls_var_grad_div(WlsObject *b_wls,
                                    const ::coder::array<real_T, 2U> &eval_pnts,
                                    ::coder::array<real_T, 1U> &ws,
                                    ::coder::array<real_T, 2U> &vdops)
{
  if (ws.size(0) == 0) {
    ws.set_size(1);
    ws[0] = 1.0;
  }
  wls_var_uno(b_wls, eval_pnts, ws, vdops);
}

//  wls_var_lap  Compute variational Laplacian as weighted sum at evaluation
static inline void wls_var_lap(WlsObject *b_wls,
                               const ::coder::array<real_T, 2U> &eval_pnts,
                               ::coder::array<real_T, 2U> &ws,
                               const ::coder::array<real_T, 2U> &varargin_1,
                               ::coder::SizeType varargin_2,
                               ::coder::array<real_T, 2U> &vdops,
                               ::coder::array<real_T, 2U> &varargout_1)
{
  if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
    ws.set_size(1, 1);
    ws[0] = 1.0;
  }
  wls_var_cdr(b_wls, eval_pnts, ws, varargin_1, varargin_2, vdops, varargout_1);
}

//  wls_var_lap  Compute variational Laplacian as weighted sum at evaluation
static inline void wls_var_lap(WlsObject *b_wls,
                               const ::coder::array<real_T, 2U> &eval_pnts,
                               ::coder::array<real_T, 2U> &ws,
                               const ::coder::array<real_T, 2U> &varargin_1,
                               ::coder::array<real_T, 2U> &vdops,
                               ::coder::array<real_T, 2U> &varargout_1)
{
  if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
    ws.set_size(1, 1);
    ws[0] = 1.0;
  }
  wls_var_cdr(b_wls, eval_pnts, ws, varargin_1, vdops, varargout_1);
}

//  wls_var_lap  Compute variational Laplacian as weighted sum at evaluation
static inline void wls_var_lap(WlsObject *b_wls,
                               const ::coder::array<real_T, 2U> &eval_pnts,
                               ::coder::array<real_T, 2U> &vdops)
{
  b_wls_var_cdr(b_wls, eval_pnts, vdops);
}

//  wls_var_lap  Compute variational Laplacian as weighted sum at evaluation
static inline void wls_var_lap(WlsObject *b_wls,
                               const ::coder::array<real_T, 2U> &eval_pnts,
                               ::coder::array<real_T, 2U> &ws,
                               ::coder::array<real_T, 2U> &vdops)
{
  if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
    ws.set_size(1, 1);
    ws[0] = 1.0;
  }
  wls_var_cdr(b_wls, eval_pnts, ws, vdops);
}

//  wls_var_uno - Compute the unified Navier operator at evaluation points
void wls_var_uno(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                 const ::coder::array<real_T, 1U> &ws_graddiv,
                 const ::coder::array<real_T, 1U> &ws_lap,
                 const ::coder::array<real_T, 2U> &ws_grad,
                 const ::coder::array<real_T, 1U> &ws_rho,
                 const ::coder::array<real_T, 2U> &fs,
                 ::coder::SizeType nevpnts, ::coder::array<real_T, 2U> &vdops,
                 ::coder::array<real_T, 2U> &result)
{
  static const int8_T b_iv[8]{4, 6, 0, 0, 0, 0, 4, 6};
  static const int8_T b_iv1[8]{2, 3, 0, 0, 0, 0, 2, 3};
  static const int8_T b_iv2[8]{4, 5, 0, 0, 0, 0, 4, 5};
  real_T timestamp;
  ::coder::SizeType func_size[2];
  ::coder::SizeType grad_size[2];
  ::coder::SizeType lap_size[2];
  ::coder::SizeType b_nevpnts;
  ::coder::SizeType grad_div_size;
  ::coder::SizeType nDims;
  ::coder::SizeType order;
  int8_T grad_data[27];
  int8_T lap_data[27];
  int8_T func_data[9];
  int8_T grad_div_data[9];
  switch (b_wls->us.size(1)) {
  case 1:
    grad_div_size = 1;
    grad_div_data[0] = 3;
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    grad_size[1] = 1;
    grad_size[0] = 1;
    grad_data[0] = 2;
    func_size[1] = 1;
    func_size[0] = 1;
    func_data[0] = 1;
    break;
  case 2:
    grad_div_size = 4;
    grad_div_data[0] = 4;
    grad_div_data[1] = 5;
    grad_div_data[2] = 5;
    grad_div_data[3] = 6;
    lap_size[1] = 2;
    lap_size[0] = 4;
    grad_size[1] = 2;
    grad_size[0] = 4;
    for (b_nevpnts = 0; b_nevpnts < 8; b_nevpnts++) {
      lap_data[b_nevpnts] = b_iv[b_nevpnts];
      grad_data[b_nevpnts] = b_iv1[b_nevpnts];
    }
    func_size[1] = 2;
    func_size[0] = 2;
    func_data[0] = 1;
    func_data[1] = 0;
    func_data[2] = 0;
    func_data[3] = 1;
    break;
  default: {
    int8_T b_I[9];
    grad_div_size = 9;
    for (b_nevpnts = 0; b_nevpnts < 9; b_nevpnts++) {
      grad_div_data[b_nevpnts] = iv5[b_nevpnts];
    }
    lap_size[1] = 3;
    lap_size[0] = 9;
    grad_size[1] = 3;
    grad_size[0] = 9;
    for (b_nevpnts = 0; b_nevpnts < 27; b_nevpnts++) {
      lap_data[b_nevpnts] = iv6[b_nevpnts];
      grad_data[b_nevpnts] = iv7[b_nevpnts];
    }
    for (b_nevpnts = 0; b_nevpnts < 9; b_nevpnts++) {
      b_I[b_nevpnts] = 0;
    }
    b_I[0] = 1;
    b_I[4] = 1;
    b_I[8] = 1;
    func_size[1] = 3;
    func_size[0] = 3;
    for (b_nevpnts = 0; b_nevpnts < 9; b_nevpnts++) {
      func_data[b_nevpnts] = b_I[b_nevpnts];
    }
  } break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if ((ws_graddiv.size(0) != 0) && (!coder::isequal(ws_graddiv))) {
    order = 2;
    //  With full Hessian
  } else if ((ws_lap.size(0) != 0) && (!coder::isequal(ws_lap))) {
    order = -2;
    //  With Laplacian only
    if (b_wls->us.size(1) == 2) {
      lap_size[1] = 2;
      lap_size[0] = 4;
      for (b_nevpnts = 0; b_nevpnts < 8; b_nevpnts++) {
        lap_data[b_nevpnts] = b_iv2[b_nevpnts];
      }
    } else if (b_wls->us.size(1) == 3) {
      lap_size[1] = 3;
      lap_size[0] = 9;
      for (b_nevpnts = 0; b_nevpnts < 27; b_nevpnts++) {
        lap_data[b_nevpnts] = iv4[b_nevpnts];
      }
    }
  } else if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
             (!coder::isequal(ws_grad))) {
    order = 1;
    //  With gradients only
  } else {
    order = 0;
    //  Function-values only
  }
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, b_nevpnts, b_wls->degree, order, b_wls->hs_inv,
               b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if (order == 2) {
    wls_update_rhs(b_wls, grad_div_data, grad_div_size, ws_graddiv);
    //  grad-div
  } else {
    wls_update_rhs(b_wls, grad_div_size);
  }
  if ((ws_lap.size(0) != 0) && (!coder::isequal(ws_lap))) {
    wls_update_rhs(b_wls, lap_data, lap_size, ws_lap);
    //  laplacian
  }
  if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
      (!coder::isequal(ws_grad))) {
    d_wls_update_rhs(b_wls, grad_data, grad_size, ws_grad);
    //  gradients
  }
  if ((ws_rho.size(0) != 0) && (!coder::isequal(ws_rho))) {
    wls_update_rhs(b_wls, func_data, func_size, ws_rho);
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  if (ws_rho.size(0) != 0) {
    wls_solve_sys(b_wls, func_data, func_size, ws_rho, vdops);
  } else {
    c_wls_solve_sys(b_wls, func_data, func_size, vdops);
  }
  //  Step 4: Optionally, evaluate the operator
  wls_eval_ops(b_wls, vdops, fs, result);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_uno - Compute the unified Navier operator at evaluation points
void wls_var_uno(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                 const ::coder::array<real_T, 1U> &ws_graddiv,
                 const ::coder::array<real_T, 1U> &ws_lap,
                 const ::coder::array<real_T, 2U> &ws_grad,
                 const ::coder::array<real_T, 1U> &ws_rho,
                 const ::coder::array<real_T, 2U> &fs,
                 ::coder::array<real_T, 2U> &vdops,
                 ::coder::array<real_T, 2U> &result)
{
  static const int8_T b_iv[8]{4, 6, 0, 0, 0, 0, 4, 6};
  static const int8_T b_iv1[8]{2, 3, 0, 0, 0, 0, 2, 3};
  static const int8_T b_iv2[8]{4, 5, 0, 0, 0, 0, 4, 5};
  real_T timestamp;
  ::coder::SizeType func_size[2];
  ::coder::SizeType grad_size[2];
  ::coder::SizeType lap_size[2];
  ::coder::SizeType grad_div_size;
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  ::coder::SizeType order;
  int8_T grad_data[27];
  int8_T lap_data[27];
  int8_T func_data[9];
  int8_T grad_div_data[9];
  nevpnts = eval_pnts.size(0);
  //  The rows in the operators will be summed up before for each point
  switch (b_wls->us.size(1)) {
  case 1:
    grad_div_size = 1;
    grad_div_data[0] = 3;
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    grad_size[1] = 1;
    grad_size[0] = 1;
    grad_data[0] = 2;
    func_size[1] = 1;
    func_size[0] = 1;
    func_data[0] = 1;
    break;
  case 2:
    grad_div_size = 4;
    grad_div_data[0] = 4;
    grad_div_data[1] = 5;
    grad_div_data[2] = 5;
    grad_div_data[3] = 6;
    lap_size[1] = 2;
    lap_size[0] = 4;
    grad_size[1] = 2;
    grad_size[0] = 4;
    for (::coder::SizeType i{0}; i < 8; i++) {
      lap_data[i] = b_iv[i];
      grad_data[i] = b_iv1[i];
    }
    func_size[1] = 2;
    func_size[0] = 2;
    func_data[0] = 1;
    func_data[1] = 0;
    func_data[2] = 0;
    func_data[3] = 1;
    break;
  default: {
    int8_T b_I[9];
    grad_div_size = 9;
    for (::coder::SizeType i{0}; i < 9; i++) {
      grad_div_data[i] = iv5[i];
    }
    lap_size[1] = 3;
    lap_size[0] = 9;
    grad_size[1] = 3;
    grad_size[0] = 9;
    for (::coder::SizeType i{0}; i < 27; i++) {
      lap_data[i] = iv6[i];
      grad_data[i] = iv7[i];
    }
    for (::coder::SizeType i{0}; i < 9; i++) {
      b_I[i] = 0;
    }
    b_I[0] = 1;
    b_I[4] = 1;
    b_I[8] = 1;
    func_size[1] = 3;
    func_size[0] = 3;
    for (::coder::SizeType i{0}; i < 9; i++) {
      func_data[i] = b_I[i];
    }
  } break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if ((ws_graddiv.size(0) != 0) && (!coder::isequal(ws_graddiv))) {
    order = 2;
    //  With full Hessian
  } else if ((ws_lap.size(0) != 0) && (!coder::isequal(ws_lap))) {
    order = -2;
    //  With Laplacian only
    if (b_wls->us.size(1) == 2) {
      lap_size[1] = 2;
      lap_size[0] = 4;
      for (::coder::SizeType i{0}; i < 8; i++) {
        lap_data[i] = b_iv2[i];
      }
    } else if (b_wls->us.size(1) == 3) {
      lap_size[1] = 3;
      lap_size[0] = 9;
      for (::coder::SizeType i{0}; i < 27; i++) {
        lap_data[i] = iv4[i];
      }
    }
  } else if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
             (!coder::isequal(ws_grad))) {
    order = 1;
    //  With gradients only
  } else {
    order = 0;
    //  Function-values only
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, order,
               b_wls->hs_inv, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if (order == 2) {
    wls_update_rhs(b_wls, grad_div_data, grad_div_size, ws_graddiv);
    //  grad-div
  } else {
    wls_update_rhs(b_wls, grad_div_size);
  }
  if ((ws_lap.size(0) != 0) && (!coder::isequal(ws_lap))) {
    wls_update_rhs(b_wls, lap_data, lap_size, ws_lap);
    //  laplacian
  }
  if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
      (!coder::isequal(ws_grad))) {
    d_wls_update_rhs(b_wls, grad_data, grad_size, ws_grad);
    //  gradients
  }
  if ((ws_rho.size(0) != 0) && (!coder::isequal(ws_rho))) {
    wls_update_rhs(b_wls, func_data, func_size, ws_rho);
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  if (ws_rho.size(0) != 0) {
    wls_solve_sys(b_wls, func_data, func_size, ws_rho, vdops);
  } else {
    c_wls_solve_sys(b_wls, func_data, func_size, vdops);
  }
  //  Step 4: Optionally, evaluate the operator
  wls_eval_ops(b_wls, vdops, fs, result);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_uno - Compute the unified Navier operator at evaluation points
void wls_var_uno(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                 const ::coder::array<real_T, 1U> &ws_graddiv,
                 const ::coder::array<real_T, 1U> &ws_lap,
                 const ::coder::array<real_T, 2U> &ws_grad,
                 const ::coder::array<real_T, 1U> &ws_rho,
                 ::coder::array<real_T, 2U> &vdops)
{
  static const int8_T b_iv[8]{4, 6, 0, 0, 0, 0, 4, 6};
  static const int8_T b_iv1[8]{2, 3, 0, 0, 0, 0, 2, 3};
  static const int8_T b_iv2[8]{4, 5, 0, 0, 0, 0, 4, 5};
  real_T timestamp;
  ::coder::SizeType func_size[2];
  ::coder::SizeType grad_size[2];
  ::coder::SizeType lap_size[2];
  ::coder::SizeType grad_div_size;
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  ::coder::SizeType order;
  int8_T grad_data[27];
  int8_T lap_data[27];
  int8_T func_data[9];
  int8_T grad_div_data[9];
  nevpnts = eval_pnts.size(0);
  //  The rows in the operators will be summed up before for each point
  switch (b_wls->us.size(1)) {
  case 1:
    grad_div_size = 1;
    grad_div_data[0] = 3;
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    grad_size[1] = 1;
    grad_size[0] = 1;
    grad_data[0] = 2;
    func_size[1] = 1;
    func_size[0] = 1;
    func_data[0] = 1;
    break;
  case 2:
    grad_div_size = 4;
    grad_div_data[0] = 4;
    grad_div_data[1] = 5;
    grad_div_data[2] = 5;
    grad_div_data[3] = 6;
    lap_size[1] = 2;
    lap_size[0] = 4;
    grad_size[1] = 2;
    grad_size[0] = 4;
    for (::coder::SizeType i{0}; i < 8; i++) {
      lap_data[i] = b_iv[i];
      grad_data[i] = b_iv1[i];
    }
    func_size[1] = 2;
    func_size[0] = 2;
    func_data[0] = 1;
    func_data[1] = 0;
    func_data[2] = 0;
    func_data[3] = 1;
    break;
  default: {
    int8_T b_I[9];
    grad_div_size = 9;
    for (::coder::SizeType i{0}; i < 9; i++) {
      grad_div_data[i] = iv5[i];
    }
    lap_size[1] = 3;
    lap_size[0] = 9;
    grad_size[1] = 3;
    grad_size[0] = 9;
    for (::coder::SizeType i{0}; i < 27; i++) {
      lap_data[i] = iv6[i];
      grad_data[i] = iv7[i];
    }
    for (::coder::SizeType i{0}; i < 9; i++) {
      b_I[i] = 0;
    }
    b_I[0] = 1;
    b_I[4] = 1;
    b_I[8] = 1;
    func_size[1] = 3;
    func_size[0] = 3;
    for (::coder::SizeType i{0}; i < 9; i++) {
      func_data[i] = b_I[i];
    }
  } break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if ((ws_graddiv.size(0) != 0) && (!coder::isequal(ws_graddiv))) {
    order = 2;
    //  With full Hessian
  } else if ((ws_lap.size(0) != 0) && (!coder::isequal(ws_lap))) {
    order = -2;
    //  With Laplacian only
    if (b_wls->us.size(1) == 2) {
      lap_size[1] = 2;
      lap_size[0] = 4;
      for (::coder::SizeType i{0}; i < 8; i++) {
        lap_data[i] = b_iv2[i];
      }
    } else if (b_wls->us.size(1) == 3) {
      lap_size[1] = 3;
      lap_size[0] = 9;
      for (::coder::SizeType i{0}; i < 27; i++) {
        lap_data[i] = iv4[i];
      }
    }
  } else if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
             (!coder::isequal(ws_grad))) {
    order = 1;
    //  With gradients only
  } else {
    order = 0;
    //  Function-values only
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, order,
               b_wls->hs_inv, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if (order == 2) {
    wls_update_rhs(b_wls, grad_div_data, grad_div_size, ws_graddiv);
    //  grad-div
  } else {
    wls_update_rhs(b_wls, grad_div_size);
  }
  if ((ws_lap.size(0) != 0) && (!coder::isequal(ws_lap))) {
    wls_update_rhs(b_wls, lap_data, lap_size, ws_lap);
    //  laplacian
  }
  if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
      (!coder::isequal(ws_grad))) {
    d_wls_update_rhs(b_wls, grad_data, grad_size, ws_grad);
    //  gradients
  }
  if ((ws_rho.size(0) != 0) && (!coder::isequal(ws_rho))) {
    wls_update_rhs(b_wls, func_data, func_size, ws_rho);
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  if (ws_rho.size(0) != 0) {
    wls_solve_sys(b_wls, func_data, func_size, ws_rho, vdops);
  } else {
    c_wls_solve_sys(b_wls, func_data, func_size, vdops);
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_uno - Compute the unified Navier operator at evaluation points
void wls_var_uno(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                 const ::coder::array<real_T, 1U> &ws_graddiv,
                 const ::coder::array<real_T, 1U> &ws_lap,
                 const ::coder::array<real_T, 2U> &ws_grad,
                 ::coder::array<real_T, 2U> &vdops)
{
  static const int8_T b_iv[8]{4, 6, 0, 0, 0, 0, 4, 6};
  static const int8_T b_iv1[8]{2, 3, 0, 0, 0, 0, 2, 3};
  static const int8_T b_iv2[8]{4, 5, 0, 0, 0, 0, 4, 5};
  real_T timestamp;
  ::coder::SizeType func_size[2];
  ::coder::SizeType grad_size[2];
  ::coder::SizeType lap_size[2];
  ::coder::SizeType grad_div_size;
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  ::coder::SizeType order;
  int8_T grad_data[27];
  int8_T lap_data[27];
  int8_T func_data[9];
  int8_T grad_div_data[9];
  nevpnts = eval_pnts.size(0);
  //  The rows in the operators will be summed up before for each point
  switch (b_wls->us.size(1)) {
  case 1:
    grad_div_size = 1;
    grad_div_data[0] = 3;
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    grad_size[1] = 1;
    grad_size[0] = 1;
    grad_data[0] = 2;
    func_size[1] = 1;
    func_size[0] = 1;
    func_data[0] = 1;
    break;
  case 2:
    grad_div_size = 4;
    grad_div_data[0] = 4;
    grad_div_data[1] = 5;
    grad_div_data[2] = 5;
    grad_div_data[3] = 6;
    lap_size[1] = 2;
    lap_size[0] = 4;
    grad_size[1] = 2;
    grad_size[0] = 4;
    for (::coder::SizeType i{0}; i < 8; i++) {
      lap_data[i] = b_iv[i];
      grad_data[i] = b_iv1[i];
    }
    func_size[1] = 2;
    func_size[0] = 2;
    func_data[0] = 1;
    func_data[1] = 0;
    func_data[2] = 0;
    func_data[3] = 1;
    break;
  default: {
    int8_T b_I[9];
    grad_div_size = 9;
    for (::coder::SizeType i{0}; i < 9; i++) {
      grad_div_data[i] = iv5[i];
    }
    lap_size[1] = 3;
    lap_size[0] = 9;
    grad_size[1] = 3;
    grad_size[0] = 9;
    for (::coder::SizeType i{0}; i < 27; i++) {
      lap_data[i] = iv6[i];
      grad_data[i] = iv7[i];
    }
    for (::coder::SizeType i{0}; i < 9; i++) {
      b_I[i] = 0;
    }
    b_I[0] = 1;
    b_I[4] = 1;
    b_I[8] = 1;
    func_size[1] = 3;
    func_size[0] = 3;
    for (::coder::SizeType i{0}; i < 9; i++) {
      func_data[i] = b_I[i];
    }
  } break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if ((ws_graddiv.size(0) != 0) && (!coder::isequal(ws_graddiv))) {
    order = 2;
    //  With full Hessian
  } else if ((ws_lap.size(0) != 0) && (!coder::isequal(ws_lap))) {
    order = -2;
    //  With Laplacian only
    if (b_wls->us.size(1) == 2) {
      lap_size[1] = 2;
      lap_size[0] = 4;
      for (::coder::SizeType i{0}; i < 8; i++) {
        lap_data[i] = b_iv2[i];
      }
    } else if (b_wls->us.size(1) == 3) {
      lap_size[1] = 3;
      lap_size[0] = 9;
      for (::coder::SizeType i{0}; i < 27; i++) {
        lap_data[i] = iv4[i];
      }
    }
  } else if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
             (!coder::isequal(ws_grad))) {
    order = 1;
    //  With gradients only
  } else {
    order = 0;
    //  Function-values only
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, order,
               b_wls->hs_inv, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if (order == 2) {
    wls_update_rhs(b_wls, grad_div_data, grad_div_size, ws_graddiv);
    //  grad-div
  } else {
    wls_update_rhs(b_wls, grad_div_size);
  }
  if ((ws_lap.size(0) != 0) && (!coder::isequal(ws_lap))) {
    wls_update_rhs(b_wls, lap_data, lap_size, ws_lap);
    //  laplacian
  }
  if ((ws_grad.size(0) != 0) && (ws_grad.size(1) != 0) &&
      (!coder::isequal(ws_grad))) {
    d_wls_update_rhs(b_wls, grad_data, grad_size, ws_grad);
    //  gradients
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, func_data, func_size, vdops);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_uno - Compute the unified Navier operator at evaluation points
void wls_var_uno5(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  const ::coder::array<real_T, 1U> &ws_graddiv,
                  const ::coder::array<real_T, 1U> &ws_lap,
                  ::coder::array<real_T, 2U> &vdops)
{
  static const int8_T b_iv[8]{4, 6, 0, 0, 0, 0, 4, 6};
  static const int8_T b_iv1[8]{4, 5, 0, 0, 0, 0, 4, 5};
  real_T timestamp;
  ::coder::SizeType func_size[2];
  ::coder::SizeType lap_size[2];
  ::coder::SizeType grad_div_size;
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  ::coder::SizeType order;
  int8_T lap_data[27];
  int8_T func_data[9];
  int8_T grad_div_data[9];
  nevpnts = eval_pnts.size(0);
  //  The rows in the operators will be summed up before for each point
  switch (b_wls->us.size(1)) {
  case 1:
    grad_div_size = 1;
    grad_div_data[0] = 3;
    lap_size[1] = 1;
    lap_size[0] = 1;
    lap_data[0] = 3;
    func_size[1] = 1;
    func_size[0] = 1;
    func_data[0] = 1;
    break;
  case 2:
    grad_div_size = 4;
    grad_div_data[0] = 4;
    grad_div_data[1] = 5;
    grad_div_data[2] = 5;
    grad_div_data[3] = 6;
    lap_size[1] = 2;
    lap_size[0] = 4;
    for (::coder::SizeType i{0}; i < 8; i++) {
      lap_data[i] = b_iv[i];
    }
    func_size[1] = 2;
    func_size[0] = 2;
    func_data[0] = 1;
    func_data[1] = 0;
    func_data[2] = 0;
    func_data[3] = 1;
    break;
  default: {
    int8_T b_I[9];
    grad_div_size = 9;
    for (::coder::SizeType i{0}; i < 9; i++) {
      grad_div_data[i] = iv5[i];
    }
    lap_size[1] = 3;
    lap_size[0] = 9;
    for (::coder::SizeType i{0}; i < 27; i++) {
      lap_data[i] = iv6[i];
    }
    for (::coder::SizeType i{0}; i < 9; i++) {
      b_I[i] = 0;
    }
    b_I[0] = 1;
    b_I[4] = 1;
    b_I[8] = 1;
    func_size[1] = 3;
    func_size[0] = 3;
    for (::coder::SizeType i{0}; i < 9; i++) {
      func_data[i] = b_I[i];
    }
  } break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if ((ws_graddiv.size(0) != 0) && (!coder::isequal(ws_graddiv))) {
    order = 2;
    //  With full Hessian
  } else if ((ws_lap.size(0) != 0) && (!coder::isequal(ws_lap))) {
    order = -2;
    //  With Laplacian only
    if (b_wls->us.size(1) == 2) {
      lap_size[1] = 2;
      lap_size[0] = 4;
      for (::coder::SizeType i{0}; i < 8; i++) {
        lap_data[i] = b_iv1[i];
      }
    } else if (b_wls->us.size(1) == 3) {
      lap_size[1] = 3;
      lap_size[0] = 9;
      for (::coder::SizeType i{0}; i < 27; i++) {
        lap_data[i] = iv4[i];
      }
    }
  } else {
    order = 0;
    //  Function-values only
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, order,
               b_wls->hs_inv, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if (order == 2) {
    wls_update_rhs(b_wls, grad_div_data, grad_div_size, ws_graddiv);
    //  grad-div
  } else {
    wls_update_rhs(b_wls, grad_div_size);
  }
  if ((ws_lap.size(0) != 0) && (!coder::isequal(ws_lap))) {
    wls_update_rhs(b_wls, lap_data, lap_size, ws_lap);
    //  laplacian
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, func_data, func_size, vdops);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

//  wls_var_uno - Compute the unified Navier operator at evaluation points
void wls_var_uno6(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  const ::coder::array<real_T, 1U> &ws_graddiv,
                  ::coder::array<real_T, 2U> &vdops)
{
  real_T timestamp;
  ::coder::SizeType func_size[2];
  ::coder::SizeType grad_div_size;
  ::coder::SizeType nDims;
  ::coder::SizeType nevpnts;
  ::coder::SizeType order;
  int8_T func_data[9];
  int8_T grad_div_data[9];
  nevpnts = eval_pnts.size(0);
  //  The rows in the operators will be summed up before for each point
  switch (b_wls->us.size(1)) {
  case 1:
    grad_div_size = 1;
    grad_div_data[0] = 3;
    func_size[1] = 1;
    func_size[0] = 1;
    func_data[0] = 1;
    break;
  case 2:
    grad_div_size = 4;
    grad_div_data[0] = 4;
    grad_div_data[1] = 5;
    grad_div_data[2] = 5;
    grad_div_data[3] = 6;
    func_size[1] = 2;
    func_size[0] = 2;
    func_data[0] = 1;
    func_data[1] = 0;
    func_data[2] = 0;
    func_data[3] = 1;
    break;
  default: {
    int8_T b_I[9];
    grad_div_size = 9;
    for (::coder::SizeType i{0}; i < 9; i++) {
      grad_div_data[i] = iv5[i];
      b_I[i] = 0;
    }
    b_I[0] = 1;
    b_I[4] = 1;
    b_I[8] = 1;
    func_size[1] = 3;
    func_size[0] = 3;
    for (::coder::SizeType i{0}; i < 9; i++) {
      func_data[i] = b_I[i];
    }
  } break;
  }
  if (b_wls->runtimes.size(0) != 0) {
    timestamp = static_cast<std::chrono::duration<double>>(
                    std::chrono::system_clock::now().time_since_epoch())
                    .count();
  }
  //  Step 1: Tabulate monomial basis functions at evaluation points
  if ((ws_graddiv.size(0) != 0) && (!coder::isequal(ws_graddiv))) {
    order = 2;
    //  With full Hessian
  } else {
    order = 0;
    //  Function-values only
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] - b_wls->origin[dim]) *
            b_wls->hs_inv[dim];
      }
    }
  } else {
    for (::coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (::coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] * b_wls->hs_inv[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  f_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, order,
               b_wls->hs_inv, b_wls->unimono, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  if (order == 2) {
    wls_update_rhs(b_wls, grad_div_data, grad_div_size, ws_graddiv);
    //  grad-div
  } else {
    wls_update_rhs(b_wls, grad_div_size);
  }
  if (b_wls->runtimes.size(0) != 0) {
    real_T timestamp1;
    timestamp1 = static_cast<std::chrono::duration<double>>(
                     std::chrono::system_clock::now().time_since_epoch())
                     .count();
    b_wls->runtimes[2] = timestamp1 - timestamp;
    timestamp = timestamp1;
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  c_wls_solve_sys(b_wls, func_data, func_size, vdops);
  if (b_wls->runtimes.size(0) != 0) {
    real_T t;
    t = static_cast<std::chrono::duration<double>>(
            std::chrono::system_clock::now().time_since_epoch())
            .count();
    b_wls->runtimes[3] = t - timestamp;
  }
}

} // namespace wls

// End of code generation (wls_internal.cpp)
