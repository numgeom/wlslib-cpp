// Copyright 2022 The NumGeom Group, Stony Brook University
// Main developers:
//     wlslib: Xiangmin Jiao, Qiao Chen, Jacob Jones
//     momp2cpp: Xiangmin Jiao, Qiao Chen
//
// wls_internal.cpp
//
// Code generation for function 'wls_internal'
//

// Include files
#include "wls_internal.h"
#include "coder_array.h"
#include "m2c_lib.h"
#include "wls_internal_types.h"
#include "wls_lapack.hpp"
#include <cmath>
#include <cstdio>
#include <cstring>
#include <stdexcept>

// Variable Definitions
namespace wls {
static const real_T dv[7]{333.33333333333331,
                          1000.0,
                          3333.3333333333335,
                          10000.0,
                          100000.0,
                          1.0E+6,
                          1.0E+7};

static const real_T dv1[7]{2.6, 2.0, 1.6, 1.6, 1.6, 1.5, 1.4};

static const int8_T iv[9]{8, 9, 9, 10, 11, 11, 12, 12, 13};

static const int8_T iv1[9]{14, 15, 15, 16, 17, 17, 18, 18, 19};

static const int8_T iv2[9]{2, 3, 4, 0, 0, 0, 0, 0, 0};

static const int8_T iv3[9]{3, 4, 2, 4, 2, 3, 0, 0, 0};

static const int8_T iv4[9]{5, 6, 7, 8, 9, 10, 0, 0, 0};

static const int8_T iv5[18]{7,  10, 6, 0, 8, 0, 6, 0, 5,
                            10, 9,  0, 8, 0, 9, 0, 5, 7};

static const int8_T iv6[9]{5, 6, 8, 6, 7, 9, 8, 9, 10};

} // namespace wls

// Function Declarations
namespace wls {
static inline void b_gen_vander(const ::coder::array<real_T, 2U> &us,
                                coder::SizeType npoints, coder::SizeType degree,
                                const real_T hs_inv_data[],
                                const coder::SizeType hs_inv_size[2],
                                ::coder::array<real_T, 2U> &V);

static inline void b_gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                                   coder::SizeType npoints,
                                   coder::SizeType degree,
                                   const real_T hs_inv_data[],
                                   const coder::SizeType hs_inv_size[2],
                                   ::coder::array<real_T, 2U> &V);

static inline void b_gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                                   coder::SizeType npoints,
                                   coder::SizeType degree,
                                   const real_T hs_inv_data[],
                                   const coder::SizeType hs_inv_size[2],
                                   ::coder::array<real_T, 2U> &V);

static inline void c_gen_vander(const ::coder::array<real_T, 2U> &us,
                                coder::SizeType npoints, coder::SizeType degree,
                                const real_T hs_inv_data[],
                                const coder::SizeType hs_inv_size[2],
                                ::coder::array<real_T, 2U> &V);

static inline void c_gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                                   coder::SizeType npoints,
                                   coder::SizeType degree,
                                   const real_T hs_inv_data[],
                                   const coder::SizeType hs_inv_size[2],
                                   ::coder::array<real_T, 2U> &V);

static inline void c_gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                                   coder::SizeType npoints,
                                   coder::SizeType degree,
                                   const real_T hs_inv_data[],
                                   const coder::SizeType hs_inv_size[2],
                                   ::coder::array<real_T, 2U> &V);

static inline void d_gen_vander(const ::coder::array<real_T, 2U> &us,
                                coder::SizeType npoints, coder::SizeType degree,
                                const real_T hs_inv_data[],
                                const coder::SizeType hs_inv_size[2],
                                ::coder::array<real_T, 2U> &V);

static inline void d_gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                                   coder::SizeType npoints,
                                   coder::SizeType degree,
                                   const real_T hs_inv_data[],
                                   const coder::SizeType hs_inv_size[2],
                                   ::coder::array<real_T, 2U> &V);

static inline void d_gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                                   coder::SizeType npoints,
                                   coder::SizeType degree,
                                   const real_T hs_inv_data[],
                                   const coder::SizeType hs_inv_size[2],
                                   ::coder::array<real_T, 2U> &V);

static inline void e_gen_vander(const ::coder::array<real_T, 2U> &us,
                                coder::SizeType npoints, coder::SizeType degree,
                                const real_T hs_inv_data[],
                                const coder::SizeType hs_inv_size[2],
                                ::coder::array<real_T, 2U> &V);

static inline void e_gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                                   coder::SizeType npoints,
                                   coder::SizeType degree,
                                   const real_T hs_inv_data[],
                                   const coder::SizeType hs_inv_size[2],
                                   ::coder::array<real_T, 2U> &V);

static inline void e_gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                                   coder::SizeType npoints,
                                   coder::SizeType degree,
                                   const real_T hs_inv_data[],
                                   const coder::SizeType hs_inv_size[2],
                                   ::coder::array<real_T, 2U> &V);

static inline real_T find_kth_shortest_dist(::coder::array<real_T, 1U> &arr,
                                            coder::SizeType k,
                                            coder::SizeType l,
                                            coder::SizeType r);

static inline void gen_vander(const ::coder::array<real_T, 2U> &us,
                              coder::SizeType npoints, coder::SizeType degree,
                              coder::SizeType order,
                              const ::coder::array<real_T, 1U> &weights,
                              ::coder::array<real_T, 2U> &V);

static inline void gen_vander(const real_T us_data[],
                              const coder::SizeType us_size[2],
                              coder::SizeType degree,
                              ::coder::array<real_T, 2U> &V);

static inline void gen_vander(const ::coder::array<real_T, 2U> &us,
                              coder::SizeType npoints, coder::SizeType degree,
                              const real_T hs_inv_data[],
                              const coder::SizeType hs_inv_size[2],
                              ::coder::array<real_T, 2U> &V);

static inline void gen_vander(const ::coder::array<real_T, 2U> &us,
                              coder::SizeType npoints, coder::SizeType degree,
                              ::coder::array<real_T, 2U> &V);

static inline void gen_vander(const ::coder::array<real_T, 2U> &us,
                              coder::SizeType npoints, coder::SizeType degree,
                              coder::SizeType order, const real_T hs_inv_data[],
                              const coder::SizeType hs_inv_size[2],
                              ::coder::array<real_T, 2U> &V);

static inline void gen_vander_1d_dag(coder::SizeType degree,
                                     ::coder::array<uint8_T, 2U> &dag);

static inline void gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                                 coder::SizeType npoints,
                                 coder::SizeType degree, coder::SizeType order,
                                 const ::coder::array<real_T, 1U> &weights,
                                 ::coder::array<real_T, 2U> &V);

static inline void gen_vander_2d(const real_T us_data[], coder::SizeType degree,
                                 ::coder::array<real_T, 2U> &V);

static inline void gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                                 coder::SizeType npoints,
                                 coder::SizeType degree,
                                 const real_T hs_inv_data[],
                                 const coder::SizeType hs_inv_size[2],
                                 ::coder::array<real_T, 2U> &V);

static inline void gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                                 coder::SizeType npoints,
                                 coder::SizeType degree,
                                 ::coder::array<real_T, 2U> &V);

static inline void gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                                 coder::SizeType npoints,
                                 coder::SizeType degree, coder::SizeType order,
                                 const real_T hs_inv_data[],
                                 const coder::SizeType hs_inv_size[2],
                                 ::coder::array<real_T, 2U> &V);

static inline void gen_vander_2d_dag(coder::SizeType degree,
                                     ::coder::array<uint8_T, 2U> &dag);

static inline void gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                                 coder::SizeType npoints,
                                 coder::SizeType degree, coder::SizeType order,
                                 const ::coder::array<real_T, 1U> &weights,
                                 ::coder::array<real_T, 2U> &V);

static inline void gen_vander_3d(const real_T us_data[], coder::SizeType degree,
                                 ::coder::array<real_T, 2U> &V);

static inline void gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                                 coder::SizeType npoints,
                                 coder::SizeType degree,
                                 const real_T hs_inv_data[],
                                 const coder::SizeType hs_inv_size[2],
                                 ::coder::array<real_T, 2U> &V);

static inline void gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                                 coder::SizeType npoints,
                                 coder::SizeType degree,
                                 ::coder::array<real_T, 2U> &V);

static inline void gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                                 coder::SizeType npoints,
                                 coder::SizeType degree, coder::SizeType order,
                                 const real_T hs_inv_data[],
                                 const coder::SizeType hs_inv_size[2],
                                 ::coder::array<real_T, 2U> &V);

static inline void gen_vander_3d_dag(coder::SizeType degree,
                                     ::coder::array<uint8_T, 2U> &dag);

static inline void rrqr_factor(const ::coder::array<real_T, 2U> &A,
                               real_T thres, coder::SizeType rowoffset,
                               coder::SizeType coloffset, coder::SizeType m,
                               coder::SizeType n,
                               ::coder::array<real_T, 2U> &QR,
                               ::coder::array<int32_T, 1U> &p, int32_T *rank,
                               ::coder::array<real_T, 1U> &work);

static inline void rrqr_qmulti(const ::coder::array<real_T, 2U> &QR,
                               coder::SizeType m, coder::SizeType n,
                               coder::SizeType rank,
                               ::coder::array<real_T, 2U> &bs,
                               coder::SizeType nrhs,
                               ::coder::array<real_T, 1U> &work);

static inline void rrqr_rtsolve(const ::coder::array<real_T, 2U> &QR,
                                coder::SizeType n, coder::SizeType rank,
                                ::coder::array<real_T, 2U> &bs,
                                coder::SizeType nrhs);

static inline void
wls_buhmann_weights(const ::coder::array<real_T, 2U> &us,
                    coder::SizeType npoints, coder::SizeType degree,
                    const ::coder::array<real_T, 1U> &params_sh,
                    const ::coder::array<real_T, 2U> &params_pw,
                    ::coder::array<real_T, 1U> &ws);

static inline void wls_buhmann_weights(const ::coder::array<real_T, 2U> &us,
                                       coder::SizeType npoints,
                                       coder::SizeType degree,
                                       ::coder::array<real_T, 1U> &ws);

static inline void
wls_eno_weights(const ::coder::array<real_T, 2U> &us, coder::SizeType npoints,
                coder::SizeType degree,
                const ::coder::array<real_T, 2U> &us_unscaled,
                const ::coder::array<real_T, 1U> &params_sh,
                const ::coder::array<real_T, 2U> &params_pw,
                ::coder::array<real_T, 1U> &ws);

static inline void
wls_invdist_weights(const ::coder::array<real_T, 2U> &us,
                    coder::SizeType npoints, coder::SizeType degree,
                    const ::coder::array<real_T, 1U> &params_sh,
                    const ::coder::array<real_T, 2U> &params_pw,
                    ::coder::array<real_T, 1U> &ws);

static inline void wls_invdist_weights(const ::coder::array<real_T, 2U> &us,
                                       coder::SizeType npoints,
                                       coder::SizeType degree,
                                       ::coder::array<real_T, 1U> &ws);

static inline void wls_resize(WlsObject *b_wls, coder::SizeType dim,
                              coder::SizeType nstpnts, coder::SizeType degree,
                              coder::SizeType order, boolean_T use_dag);

} // namespace wls

// Function Definitions
namespace wls {
static void b_gen_vander(const ::coder::array<real_T, 2U> &us,
                         coder::SizeType npoints, coder::SizeType degree,
                         const real_T hs_inv_data[],
                         const coder::SizeType hs_inv_size[2],
                         ::coder::array<real_T, 2U> &V)
{
  switch (us.size(1)) {
  case 1: {
    real_T h_inv_;
    coder::SizeType b_npoints;
    coder::SizeType i;
    coder::SizeType i1;
    coder::SizeType i2;
    coder::SizeType stride;
    boolean_T b;
    boolean_T b1;
    b_npoints = npoints - 1;
    m2cAssert(us.size(1) == 1, "");
    //  Handle input arguments
    if (npoints == 0) {
      b_npoints = us.size(0) - 1;
    } else {
      m2cAssert(npoints <= us.size(0), "Input us is too small.");
    }
    m2cAssert(degree >= 0, "Degree must be nonnegative");
    if (hs_inv_size[1] == 0) {
      h_inv_ = 1.0;
    } else {
      h_inv_ = hs_inv_data[0];
    }
    stride = us.size(0);
    //  Number of row blocks
    V.set_size(degree + 1, us.size(0) << 1);
    //  Compute rows corresponding to function values
    if (degree != 0) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      i = us.size(1) * us.size(0);
      i1 = 0;
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          i2 = us.size(1) * us.size(0) - 1;
          if (i1 > MAX_int32_T - us.size(1)) {
            i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i1 += us.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        V[iPnt] = 1.0;
        V[iPnt + V.size(1)] = us[i1];
      }
    } else {
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        V[iPnt] = 1.0;
      }
    }
    i = degree + 1;
    for (coder::SizeType ii{2}; ii <= i; ii++) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      i1 = us.size(1) * us.size(0);
      i2 = 0;
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= i1)) {
          i2 = 0;
          b = true;
        } else if (b) {
          b = false;
          i2 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          coder::SizeType i3;
          i3 = us.size(1) * us.size(0) - 1;
          if (i2 > MAX_int32_T - us.size(1)) {
            i2 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i2 += us.size(1);
            if (i2 > i3) {
              i2 -= i3;
            }
          }
        }
        V[iPnt + V.size(1) * (ii - 1)] =
            V[iPnt + V.size(1) * (ii - 2)] * us[i2];
      }
    }
    //  Add row blocks corresponding to kth derivatives
    for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
      V[stride + iPnt] = 0.0;
    }
    for (coder::SizeType j{0}; j < degree; j++) {
      real_T s;
      s = h_inv_ * static_cast<real_T>(j + 1);
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * (j + 1)] = V[iPnt + V.size(1) * j] * s;
      }
    }
  } break;
  case 2:
    b_gen_vander_2d(us, npoints, degree, hs_inv_data, hs_inv_size, V);
    break;
  default:
    b_gen_vander_3d(us, npoints, degree, hs_inv_data, hs_inv_size, V);
    break;
  }
}

static void b_gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                            coder::SizeType npoints, coder::SizeType degree,
                            const real_T hs_inv_data[],
                            const coder::SizeType hs_inv_size[2],
                            ::coder::array<real_T, 2U> &V)
{
  real_T hs_inv__idx_0;
  real_T hs_inv__idx_1;
  real_T scaleu;
  real_T scalev;
  coder::SizeType b_degree;
  coder::SizeType c;
  coder::SizeType deg;
  coder::SizeType i;
  coder::SizeType offset;
  coder::SizeType stride;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (hs_inv_size[1] == 0) {
    hs_inv__idx_0 = 1.0;
    hs_inv__idx_1 = 1.0;
  } else {
    hs_inv__idx_0 = hs_inv_data[0];
    hs_inv__idx_1 = hs_inv_data[1];
  }
  stride = us.size(0);
  //  Number of row blocks
  if (degree >= 0) {
    b_degree = (degree + 1) * (degree + 2) / 2;
  } else {
    b_degree = (1 - degree) * (1 - degree);
  }
  V.set_size(b_degree, us.size(0) * 3);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
    }
  } else {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 3;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 2; deg <= i; deg++) {
    for (coder::SizeType j{0}; j < deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt + V.size(1) * c] =
          V[iPnt + V.size(1) * ((c - deg) - 1)] * us[us.size(1) * iPnt + 1];
    }
    c++;
  }
  //  Compute the bi-degree terms if degree<0
  i = -degree;
  for (deg = i; deg >= 1; deg--) {
    for (coder::SizeType k{0}; k < deg; k++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
      }
      c++;
    }
  }
  //  compute higher order confluent Vandermonde matrix blocks incrementally
  m2cAssert(degree != 0, "");
  //  Compute derivative with respect to u
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    b_degree = stride + iPnt;
    V[b_degree] = 0.0;
    V[b_degree + V.size(1)] = V[iPnt] * hs_inv__idx_0;
    V[b_degree + V.size(1) * 2] = 0.0;
  }
  c = 3;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  for (deg = 2; deg <= b_degree; deg++) {
    scaleu = static_cast<real_T>(deg) * hs_inv__idx_0;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] =
          V[iPnt + V.size(1) * (c - deg)] * scaleu;
    }
    c++;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      scaleu -= hs_inv__idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * scaleu;
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
  }
  //  Compute the bi-degree terms if degree<0
  for (coder::SizeType len{i}; len >= 0; len--) {
    scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
    for (coder::SizeType k{0}; k < len; k++) {
      scaleu -= hs_inv__idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - len)] * scaleu;
      }
      c++;
    }
  }
  //  Compute derivative with respect to v
  offset = us.size(0) + us.size(0);
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    b_degree = offset + iPnt;
    V[b_degree] = 0.0;
    V[b_degree + V.size(1)] = 0.0;
    V[b_degree + V.size(1) * 2] = V[iPnt] * hs_inv__idx_1;
  }
  c = 3;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  for (deg = 2; deg <= b_degree; deg++) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    for (coder::SizeType j{0}; j < deg; j++) {
      scalev = (static_cast<real_T>(j) + 1.0) * hs_inv__idx_1;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - deg) - 1)] * scalev;
      }
      c++;
    }
  }
  //  Compute the bi-degree terms if degree<0
  deg = -degree;
  for (coder::SizeType len{i}; len >= 0; len--) {
    deg++;
    scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
    for (coder::SizeType k{0}; k < len; k++) {
      scalev += hs_inv__idx_1;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - len) - 1)] * scalev;
      }
      c++;
    }
  }
  //      compute regular orders if order > 0
}

static void b_gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                            coder::SizeType npoints, coder::SizeType degree,
                            const real_T hs_inv_data[],
                            const coder::SizeType hs_inv_size[2],
                            ::coder::array<real_T, 2U> &V)
{
  real_T hs_inv_idx_0;
  real_T hs_inv_idx_1;
  real_T hs_inv_idx_2;
  real_T scalew;
  coder::SizeType b_degree;
  coder::SizeType balance;
  coder::SizeType c;
  coder::SizeType cornerTriangle;
  coder::SizeType counterBottomRow;
  coder::SizeType d;
  coder::SizeType deg;
  coder::SizeType excess;
  coder::SizeType i;
  coder::SizeType maxLayers;
  coder::SizeType nTermsInLayer;
  coder::SizeType nTermsInPrevLayer;
  coder::SizeType offset;
  coder::SizeType stride;
  coder::SizeType x_tmp;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (hs_inv_size[1] == 0) {
    hs_inv_idx_0 = 1.0;
    hs_inv_idx_1 = 1.0;
    hs_inv_idx_2 = 1.0;
  } else {
    hs_inv_idx_0 = hs_inv_data[0];
    hs_inv_idx_1 = hs_inv_data[1];
    hs_inv_idx_2 = hs_inv_data[2];
  }
  stride = us.size(0);
  //  Allocate storage for V
  if (degree >= 0) {
    b_degree = (degree + 1) * (degree + 2) * (degree + 3) / 6;
  } else {
    b_degree = (1 - degree) * (1 - degree) * (1 - degree);
  }
  V.set_size(b_degree, us.size(0) << 2);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
      V[iPnt + V.size(1) * 3] = us[us.size(1) * iPnt + 2];
    }
  } else {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 4;
  d = 3;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 2; deg <= i; deg++) {
    //  Within each level, use convention of Pascal triangle with x^deg at peak
    for (coder::SizeType j{0}; j < deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * us[us.size(1) * iPnt];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt + V.size(1) * c] =
          V[iPnt + V.size(1) * ((c - d) - 1)] * us[us.size(1) * iPnt + 1];
    }
    c++;
    for (coder::SizeType j{0}; j < d; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] = V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
                                  us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    d = (d + deg) + 1;
  }
  //  Compute the tri-degree terms if degree<0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      coder::SizeType gap;
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 1;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType k{0}; k < deg; k++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] = V[iPnt + V.size(1) * (c - nTermsInLayer)] *
                                    us[us.size(1) * iPnt + 1];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      b_degree = ((degree + degree) + p) - 1;
      if (b_degree < 0) {
        b_degree = 0;
      }
      excess += b_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      gap = (nTermsInPrevLayer + counterBottomRow) - 1;
      x_tmp = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= x_tmp; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - gap)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  m2cAssert(true, "");
  //      compute higher order confluent Vandermonde matrix blocks
  m2cAssert(degree != 0, "");
  // compute derivatives with respect to u
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    b_degree = stride + iPnt;
    V[b_degree] = 0.0;
    V[b_degree + V.size(1)] = V[iPnt] * hs_inv_idx_0;
    V[b_degree + V.size(1) * 2] = 0.0;
    V[b_degree + V.size(1) * 3] = 0.0;
  }
  c = 4;
  d = 3;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 2; deg <= i; deg++) {
    real_T scaleu;
    scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] =
          V[iPnt + V.size(1) * (c - d)] * scaleu;
    }
    c++;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      scaleu -= hs_inv_idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * scaleu;
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] = 0.0;
    }
    for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        b_degree = stride + iPnt;
        V[b_degree + V.size(1) * (c + 1)] =
            V[b_degree + V.size(1) * ((c - d) - deg)] *
            us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
    }
    c += 2;
    d = (d + deg) + 1;
  }
  // tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 1;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          b_degree = stride + iPnt;
          V[b_degree + V.size(1) * c] =
              V[b_degree + V.size(1) * (c - nTermsInLayer)] *
              us[us.size(1) * iPnt + 1];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      b_degree = (((p + degree) << 1) - p) - 1;
      if (b_degree < 0) {
        b_degree = 0;
      }
      excess += b_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = (nTermsInPrevLayer + counterBottomRow) - 1;
      x_tmp = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= x_tmp; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          b_degree = stride + iPnt;
          V[b_degree + V.size(1) * c] =
              V[b_degree + V.size(1) * (c - balance)] *
              us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  // compute derivatives with respect to v
  offset = us.size(0) + us.size(0);
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    b_degree = offset + iPnt;
    V[b_degree] = 0.0;
    V[b_degree + V.size(1)] = 0.0;
    V[b_degree + V.size(1) * 2] = V[iPnt] * hs_inv_idx_1;
    V[b_degree + V.size(1) * 3] = 0.0;
  }
  c = 4;
  d = 4;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 2; deg <= i; deg++) {
    real_T scalev;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    scalev = hs_inv_idx_1;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * scalev;
      }
      scalev += hs_inv_idx_1;
      c++;
    }
    scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] =
          V[iPnt + V.size(1) * (c - d)] * scalev;
    }
    c++;
    for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        b_degree = offset + iPnt;
        V[b_degree + V.size(1) * c] =
            V[b_degree + V.size(1) * ((c - d) - deg)] *
            us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    d = (d + deg) + 1;
  }
  // compute the tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d - 2;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          b_degree = offset + iPnt;
          V[b_degree + V.size(1) * c] =
              V[b_degree + V.size(1) * (c - nTermsInLayer)] *
              us[us.size(1) * iPnt];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      b_degree = (((p + degree) << 1) - p) - 1;
      if (b_degree < 0) {
        b_degree = 0;
      }
      excess += b_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer + 1;
      nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
      balance = nTermsInPrevLayer + counterBottomRow;
      x_tmp = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= x_tmp; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          b_degree = offset + iPnt;
          V[b_degree + V.size(1) * c] =
              V[b_degree + V.size(1) * (c - balance)] *
              us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  // compute derivatives with respect to w
  offset += us.size(0);
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    b_degree = offset + iPnt;
    V[b_degree] = 0.0;
    V[b_degree + V.size(1)] = 0.0;
    V[b_degree + V.size(1) * 2] = 0.0;
    V[b_degree + V.size(1) * 3] = V[iPnt] * hs_inv_idx_2;
  }
  c = 4;
  d = 3;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 2; deg <= i; deg++) {
    for (coder::SizeType j{0}; j <= deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    for (coder::SizeType k{0}; k < deg; k++) {
      x_tmp = (deg - k) - 1;
      for (coder::SizeType b_i{0}; b_i <= x_tmp; b_i++) {
        scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (((c - d) - deg) - 1)] * scalew;
        }
        c++;
      }
    }
    d = (d + deg) + 1;
  }
  // compute tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      coder::SizeType degg;
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType k{0}; k < deg; k++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      x_tmp = p + degree;
      b_degree = ((x_tmp << 1) - p) - 1;
      if (b_degree < 0) {
        b_degree = 0;
      }
      excess += b_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = nTermsInPrevLayer + counterBottomRow;
      degg = -degree;
      for (coder::SizeType k{0}; k < degg; k++) {
        coder::SizeType partition;
        b_degree = (x_tmp - k) - 1;
        if (b_degree < 0) {
          b_degree = -b_degree;
        }
        partition = -degree - b_degree;
        for (coder::SizeType j{0}; j <= partition; j++) {
          scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(iPnt + offset) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - balance)] * scalew;
          }
          c++;
        }
      }
    }
  }
}

static void c_gen_vander(const ::coder::array<real_T, 2U> &us,
                         coder::SizeType npoints, coder::SizeType degree,
                         const real_T hs_inv_data[],
                         const coder::SizeType hs_inv_size[2],
                         ::coder::array<real_T, 2U> &V)
{
  switch (us.size(1)) {
  case 1: {
    real_T h_inv_;
    coder::SizeType V_tmp;
    coder::SizeType b_npoints;
    coder::SizeType i;
    coder::SizeType i1;
    coder::SizeType r;
    coder::SizeType stride;
    boolean_T b;
    boolean_T b1;
    b_npoints = npoints - 1;
    m2cAssert(us.size(1) == 1, "");
    //  Handle input arguments
    if (npoints == 0) {
      b_npoints = us.size(0) - 1;
    } else {
      m2cAssert(npoints <= us.size(0), "Input us is too small.");
    }
    m2cAssert(degree >= 0, "Degree must be nonnegative");
    if (hs_inv_size[1] == 0) {
      h_inv_ = 1.0;
    } else {
      h_inv_ = hs_inv_data[0];
    }
    stride = us.size(0);
    //  Number of row blocks
    V.set_size(degree + 1, us.size(0) * 3);
    //  Compute rows corresponding to function values
    if (degree != 0) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      V_tmp = us.size(1) * us.size(0);
      i = 0;
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= V_tmp)) {
          i = 0;
          b = true;
        } else if (b) {
          b = false;
          i = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          i1 = us.size(1) * us.size(0) - 1;
          if (i > MAX_int32_T - us.size(1)) {
            i = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i += us.size(1);
            if (i > i1) {
              i -= i1;
            }
          }
        }
        V[iPnt] = 1.0;
        V[iPnt + V.size(1)] = us[i];
      }
    } else {
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        V[iPnt] = 1.0;
      }
    }
    V_tmp = degree + 1;
    for (coder::SizeType ii{2}; ii <= V_tmp; ii++) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      i = us.size(1) * us.size(0);
      i1 = 0;
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          coder::SizeType i2;
          i2 = us.size(1) * us.size(0) - 1;
          if (i1 > MAX_int32_T - us.size(1)) {
            i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i1 += us.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        V[iPnt + V.size(1) * (ii - 1)] =
            V[iPnt + V.size(1) * (ii - 2)] * us[i1];
      }
    }
    //  Add row blocks corresponding to kth derivatives
    r = us.size(0);
    for (coder::SizeType k{0}; k < 2; k++) {
      for (coder::SizeType j{0}; j <= k; j++) {
        for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
          V[(r + iPnt) + V.size(1) * j] = 0.0;
        }
      }
      for (coder::SizeType j{k + 1}; j <= degree; j++) {
        real_T s;
        s = h_inv_ * static_cast<real_T>(j);
        for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
          V_tmp = (r + iPnt) + 1;
          V[(V_tmp + V.size(1) * j) - 1] =
              V[((V_tmp - stride) + V.size(1) * (j - 1)) - 1] * s;
        }
      }
      r += stride;
    }
  } break;
  case 2:
    c_gen_vander_2d(us, npoints, degree, hs_inv_data, hs_inv_size, V);
    break;
  default:
    c_gen_vander_3d(us, npoints, degree, hs_inv_data, hs_inv_size, V);
    break;
  }
}

static void c_gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                            coder::SizeType npoints, coder::SizeType degree,
                            const real_T hs_inv_data[],
                            const coder::SizeType hs_inv_size[2],
                            ::coder::array<real_T, 2U> &V)
{
  real_T hs_inv__idx_0;
  real_T hs_inv__idx_1;
  real_T scaleu;
  real_T scalev;
  coder::SizeType b_degree;
  coder::SizeType c;
  coder::SizeType deg;
  coder::SizeType i;
  coder::SizeType i1;
  coder::SizeType i2;
  coder::SizeType offset;
  coder::SizeType offset_prev;
  coder::SizeType stride;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (hs_inv_size[1] == 0) {
    hs_inv__idx_0 = 1.0;
    hs_inv__idx_1 = 1.0;
  } else {
    hs_inv__idx_0 = hs_inv_data[0];
    hs_inv__idx_1 = hs_inv_data[1];
  }
  stride = us.size(0);
  //  Number of row blocks
  if (degree >= 0) {
    b_degree = (degree + 1) * (degree + 2) / 2;
  } else {
    b_degree = (1 - degree) * (1 - degree);
  }
  V.set_size(b_degree, us.size(0) * 6);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
    }
  } else {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 3;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 2; deg <= i; deg++) {
    for (coder::SizeType j{0}; j < deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt + V.size(1) * c] =
          V[iPnt + V.size(1) * ((c - deg) - 1)] * us[us.size(1) * iPnt + 1];
    }
    c++;
  }
  //  Compute the bi-degree terms if degree<0
  i = -degree;
  for (deg = i; deg >= 1; deg--) {
    for (coder::SizeType k{0}; k < deg; k++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
      }
      c++;
    }
  }
  //  compute higher order confluent Vandermonde matrix blocks incrementally
  m2cAssert(degree != 0, "");
  //  Compute derivative with respect to u
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    b_degree = stride + iPnt;
    V[b_degree] = 0.0;
    V[b_degree + V.size(1)] = V[iPnt] * hs_inv__idx_0;
    V[b_degree + V.size(1) * 2] = 0.0;
  }
  c = 3;
  if (degree < 0) {
    i1 = -degree;
  } else {
    i1 = degree;
  }
  for (deg = 2; deg <= i1; deg++) {
    scaleu = static_cast<real_T>(deg) * hs_inv__idx_0;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] =
          V[iPnt + V.size(1) * (c - deg)] * scaleu;
    }
    c++;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      scaleu -= hs_inv__idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * scaleu;
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
  }
  //  Compute the bi-degree terms if degree<0
  for (coder::SizeType len{i}; len >= 0; len--) {
    scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
    for (coder::SizeType k{0}; k < len; k++) {
      scaleu -= hs_inv__idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - len)] * scaleu;
      }
      c++;
    }
  }
  //  Compute derivative with respect to v
  offset = us.size(0) + us.size(0);
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    b_degree = offset + iPnt;
    V[b_degree] = 0.0;
    V[b_degree + V.size(1)] = 0.0;
    V[b_degree + V.size(1) * 2] = V[iPnt] * hs_inv__idx_1;
  }
  c = 3;
  if (degree < 0) {
    i1 = -degree;
  } else {
    i1 = degree;
  }
  for (deg = 2; deg <= i1; deg++) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    for (coder::SizeType j{0}; j < deg; j++) {
      scalev = (static_cast<real_T>(j) + 1.0) * hs_inv__idx_1;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - deg) - 1)] * scalev;
      }
      c++;
    }
  }
  //  Compute the bi-degree terms if degree<0
  deg = -degree;
  for (coder::SizeType len{i}; len >= 0; len--) {
    deg++;
    scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
    for (coder::SizeType k{0}; k < len; k++) {
      scalev += hs_inv__idx_1;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - len) - 1)] * scalev;
      }
      c++;
    }
  }
  //      compute regular orders if order > 0
  m2cAssert(degree != 0, "");
  offset = 3 * us.size(0);
  offset_prev = us.size(0);
  //  Compute derivative with respect to u
  if (degree < 0) {
    i1 = -degree;
  } else {
    i1 = degree;
  }
  for (coder::SizeType b_i{0}; b_i < 2; b_i++) {
    //  Initialize block to zero
    i2 = offset + 1;
    b_degree = offset + npoints;
    for (coder::SizeType col{0}; col < 3; col++) {
      for (coder::SizeType row{i2}; row <= b_degree; row++) {
        V[(row + V.size(1) * col) - 1] = 0.0;
      }
    }
    c = 3;
    for (deg = 2; deg <= i1; deg++) {
      scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
      i2 = deg - 1;
      for (coder::SizeType j{0}; j <= i2; j++) {
        scaleu -= hs_inv__idx_0;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
        }
        c++;
      }
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    //  Compute the bi-degree terms if degree<0
    for (coder::SizeType len{i}; len >= 0; len--) {
      scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
      for (coder::SizeType k{0}; k < len; k++) {
        scaleu -= hs_inv__idx_0;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
        }
        c++;
      }
    }
    offset += stride;
    offset_prev += stride;
  }
  //  Compute derivative with respect to v
  i1 = offset + 1;
  i2 = offset + npoints;
  for (coder::SizeType col{0}; col < 3; col++) {
    for (coder::SizeType row{i1}; row <= i2; row++) {
      V[(row + V.size(1) * col) - 1] = 0.0;
    }
  }
  c = 3;
  if (degree < 0) {
    i1 = -degree;
  } else {
    i1 = degree;
  }
  for (deg = 2; deg <= i1; deg++) {
    for (coder::SizeType j{0}; j < 2; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    for (coder::SizeType j{2}; j <= deg; j++) {
      scalev = static_cast<real_T>(j) * hs_inv__idx_1;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - deg) - 1)] *
            scalev;
      }
      c++;
    }
  }
  //  Compute the bi-degree terms if degree<0
  deg = -degree;
  for (coder::SizeType len{i}; len >= 0; len--) {
    deg++;
    scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
    for (coder::SizeType k{0}; k < len; k++) {
      scalev += hs_inv__idx_1;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - len) - 1)] *
            scalev;
      }
      c++;
    }
  }
}

static void c_gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                            coder::SizeType npoints, coder::SizeType degree,
                            const real_T hs_inv_data[],
                            const coder::SizeType hs_inv_size[2],
                            ::coder::array<real_T, 2U> &V)
{
  real_T hs_inv_idx_0;
  real_T hs_inv_idx_1;
  real_T hs_inv_idx_2;
  real_T scaleu;
  real_T scalev;
  real_T scalew;
  real_T uu2;
  real_T uv;
  real_T uw;
  real_T vv2;
  real_T vw;
  real_T ww2;
  coder::SizeType V_tmp;
  coder::SizeType b_degree;
  coder::SizeType balance;
  coder::SizeType c;
  coder::SizeType cornerTriangle;
  coder::SizeType counterBottomRow;
  coder::SizeType d;
  coder::SizeType deg;
  coder::SizeType degg;
  coder::SizeType excess;
  coder::SizeType i;
  coder::SizeType i1;
  coder::SizeType maxLayers;
  coder::SizeType nTermsInLayer;
  coder::SizeType nTermsInPrevLayer;
  coder::SizeType offset;
  coder::SizeType partition;
  coder::SizeType stride;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (hs_inv_size[1] == 0) {
    hs_inv_idx_0 = 1.0;
    hs_inv_idx_1 = 1.0;
    hs_inv_idx_2 = 1.0;
  } else {
    hs_inv_idx_0 = hs_inv_data[0];
    hs_inv_idx_1 = hs_inv_data[1];
    hs_inv_idx_2 = hs_inv_data[2];
  }
  stride = us.size(0);
  //  Allocate storage for V
  if (degree >= 0) {
    b_degree = (degree + 1) * (degree + 2) * (degree + 3) / 6;
  } else {
    b_degree = (1 - degree) * (1 - degree) * (1 - degree);
  }
  V.set_size(b_degree, us.size(0) * 10);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
      V[iPnt + V.size(1) * 3] = us[us.size(1) * iPnt + 2];
    }
  } else {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 4;
  d = 3;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 2; deg <= i; deg++) {
    //  Within each level, use convention of Pascal triangle with x^deg at peak
    for (coder::SizeType j{0}; j < deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * us[us.size(1) * iPnt];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt + V.size(1) * c] =
          V[iPnt + V.size(1) * ((c - d) - 1)] * us[us.size(1) * iPnt + 1];
    }
    c++;
    for (coder::SizeType j{0}; j < d; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] = V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
                                  us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    d = (d + deg) + 1;
  }
  //  Compute the tri-degree terms if degree<0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      coder::SizeType gap;
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 1;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType k{0}; k < deg; k++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] = V[iPnt + V.size(1) * (c - nTermsInLayer)] *
                                    us[us.size(1) * iPnt + 1];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      b_degree = ((degree + degree) + p) - 1;
      if (b_degree < 0) {
        b_degree = 0;
      }
      excess += b_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      gap = (nTermsInPrevLayer + counterBottomRow) - 1;
      i1 = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= i1; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - gap)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  m2cAssert(true, "");
  //      compute higher order confluent Vandermonde matrix blocks
  m2cAssert(degree != 0, "");
  // compute derivatives with respect to u
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    V_tmp = stride + iPnt;
    V[V_tmp] = 0.0;
    V[V_tmp + V.size(1)] = V[iPnt] * hs_inv_idx_0;
    V[V_tmp + V.size(1) * 2] = 0.0;
    V[V_tmp + V.size(1) * 3] = 0.0;
  }
  c = 4;
  d = 3;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 2; deg <= i; deg++) {
    scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] =
          V[iPnt + V.size(1) * (c - d)] * scaleu;
    }
    c++;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      scaleu -= hs_inv_idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * scaleu;
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] = 0.0;
    }
    for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V_tmp = stride + iPnt;
        V[V_tmp + V.size(1) * (c + 1)] =
            V[V_tmp + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
    }
    c += 2;
    d = (d + deg) + 1;
  }
  // tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 1;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V_tmp = stride + iPnt;
          V[V_tmp + V.size(1) * c] =
              V[V_tmp + V.size(1) * (c - nTermsInLayer)] *
              us[us.size(1) * iPnt + 1];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      b_degree = (((p + degree) << 1) - p) - 1;
      if (b_degree < 0) {
        b_degree = 0;
      }
      excess += b_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = (nTermsInPrevLayer + counterBottomRow) - 1;
      i1 = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= i1; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V_tmp = stride + iPnt;
          V[V_tmp + V.size(1) * c] =
              V[V_tmp + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  // compute derivatives with respect to v
  offset = us.size(0) + us.size(0);
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    V_tmp = offset + iPnt;
    V[V_tmp] = 0.0;
    V[V_tmp + V.size(1)] = 0.0;
    V[V_tmp + V.size(1) * 2] = V[iPnt] * hs_inv_idx_1;
    V[V_tmp + V.size(1) * 3] = 0.0;
  }
  c = 4;
  d = 4;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 2; deg <= i; deg++) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    scalev = hs_inv_idx_1;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * scalev;
      }
      scalev += hs_inv_idx_1;
      c++;
    }
    scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] =
          V[iPnt + V.size(1) * (c - d)] * scalev;
    }
    c++;
    for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V_tmp = offset + iPnt;
        V[V_tmp + V.size(1) * c] =
            V[V_tmp + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    d = (d + deg) + 1;
  }
  // compute the tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d - 2;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V_tmp = offset + iPnt;
          V[V_tmp + V.size(1) * c] =
              V[V_tmp + V.size(1) * (c - nTermsInLayer)] *
              us[us.size(1) * iPnt];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      b_degree = (((p + degree) << 1) - p) - 1;
      if (b_degree < 0) {
        b_degree = 0;
      }
      excess += b_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer + 1;
      nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
      balance = nTermsInPrevLayer + counterBottomRow;
      i1 = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= i1; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V_tmp = offset + iPnt;
          V[V_tmp + V.size(1) * c] =
              V[V_tmp + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  // compute derivatives with respect to w
  offset += us.size(0);
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    b_degree = offset + iPnt;
    V[b_degree] = 0.0;
    V[b_degree + V.size(1)] = 0.0;
    V[b_degree + V.size(1) * 2] = 0.0;
    V[b_degree + V.size(1) * 3] = V[iPnt] * hs_inv_idx_2;
  }
  c = 4;
  d = 3;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 2; deg <= i; deg++) {
    for (coder::SizeType j{0}; j <= deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    for (coder::SizeType k{0}; k < deg; k++) {
      i1 = (deg - k) - 1;
      for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
        scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (((c - d) - deg) - 1)] * scalew;
        }
        c++;
      }
    }
    d = (d + deg) + 1;
  }
  // compute tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType k{0}; k < deg; k++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      V_tmp = p + degree;
      b_degree = ((V_tmp << 1) - p) - 1;
      if (b_degree < 0) {
        b_degree = 0;
      }
      excess += b_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = nTermsInPrevLayer + counterBottomRow;
      degg = -degree;
      for (coder::SizeType k{0}; k < degg; k++) {
        b_degree = (V_tmp - k) - 1;
        if (b_degree < 0) {
          b_degree = -b_degree;
        }
        partition = -degree - b_degree;
        for (coder::SizeType j{0}; j <= partition; j++) {
          scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(iPnt + offset) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - balance)] * scalew;
          }
          c++;
        }
      }
    }
  }
  //  compute du^2
  offset = us.size(0) << 2;
  uu2 = 2.0 * hs_inv_idx_0 * hs_inv_idx_0;
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    b_degree = offset + iPnt;
    V[b_degree] = 0.0;
    V[b_degree + V.size(1)] = 0.0;
    V[b_degree + V.size(1) * 2] = 0.0;
    V[b_degree + V.size(1) * 3] = 0.0;
    V[b_degree + V.size(1) * 4] = uu2 * V[iPnt];
    for (i = 0; i < 5; i++) {
      V[b_degree + V.size(1) * (i + 5)] = 0.0;
    }
  }
  c = 10;
  d = 6;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 3; deg <= i; deg++) {
    scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] =
          V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
    }
    c++;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      scaleu -= hs_inv_idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V_tmp = offset + iPnt;
        V[V_tmp + V.size(1) * (c + 1)] =
            V[V_tmp + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
    }
    c += 2;
    d = (d + deg) + 1;
  }
  // compute tri degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i1 = 1 - degree;
    for (coder::SizeType p{i1}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 1;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V_tmp = offset + iPnt;
          V[V_tmp + V.size(1) * c] =
              V[V_tmp + V.size(1) * (c - nTermsInLayer)] *
              us[us.size(1) * iPnt + 1];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      b_degree = (((p + degree) << 1) - p) - 1;
      if (b_degree < 0) {
        b_degree = 0;
      }
      excess += b_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = (nTermsInPrevLayer + counterBottomRow) - 1;
      b_degree = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= b_degree; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V_tmp = offset + iPnt;
          V[V_tmp + V.size(1) * c] =
              V[V_tmp + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  //      compute du*dv
  offset += us.size(0);
  uv = hs_inv_idx_0 * hs_inv_idx_1;
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    b_degree = offset + iPnt;
    for (i1 = 0; i1 < 5; i1++) {
      V[b_degree + V.size(1) * i1] = 0.0;
    }
    V[b_degree + V.size(1) * 5] = uv * V[iPnt];
    V[b_degree + V.size(1) * 6] = 0.0;
    V[b_degree + V.size(1) * 7] = 0.0;
    V[b_degree + V.size(1) * 8] = 0.0;
    V[b_degree + V.size(1) * 9] = 0.0;
  }
  c = 10;
  d = 7;
  for (deg = 3; deg <= i; deg++) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    scalev = hs_inv_idx_1;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[(iPnt + stride) + V.size(1) * (c - d)] * scalev;
      }
      scalev += hs_inv_idx_1;
      c++;
    }
    scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] =
          V[(iPnt + stride) + V.size(1) * (c - d)] * scalev;
    }
    c++;
    for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V_tmp = offset + iPnt;
        V[V_tmp + V.size(1) * c] =
            V[V_tmp + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    d = (d + deg) + 1;
  }
  // compute the tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3 + 1;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d - 2;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i1 = 1 - degree;
    for (coder::SizeType p{i1}; p <= maxLayers; p++) {
      //  implicitly calculating number of elements in corner Pascal triangles
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((stride << 1) + iPnt) + V.size(1) * (c - nTermsInLayer)] *
              static_cast<real_T>(-degree - kdegree) * hs_inv_idx_0;
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      b_degree = (((p + degree) << 1) - p) - 1;
      if (b_degree < 0) {
        b_degree = 0;
      }
      excess += b_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer + 1;
      nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
      balance = nTermsInPrevLayer + counterBottomRow;
      b_degree = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= b_degree; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V_tmp = offset + iPnt;
          V[V_tmp + V.size(1) * c] =
              V[V_tmp + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  //  compute dv^2
  offset += us.size(0);
  vv2 = 2.0 * hs_inv_idx_1 * hs_inv_idx_1;
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    b_degree = offset + iPnt;
    for (i1 = 0; i1 < 6; i1++) {
      V[b_degree + V.size(1) * i1] = 0.0;
    }
    V[b_degree + V.size(1) * 6] = vv2 * V[iPnt];
    V[b_degree + V.size(1) * 7] = 0.0;
    V[b_degree + V.size(1) * 8] = 0.0;
    V[b_degree + V.size(1) * 9] = 0.0;
  }
  c = 10;
  d = 7;
  if (degree < 0) {
    i1 = -degree;
  } else {
    i1 = degree;
  }
  for (deg = 3; deg <= i1; deg++) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    scalev = hs_inv_idx_1;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[(iPnt + (stride << 1)) + V.size(1) * (c - d)] * scalev;
      }
      scalev += hs_inv_idx_1;
      c++;
    }
    scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] =
          V[((stride << 1) + iPnt) + V.size(1) * (c - d)] * scalev;
    }
    c++;
    for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V_tmp = offset + iPnt;
        V[V_tmp + V.size(1) * c] =
            V[V_tmp + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    d = (d + deg) + 1;
  }
  // compute the tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d - 2;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i1 = 1 - degree;
    for (coder::SizeType p{i1}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V_tmp = offset + iPnt;
          V[V_tmp + V.size(1) * c] =
              V[V_tmp + V.size(1) * (c - nTermsInLayer)] *
              us[us.size(1) * iPnt];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      b_degree = (((p + degree) << 1) - p) - 1;
      if (b_degree < 0) {
        b_degree = 0;
      }
      excess += b_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer + 1;
      nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
      balance = nTermsInPrevLayer + counterBottomRow;
      b_degree = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= b_degree; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V_tmp = offset + iPnt;
          V[V_tmp + V.size(1) * c] =
              V[V_tmp + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  //      compute du*dw
  offset = (offset + us.size(0)) - 1;
  uw = hs_inv_idx_0 * hs_inv_idx_2;
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    b_degree = (offset + iPnt) + 1;
    for (i1 = 0; i1 < 7; i1++) {
      V[b_degree + V.size(1) * i1] = 0.0;
    }
    V[b_degree + V.size(1) * 7] = uw * V[iPnt];
    V[b_degree + V.size(1) * 8] = 0.0;
    V[b_degree + V.size(1) * 9] = 0.0;
  }
  c = 10;
  d = 6;
  for (deg = 3; deg <= i; deg++) {
    for (coder::SizeType j{0}; j <= deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
      }
      c++;
    }
    for (coder::SizeType k{0}; k < deg; k++) {
      i1 = (deg - k) - 1;
      for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
        scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[((offset + iPnt) + V.size(1) * c) + 1] =
              V[(iPnt + stride) + V.size(1) * (((c - d) - deg) - 1)] * scalew;
        }
        c++;
      }
    }
    d = (d + deg) + 1;
  }
  // compute tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3 + 1;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i1 = 1 - degree;
    for (coder::SizeType p{i1}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType k{0}; k < deg; k++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      V_tmp = p + degree;
      b_degree = ((V_tmp << 1) - p) - 1;
      if (b_degree < 0) {
        b_degree = 0;
      }
      excess += b_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = nTermsInPrevLayer + counterBottomRow;
      degg = -degree;
      for (coder::SizeType k{0}; k < degg; k++) {
        b_degree = (V_tmp - k) - 1;
        if (b_degree < 0) {
          b_degree = -b_degree;
        }
        partition = -degree - b_degree;
        for (coder::SizeType j{0}; j <= partition; j++) {
          scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[((iPnt + offset) + V.size(1) * c) + 1] =
                V[(iPnt + stride) + V.size(1) * (c - balance)] * scalew;
          }
          c++;
        }
      }
    }
  }
  //      compute dv*dw
  offset += us.size(0);
  vw = hs_inv_idx_1 * hs_inv_idx_2;
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    b_degree = (offset + iPnt) + 1;
    for (i1 = 0; i1 < 8; i1++) {
      V[b_degree + V.size(1) * i1] = 0.0;
    }
    V[b_degree + V.size(1) * 8] = vw * V[iPnt];
    V[b_degree + V.size(1) * 9] = 0.0;
  }
  c = 10;
  d = 6;
  for (deg = 3; deg <= i; deg++) {
    for (coder::SizeType j{0}; j <= deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
      }
      c++;
    }
    for (coder::SizeType k{0}; k < deg; k++) {
      i1 = (deg - k) - 1;
      for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
        scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[((offset + iPnt) + V.size(1) * c) + 1] =
              V[(iPnt + (stride << 1)) + V.size(1) * (((c - d) - deg) - 1)] *
              scalew;
        }
        c++;
      }
    }
    d = (d + deg) + 1;
  }
  // compute tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3 + 1;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType k{0}; k < deg; k++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      V_tmp = p + degree;
      b_degree = ((V_tmp << 1) - p) - 1;
      if (b_degree < 0) {
        b_degree = 0;
      }
      excess += b_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = nTermsInPrevLayer + counterBottomRow;
      degg = -degree;
      for (coder::SizeType k{0}; k < degg; k++) {
        b_degree = (V_tmp - k) - 1;
        if (b_degree < 0) {
          b_degree = -b_degree;
        }
        partition = -degree - b_degree;
        for (coder::SizeType j{0}; j <= partition; j++) {
          scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[((iPnt + offset) + V.size(1) * c) + 1] =
                V[(iPnt + (stride << 1)) + V.size(1) * (c - balance)] * scalew;
          }
          c++;
        }
      }
    }
  }
  //  compute dw^2
  offset = (offset + us.size(0)) + 1;
  ww2 = 2.0 * hs_inv_idx_2 * hs_inv_idx_2;
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    b_degree = offset + iPnt;
    for (i = 0; i < 9; i++) {
      V[b_degree + V.size(1) * i] = 0.0;
    }
    V[b_degree + V.size(1) * 9] = ww2 * V[iPnt];
  }
  c = 10;
  d = 6;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 3; deg <= i; deg++) {
    for (coder::SizeType j{0}; j <= deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    for (coder::SizeType k{0}; k < deg; k++) {
      i1 = (deg - k) - 1;
      for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
        scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + 3 * stride) + V.size(1) * (((c - d) - deg) - 1)] *
              scalew;
        }
        c++;
      }
    }
    d = (d + deg) + 1;
  }
  // compute tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType k{0}; k < deg; k++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      V_tmp = p + degree;
      b_degree = ((V_tmp << 1) - p) - 1;
      if (b_degree < 0) {
        b_degree = 0;
      }
      excess += b_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = nTermsInPrevLayer + counterBottomRow;
      degg = -degree;
      for (coder::SizeType k{0}; k < degg; k++) {
        b_degree = (V_tmp - k) - 1;
        if (b_degree < 0) {
          b_degree = -b_degree;
        }
        partition = -degree - b_degree;
        for (coder::SizeType j{0}; j <= partition; j++) {
          scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(iPnt + offset) + V.size(1) * c] =
                V[(iPnt + 3 * stride) + V.size(1) * (c - balance)] * scalew;
          }
          c++;
        }
      }
    }
  }
}

static void d_gen_vander(const ::coder::array<real_T, 2U> &us,
                         coder::SizeType npoints, coder::SizeType degree,
                         const real_T hs_inv_data[],
                         const coder::SizeType hs_inv_size[2],
                         ::coder::array<real_T, 2U> &V)
{
  switch (us.size(1)) {
  case 1: {
    real_T h_inv_;
    coder::SizeType b_npoints;
    coder::SizeType i;
    coder::SizeType i1;
    coder::SizeType i2;
    coder::SizeType stride;
    boolean_T b;
    boolean_T b1;
    b_npoints = npoints - 1;
    m2cAssert(us.size(1) == 1, "");
    //  Handle input arguments
    if (npoints == 0) {
      b_npoints = us.size(0) - 1;
    } else {
      m2cAssert(npoints <= us.size(0), "Input us is too small.");
    }
    m2cAssert(degree >= 0, "Degree must be nonnegative");
    if (hs_inv_size[1] == 0) {
      h_inv_ = 1.0;
    } else {
      h_inv_ = hs_inv_data[0];
    }
    stride = us.size(0);
    //  Number of row blocks
    V.set_size(degree + 1, us.size(0) << 1);
    //  Compute rows corresponding to function values
    if (degree != 0) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      i = us.size(1) * us.size(0);
      i1 = 0;
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          i2 = us.size(1) * us.size(0) - 1;
          if (i1 > MAX_int32_T - us.size(1)) {
            i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i1 += us.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        V[iPnt] = 1.0;
        V[iPnt + V.size(1)] = us[i1];
      }
    } else {
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        V[iPnt] = 1.0;
      }
    }
    for (coder::SizeType ii{2}; ii <= degree; ii++) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      i = us.size(1) * us.size(0);
      i1 = 0;
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          i2 = us.size(1) * us.size(0) - 1;
          if (i1 > MAX_int32_T - us.size(1)) {
            i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i1 += us.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        V[iPnt + V.size(1) * (ii - 1)] =
            V[iPnt + V.size(1) * (ii - 2)] * us[i1];
      }
    }
    //  Add row blocks corresponding to kth derivatives
    for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
      V[stride + iPnt] = 0.0;
    }
    for (coder::SizeType j{0}; j < degree; j++) {
      real_T s;
      s = h_inv_ * static_cast<real_T>(j + 1);
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * (j + 1)] = V[iPnt + V.size(1) * j] * s;
      }
    }
    //      Calculate Biharmonic if order = -4
  } break;
  case 2:
    d_gen_vander_2d(us, npoints, degree, hs_inv_data, hs_inv_size, V);
    break;
  default:
    d_gen_vander_3d(us, npoints, degree, hs_inv_data, hs_inv_size, V);
    break;
  }
}

static void d_gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                            coder::SizeType npoints, coder::SizeType degree,
                            const real_T hs_inv_data[],
                            const coder::SizeType hs_inv_size[2],
                            ::coder::array<real_T, 2U> &V)
{
  real_T hs_inv__idx_0;
  real_T hs_inv__idx_1;
  real_T scaleu;
  real_T scalev;
  coder::SizeType b_degree;
  coder::SizeType c;
  coder::SizeType deg;
  coder::SizeType offset;
  coder::SizeType stride;
  coder::SizeType x;
  coder::SizeType x_tmp_tmp;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (hs_inv_size[1] == 0) {
    hs_inv__idx_0 = 1.0;
    hs_inv__idx_1 = 1.0;
  } else {
    hs_inv__idx_0 = hs_inv_data[0];
    hs_inv__idx_1 = hs_inv_data[1];
  }
  stride = us.size(0);
  //  Number of row blocks
  if (degree >= 0) {
    b_degree = (degree + 1) * (degree + 2) / 2;
  } else {
    b_degree = (1 - degree) * (1 - degree);
  }
  V.set_size(b_degree, us.size(0) * 3);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
    }
  } else {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 3;
  x_tmp_tmp = -degree;
  x = -degree;
  if (-degree > 0) {
    x = 1;
  } else if (-degree < 0) {
    x = -1;
  }
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (-x < 0) {
    x = 0;
  } else {
    x = -x;
  }
  x = b_degree - x;
  for (deg = 2; deg <= x; deg++) {
    for (coder::SizeType j{0}; j < deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt + V.size(1) * c] =
          V[iPnt + V.size(1) * ((c - deg) - 1)] * us[us.size(1) * iPnt + 1];
    }
    c++;
  }
  //  Compute the bi-degree terms if degree<0
  for (deg = x_tmp_tmp; deg >= 2; deg--) {
    for (coder::SizeType k{0}; k < deg; k++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
      }
      c++;
    }
  }
  //  compute higher order confluent Vandermonde matrix blocks incrementally
  m2cAssert(degree != 0, "");
  //  Compute derivative with respect to u
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    x = stride + iPnt;
    V[x] = 0.0;
    V[x + V.size(1)] = V[iPnt] * hs_inv__idx_0;
    V[x + V.size(1) * 2] = 0.0;
  }
  c = 3;
  if (degree < 0) {
    x = -degree;
  } else {
    x = degree;
  }
  for (deg = 2; deg <= x; deg++) {
    scaleu = static_cast<real_T>(deg) * hs_inv__idx_0;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] =
          V[iPnt + V.size(1) * (c - deg)] * scaleu;
    }
    c++;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      scaleu -= hs_inv__idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * scaleu;
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
  }
  //  Compute the bi-degree terms if degree<0
  for (coder::SizeType len{x_tmp_tmp}; len >= 0; len--) {
    scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
    for (coder::SizeType k{0}; k < len; k++) {
      scaleu -= hs_inv__idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - len)] * scaleu;
      }
      c++;
    }
  }
  //  Compute derivative with respect to v
  offset = us.size(0) + us.size(0);
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    x = offset + iPnt;
    V[x] = 0.0;
    V[x + V.size(1)] = 0.0;
    V[x + V.size(1) * 2] = V[iPnt] * hs_inv__idx_1;
  }
  c = 3;
  if (degree < 0) {
    x = -degree;
  } else {
    x = degree;
  }
  for (deg = 2; deg <= x; deg++) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    for (coder::SizeType j{0}; j < deg; j++) {
      scalev = (static_cast<real_T>(j) + 1.0) * hs_inv__idx_1;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - deg) - 1)] * scalev;
      }
      c++;
    }
  }
  //  Compute the bi-degree terms if degree<0
  deg = -degree;
  for (coder::SizeType len{x_tmp_tmp}; len >= 0; len--) {
    deg++;
    scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
    for (coder::SizeType k{0}; k < len; k++) {
      scalev += hs_inv__idx_1;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - len) - 1)] * scalev;
      }
      c++;
    }
  }
  //      compute regular orders if order > 0
}

static void d_gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                            coder::SizeType npoints, coder::SizeType degree,
                            const real_T hs_inv_data[],
                            const coder::SizeType hs_inv_size[2],
                            ::coder::array<real_T, 2U> &V)
{
  real_T hs_inv_idx_0;
  real_T hs_inv_idx_1;
  real_T hs_inv_idx_2;
  real_T scalew;
  coder::SizeType b_degree;
  coder::SizeType balance;
  coder::SizeType c;
  coder::SizeType cornerTriangle;
  coder::SizeType counterBottomRow;
  coder::SizeType d;
  coder::SizeType deg;
  coder::SizeType excess;
  coder::SizeType i;
  coder::SizeType maxLayers;
  coder::SizeType nTermsInLayer;
  coder::SizeType nTermsInPrevLayer;
  coder::SizeType offset;
  coder::SizeType stride;
  coder::SizeType x;
  coder::SizeType x_tmp_tmp;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (hs_inv_size[1] == 0) {
    hs_inv_idx_0 = 1.0;
    hs_inv_idx_1 = 1.0;
    hs_inv_idx_2 = 1.0;
  } else {
    hs_inv_idx_0 = hs_inv_data[0];
    hs_inv_idx_1 = hs_inv_data[1];
    hs_inv_idx_2 = hs_inv_data[2];
  }
  stride = us.size(0);
  //  Allocate storage for V
  if (degree >= 0) {
    b_degree = (degree + 1) * (degree + 2) * (degree + 3) / 6;
  } else {
    b_degree = (1 - degree) * (1 - degree) * (1 - degree);
  }
  V.set_size(b_degree, us.size(0) << 2);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
      V[iPnt + V.size(1) * 3] = us[us.size(1) * iPnt + 2];
    }
  } else {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 4;
  d = 3;
  x_tmp_tmp = -degree;
  x = -degree;
  if (-degree > 0) {
    x = 1;
  } else if (-degree < 0) {
    x = -1;
  }
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (-x < 0) {
    x = 0;
  } else {
    x = -x;
  }
  i = b_degree - x;
  for (deg = 2; deg <= i; deg++) {
    //  Within each level, use convention of Pascal triangle with x^deg at peak
    for (coder::SizeType j{0}; j < deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * us[us.size(1) * iPnt];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt + V.size(1) * c] =
          V[iPnt + V.size(1) * ((c - d) - 1)] * us[us.size(1) * iPnt + 1];
    }
    c++;
    for (coder::SizeType j{0}; j < d; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] = V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
                                  us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    d = (d + deg) + 1;
  }
  //  Compute the tri-degree terms if degree<0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3 - 1;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      coder::SizeType gap;
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 1;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType k{0}; k < deg; k++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] = V[iPnt + V.size(1) * (c - nTermsInLayer)] *
                                    us[us.size(1) * iPnt + 1];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      x = ((degree + degree) + p) - 1;
      if (x < 0) {
        x = 0;
      }
      excess += x;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      gap = (nTermsInPrevLayer + counterBottomRow) - 1;
      b_degree = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= b_degree; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - gap)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  m2cAssert(true, "");
  //      compute higher order confluent Vandermonde matrix blocks
  m2cAssert(degree != 0, "");
  // compute derivatives with respect to u
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    x = stride + iPnt;
    V[x] = 0.0;
    V[x + V.size(1)] = V[iPnt] * hs_inv_idx_0;
    V[x + V.size(1) * 2] = 0.0;
    V[x + V.size(1) * 3] = 0.0;
  }
  c = 4;
  d = 3;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 2; deg <= i; deg++) {
    real_T scaleu;
    scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] =
          V[iPnt + V.size(1) * (c - d)] * scaleu;
    }
    c++;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      scaleu -= hs_inv_idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * scaleu;
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] = 0.0;
    }
    for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = stride + iPnt;
        V[x + V.size(1) * (c + 1)] =
            V[x + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
    }
    c += 2;
    d = (d + deg) + 1;
  }
  // tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 1;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = stride + iPnt;
          V[x + V.size(1) * c] = V[x + V.size(1) * (c - nTermsInLayer)] *
                                 us[us.size(1) * iPnt + 1];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      x = (((p + degree) << 1) - p) - 1;
      if (x < 0) {
        x = 0;
      }
      excess += x;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = (nTermsInPrevLayer + counterBottomRow) - 1;
      b_degree = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= b_degree; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = stride + iPnt;
          V[x + V.size(1) * c] =
              V[x + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  // compute derivatives with respect to v
  offset = us.size(0) + us.size(0);
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    x = offset + iPnt;
    V[x] = 0.0;
    V[x + V.size(1)] = 0.0;
    V[x + V.size(1) * 2] = V[iPnt] * hs_inv_idx_1;
    V[x + V.size(1) * 3] = 0.0;
  }
  c = 4;
  d = 4;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 2; deg <= i; deg++) {
    real_T scalev;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    scalev = hs_inv_idx_1;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * scalev;
      }
      scalev += hs_inv_idx_1;
      c++;
    }
    scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] =
          V[iPnt + V.size(1) * (c - d)] * scalev;
    }
    c++;
    for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        V[x + V.size(1) * c] =
            V[x + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    d = (d + deg) + 1;
  }
  // compute the tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d - 2;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = offset + iPnt;
          V[x + V.size(1) * c] =
              V[x + V.size(1) * (c - nTermsInLayer)] * us[us.size(1) * iPnt];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      x = (((p + degree) << 1) - p) - 1;
      if (x < 0) {
        x = 0;
      }
      excess += x;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer + 1;
      nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
      balance = nTermsInPrevLayer + counterBottomRow;
      b_degree = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= b_degree; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = offset + iPnt;
          V[x + V.size(1) * c] =
              V[x + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  // compute derivatives with respect to w
  offset += us.size(0);
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    x = offset + iPnt;
    V[x] = 0.0;
    V[x + V.size(1)] = 0.0;
    V[x + V.size(1) * 2] = 0.0;
    V[x + V.size(1) * 3] = V[iPnt] * hs_inv_idx_2;
  }
  c = 4;
  d = 3;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 2; deg <= i; deg++) {
    for (coder::SizeType j{0}; j <= deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    for (coder::SizeType k{0}; k < deg; k++) {
      b_degree = (deg - k) - 1;
      for (coder::SizeType b_i{0}; b_i <= b_degree; b_i++) {
        scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (((c - d) - deg) - 1)] * scalew;
        }
        c++;
      }
    }
    d = (d + deg) + 1;
  }
  // compute tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType k{0}; k < deg; k++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      b_degree = p + degree;
      x = ((b_degree << 1) - p) - 1;
      if (x < 0) {
        x = 0;
      }
      excess += x;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = nTermsInPrevLayer + counterBottomRow;
      for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
        coder::SizeType partition;
        x = (b_degree - k) - 1;
        if (x < 0) {
          x = -x;
        }
        partition = -degree - x;
        for (coder::SizeType j{0}; j <= partition; j++) {
          scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(iPnt + offset) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - balance)] * scalew;
          }
          c++;
        }
      }
    }
  }
}

static void e_gen_vander(const ::coder::array<real_T, 2U> &us,
                         coder::SizeType npoints, coder::SizeType degree,
                         const real_T hs_inv_data[],
                         const coder::SizeType hs_inv_size[2],
                         ::coder::array<real_T, 2U> &V)
{
  switch (us.size(1)) {
  case 1: {
    real_T h_inv_;
    coder::SizeType V_tmp;
    coder::SizeType b_npoints;
    coder::SizeType i;
    coder::SizeType i1;
    coder::SizeType r;
    coder::SizeType stride;
    boolean_T b;
    boolean_T b1;
    b_npoints = npoints - 1;
    m2cAssert(us.size(1) == 1, "");
    //  Handle input arguments
    if (npoints == 0) {
      b_npoints = us.size(0) - 1;
    } else {
      m2cAssert(npoints <= us.size(0), "Input us is too small.");
    }
    m2cAssert(degree >= 0, "Degree must be nonnegative");
    if (hs_inv_size[1] == 0) {
      h_inv_ = 1.0;
    } else {
      h_inv_ = hs_inv_data[0];
    }
    stride = us.size(0);
    //  Number of row blocks
    V.set_size(degree + 1, us.size(0) * 3);
    //  Compute rows corresponding to function values
    if (degree != 0) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      V_tmp = us.size(1) * us.size(0);
      i = 0;
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= V_tmp)) {
          i = 0;
          b = true;
        } else if (b) {
          b = false;
          i = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          i1 = us.size(1) * us.size(0) - 1;
          if (i > MAX_int32_T - us.size(1)) {
            i = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i += us.size(1);
            if (i > i1) {
              i -= i1;
            }
          }
        }
        V[iPnt] = 1.0;
        V[iPnt + V.size(1)] = us[i];
      }
    } else {
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        V[iPnt] = 1.0;
      }
    }
    V_tmp = degree - 1;
    for (coder::SizeType ii{2}; ii <= V_tmp; ii++) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      i = us.size(1) * us.size(0);
      i1 = 0;
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          coder::SizeType i2;
          i2 = us.size(1) * us.size(0) - 1;
          if (i1 > MAX_int32_T - us.size(1)) {
            i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i1 += us.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        V[iPnt + V.size(1) * (ii - 1)] =
            V[iPnt + V.size(1) * (ii - 2)] * us[i1];
      }
    }
    //  Add row blocks corresponding to kth derivatives
    r = us.size(0);
    //      computing negative orders
    for (coder::SizeType k{0}; k < 2; k++) {
      for (coder::SizeType j{0}; j <= k; j++) {
        for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
          V[(r + iPnt) + V.size(1) * j] = 0.0;
        }
      }
      for (coder::SizeType j{k + 1}; j <= degree; j++) {
        real_T s;
        s = h_inv_ * static_cast<real_T>(j);
        for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
          V_tmp = (r + iPnt) + 1;
          V[(V_tmp + V.size(1) * j) - 1] =
              V[((V_tmp - stride) + V.size(1) * (j - 1)) - 1] * s;
        }
      }
      r += stride;
    }
    //      Calculate Biharmonic if order = -4
  } break;
  case 2:
    e_gen_vander_2d(us, npoints, degree, hs_inv_data, hs_inv_size, V);
    break;
  default:
    e_gen_vander_3d(us, npoints, degree, hs_inv_data, hs_inv_size, V);
    break;
  }
}

static void e_gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                            coder::SizeType npoints, coder::SizeType degree,
                            const real_T hs_inv_data[],
                            const coder::SizeType hs_inv_size[2],
                            ::coder::array<real_T, 2U> &V)
{
  real_T hs_inv__idx_0;
  real_T hs_inv__idx_1;
  real_T scaleu;
  real_T scalev;
  coder::SizeType b_degree;
  coder::SizeType c;
  coder::SizeType deg;
  coder::SizeType i;
  coder::SizeType offset;
  coder::SizeType offset_prev;
  coder::SizeType stride;
  coder::SizeType x;
  coder::SizeType x_tmp_tmp;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (hs_inv_size[1] == 0) {
    hs_inv__idx_0 = 1.0;
    hs_inv__idx_1 = 1.0;
  } else {
    hs_inv__idx_0 = hs_inv_data[0];
    hs_inv__idx_1 = hs_inv_data[1];
  }
  stride = us.size(0);
  //  Number of row blocks
  if (degree >= 0) {
    b_degree = (degree + 1) * (degree + 2) / 2;
  } else {
    b_degree = (1 - degree) * (1 - degree);
  }
  V.set_size(b_degree, us.size(0) * 5);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
    }
  } else {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 3;
  x_tmp_tmp = -degree;
  x = -degree;
  if (-degree > 0) {
    x = 1;
  } else if (-degree < 0) {
    x = -1;
  }
  x *= -2;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (x < 0) {
    x = 0;
  }
  b_degree -= x;
  for (deg = 2; deg <= b_degree; deg++) {
    for (coder::SizeType j{0}; j < deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt + V.size(1) * c] =
          V[iPnt + V.size(1) * ((c - deg) - 1)] * us[us.size(1) * iPnt + 1];
    }
    c++;
  }
  //  Compute the bi-degree terms if degree<0
  for (deg = x_tmp_tmp; deg >= 3; deg--) {
    for (coder::SizeType k{0}; k < deg; k++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
      }
      c++;
    }
  }
  //  compute higher order confluent Vandermonde matrix blocks incrementally
  m2cAssert(degree != 0, "");
  //  Compute derivative with respect to u
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    x = stride + iPnt;
    V[x] = 0.0;
    V[x + V.size(1)] = V[iPnt] * hs_inv__idx_0;
    V[x + V.size(1) * 2] = 0.0;
  }
  c = 3;
  x = -degree;
  if (-degree > 0) {
    x = 1;
  } else if (-degree < 0) {
    x = -1;
  }
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (-x < 0) {
    x = 0;
  } else {
    x = -x;
  }
  b_degree -= x;
  for (deg = 2; deg <= b_degree; deg++) {
    scaleu = static_cast<real_T>(deg) * hs_inv__idx_0;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] =
          V[iPnt + V.size(1) * (c - deg)] * scaleu;
    }
    c++;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      scaleu -= hs_inv__idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * scaleu;
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
  }
  //  Compute the bi-degree terms if degree<0
  for (coder::SizeType len{x_tmp_tmp}; len >= -1; len--) {
    scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
    for (coder::SizeType k{0}; k < len; k++) {
      scaleu -= hs_inv__idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - len)] * scaleu;
      }
      c++;
    }
  }
  //  Compute derivative with respect to v
  offset = us.size(0) + us.size(0);
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    x = offset + iPnt;
    V[x] = 0.0;
    V[x + V.size(1)] = 0.0;
    V[x + V.size(1) * 2] = V[iPnt] * hs_inv__idx_1;
  }
  c = 3;
  x = -degree;
  if (-degree > 0) {
    x = 1;
  } else if (-degree < 0) {
    x = -1;
  }
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (-x < 0) {
    x = 0;
  } else {
    x = -x;
  }
  b_degree -= x;
  for (deg = 2; deg <= b_degree; deg++) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    for (coder::SizeType j{0}; j < deg; j++) {
      scalev = (static_cast<real_T>(j) + 1.0) * hs_inv__idx_1;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - deg) - 1)] * scalev;
      }
      c++;
    }
  }
  //  Compute the bi-degree terms if degree<0
  deg = -degree;
  for (coder::SizeType len{x_tmp_tmp}; len >= -1; len--) {
    deg++;
    scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
    for (coder::SizeType k{0}; k < len; k++) {
      scalev += hs_inv__idx_1;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - len) - 1)] * scalev;
      }
      c++;
    }
  }
  //      compute regular orders if order > 0
  m2cAssert(degree != 0, "");
  offset = 3 * us.size(0);
  offset_prev = us.size(0);
  //  Compute derivative with respect to u
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  //  Initialize block to zero
  i = offset + 1;
  x = offset + npoints;
  for (coder::SizeType col{0}; col < 3; col++) {
    for (coder::SizeType row{i}; row <= x; row++) {
      V[(row + V.size(1) * col) - 1] = 0.0;
    }
  }
  c = 3;
  for (deg = 2; deg <= b_degree; deg++) {
    scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
    i = deg - 1;
    for (coder::SizeType j{0}; j <= i; j++) {
      scaleu -= hs_inv__idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
  }
  //  Compute the bi-degree terms if degree<0
  for (coder::SizeType len{x_tmp_tmp}; len >= -2; len--) {
    scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
    for (coder::SizeType k{0}; k < len; k++) {
      scaleu -= hs_inv__idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
      }
      c++;
    }
  }
  offset += us.size(0);
  //  Compute derivative with respect to v
  offset_prev = (us.size(0) + us.size(0)) + us.size(0);
  b_degree = offset + 1;
  i = offset + npoints;
  for (coder::SizeType col{0}; col < 3; col++) {
    for (coder::SizeType row{b_degree}; row <= i; row++) {
      V[(row + V.size(1) * col) - 1] = 0.0;
    }
  }
  c = 3;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  for (deg = 2; deg <= b_degree; deg++) {
    for (coder::SizeType j{0}; j < 2; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    for (coder::SizeType j{2}; j <= deg; j++) {
      scalev = static_cast<real_T>(j) * hs_inv__idx_1;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - deg) - 1)] *
            scalev;
      }
      c++;
    }
  }
  //  Compute the bi-degree terms if degree<0
  deg = -degree;
  for (coder::SizeType len{x_tmp_tmp}; len >= -2; len--) {
    deg++;
    scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
    for (coder::SizeType k{0}; k < len; k++) {
      scalev += hs_inv__idx_1;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - len) - 1)] *
            scalev;
      }
      c++;
    }
  }
}

static void e_gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                            coder::SizeType npoints, coder::SizeType degree,
                            const real_T hs_inv_data[],
                            const coder::SizeType hs_inv_size[2],
                            ::coder::array<real_T, 2U> &V)
{
  real_T hs_inv_idx_0;
  real_T hs_inv_idx_1;
  real_T hs_inv_idx_2;
  real_T scaleu;
  real_T scalev;
  real_T scalew;
  real_T uu2;
  real_T vv2;
  real_T ww2;
  coder::SizeType b_degree;
  coder::SizeType balance;
  coder::SizeType c;
  coder::SizeType cornerTriangle;
  coder::SizeType counterBottomRow;
  coder::SizeType d;
  coder::SizeType deg;
  coder::SizeType excess;
  coder::SizeType i;
  coder::SizeType maxLayers;
  coder::SizeType nTermsInLayer;
  coder::SizeType nTermsInPrevLayer;
  coder::SizeType offset;
  coder::SizeType partition;
  coder::SizeType stride;
  coder::SizeType x;
  coder::SizeType x_tmp_tmp;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (hs_inv_size[1] == 0) {
    hs_inv_idx_0 = 1.0;
    hs_inv_idx_1 = 1.0;
    hs_inv_idx_2 = 1.0;
  } else {
    hs_inv_idx_0 = hs_inv_data[0];
    hs_inv_idx_1 = hs_inv_data[1];
    hs_inv_idx_2 = hs_inv_data[2];
  }
  stride = us.size(0);
  //  Allocate storage for V
  if (degree >= 0) {
    b_degree = (degree + 1) * (degree + 2) * (degree + 3) / 6;
  } else {
    b_degree = (1 - degree) * (1 - degree) * (1 - degree);
  }
  V.set_size(b_degree, us.size(0) * 7);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
      V[iPnt + V.size(1) * 3] = us[us.size(1) * iPnt + 2];
    }
  } else {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 4;
  d = 3;
  x_tmp_tmp = -degree;
  x = -degree;
  if (-degree > 0) {
    x = 1;
  } else if (-degree < 0) {
    x = -1;
  }
  x *= -2;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (x < 0) {
    x = 0;
  }
  i = b_degree - x;
  for (deg = 2; deg <= i; deg++) {
    //  Within each level, use convention of Pascal triangle with x^deg at peak
    for (coder::SizeType j{0}; j < deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * us[us.size(1) * iPnt];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt + V.size(1) * c] =
          V[iPnt + V.size(1) * ((c - d) - 1)] * us[us.size(1) * iPnt + 1];
    }
    c++;
    for (coder::SizeType j{0}; j < d; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] = V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
                                  us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    d = (d + deg) + 1;
  }
  //  Compute the tri-degree terms if degree<0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3 - 2;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      coder::SizeType gap;
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 1;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType k{0}; k < deg; k++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] = V[iPnt + V.size(1) * (c - nTermsInLayer)] *
                                    us[us.size(1) * iPnt + 1];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      x = ((degree + degree) + p) - 1;
      if (x < 0) {
        x = 0;
      }
      excess += x;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      gap = (nTermsInPrevLayer + counterBottomRow) - 1;
      b_degree = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= b_degree; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - gap)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  m2cAssert(true, "");
  //      compute higher order confluent Vandermonde matrix blocks
  m2cAssert(degree != 0, "");
  // compute derivatives with respect to u
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    x = stride + iPnt;
    V[x] = 0.0;
    V[x + V.size(1)] = V[iPnt] * hs_inv_idx_0;
    V[x + V.size(1) * 2] = 0.0;
    V[x + V.size(1) * 3] = 0.0;
  }
  c = 4;
  d = 3;
  x = -degree;
  if (-degree > 0) {
    x = 1;
  } else if (-degree < 0) {
    x = -1;
  }
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (-x < 0) {
    x = 0;
  } else {
    x = -x;
  }
  i = b_degree - x;
  for (deg = 2; deg <= i; deg++) {
    scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] =
          V[iPnt + V.size(1) * (c - d)] * scaleu;
    }
    c++;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      scaleu -= hs_inv_idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * scaleu;
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] = 0.0;
    }
    for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = stride + iPnt;
        V[x + V.size(1) * (c + 1)] =
            V[x + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
    }
    c += 2;
    d = (d + deg) + 1;
  }
  // tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3 - 1;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 1;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = stride + iPnt;
          V[x + V.size(1) * c] = V[x + V.size(1) * (c - nTermsInLayer)] *
                                 us[us.size(1) * iPnt + 1];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      x = (((p + degree) << 1) - p) - 1;
      if (x < 0) {
        x = 0;
      }
      excess += x;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = (nTermsInPrevLayer + counterBottomRow) - 1;
      b_degree = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= b_degree; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = stride + iPnt;
          V[x + V.size(1) * c] =
              V[x + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  // compute derivatives with respect to v
  offset = us.size(0) + us.size(0);
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    x = offset + iPnt;
    V[x] = 0.0;
    V[x + V.size(1)] = 0.0;
    V[x + V.size(1) * 2] = V[iPnt] * hs_inv_idx_1;
    V[x + V.size(1) * 3] = 0.0;
  }
  c = 4;
  d = 4;
  x = -degree;
  if (-degree > 0) {
    x = 1;
  } else if (-degree < 0) {
    x = -1;
  }
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (-x < 0) {
    x = 0;
  } else {
    x = -x;
  }
  i = b_degree - x;
  for (deg = 2; deg <= i; deg++) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    scalev = hs_inv_idx_1;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * scalev;
      }
      scalev += hs_inv_idx_1;
      c++;
    }
    scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] =
          V[iPnt + V.size(1) * (c - d)] * scalev;
    }
    c++;
    for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        V[x + V.size(1) * c] =
            V[x + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    d = (d + deg) + 1;
  }
  // compute the tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3 - 1;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d - 2;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = offset + iPnt;
          V[x + V.size(1) * c] =
              V[x + V.size(1) * (c - nTermsInLayer)] * us[us.size(1) * iPnt];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      x = (((p + degree) << 1) - p) - 1;
      if (x < 0) {
        x = 0;
      }
      excess += x;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer + 1;
      nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
      balance = nTermsInPrevLayer + counterBottomRow;
      b_degree = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= b_degree; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = offset + iPnt;
          V[x + V.size(1) * c] =
              V[x + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  // compute derivatives with respect to w
  offset += us.size(0);
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    x = offset + iPnt;
    V[x] = 0.0;
    V[x + V.size(1)] = 0.0;
    V[x + V.size(1) * 2] = 0.0;
    V[x + V.size(1) * 3] = V[iPnt] * hs_inv_idx_2;
  }
  c = 4;
  d = 3;
  x = -degree;
  if (-degree > 0) {
    x = 1;
  } else if (-degree < 0) {
    x = -1;
  }
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (-x < 0) {
    x = 0;
  } else {
    x = -x;
  }
  i = b_degree - x;
  for (deg = 2; deg <= i; deg++) {
    for (coder::SizeType j{0}; j <= deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    for (coder::SizeType k{0}; k < deg; k++) {
      b_degree = (deg - k) - 1;
      for (coder::SizeType b_i{0}; b_i <= b_degree; b_i++) {
        scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (((c - d) - deg) - 1)] * scalew;
        }
        c++;
      }
    }
    d = (d + deg) + 1;
  }
  // compute tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3 - 1;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType k{0}; k < deg; k++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      b_degree = p + degree;
      x = ((b_degree << 1) - p) - 1;
      if (x < 0) {
        x = 0;
      }
      excess += x;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = nTermsInPrevLayer + counterBottomRow;
      for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
        x = (b_degree - k) - 1;
        if (x < 0) {
          x = -x;
        }
        partition = -degree - x;
        for (coder::SizeType j{0}; j <= partition; j++) {
          scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(iPnt + offset) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - balance)] * scalew;
          }
          c++;
        }
      }
    }
  }
  //  compute du^2
  offset = us.size(0) << 2;
  uu2 = 2.0 * hs_inv_idx_0 * hs_inv_idx_0;
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    x = offset + iPnt;
    V[x] = 0.0;
    V[x + V.size(1)] = 0.0;
    V[x + V.size(1) * 2] = 0.0;
    V[x + V.size(1) * 3] = 0.0;
    V[x + V.size(1) * 4] = uu2 * V[iPnt];
    for (i = 0; i < 5; i++) {
      V[x + V.size(1) * (i + 5)] = 0.0;
    }
  }
  c = 10;
  d = 6;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 3; deg <= i; deg++) {
    scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] =
          V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
    }
    c++;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      scaleu -= hs_inv_idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        V[x + V.size(1) * (c + 1)] =
            V[x + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
    }
    c += 2;
    d = (d + deg) + 1;
  }
  // compute tri degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 1;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = offset + iPnt;
          V[x + V.size(1) * c] = V[x + V.size(1) * (c - nTermsInLayer)] *
                                 us[us.size(1) * iPnt + 1];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      x = (((p + degree) << 1) - p) - 1;
      if (x < 0) {
        x = 0;
      }
      excess += x;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = (nTermsInPrevLayer + counterBottomRow) - 1;
      b_degree = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= b_degree; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = offset + iPnt;
          V[x + V.size(1) * c] =
              V[x + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  //  compute dv^2
  offset += us.size(0);
  vv2 = 2.0 * hs_inv_idx_1 * hs_inv_idx_1;
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    x = offset + iPnt;
    for (i = 0; i < 6; i++) {
      V[x + V.size(1) * i] = 0.0;
    }
    V[x + V.size(1) * 6] = vv2 * V[iPnt];
    V[x + V.size(1) * 7] = 0.0;
    V[x + V.size(1) * 8] = 0.0;
    V[x + V.size(1) * 9] = 0.0;
  }
  c = 10;
  d = 7;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 3; deg <= i; deg++) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    scalev = hs_inv_idx_1;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[(iPnt + (stride << 1)) + V.size(1) * (c - d)] * scalev;
      }
      scalev += hs_inv_idx_1;
      c++;
    }
    scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] =
          V[((stride << 1) + iPnt) + V.size(1) * (c - d)] * scalev;
    }
    c++;
    for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        V[x + V.size(1) * c] =
            V[x + V.size(1) * ((c - d) - deg)] * us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    d = (d + deg) + 1;
  }
  // compute the tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d - 2;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = offset + iPnt;
          V[x + V.size(1) * c] =
              V[x + V.size(1) * (c - nTermsInLayer)] * us[us.size(1) * iPnt];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      x = (((p + degree) << 1) - p) - 1;
      if (x < 0) {
        x = 0;
      }
      excess += x;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer + 1;
      nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
      balance = nTermsInPrevLayer + counterBottomRow;
      b_degree = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= b_degree; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = offset + iPnt;
          V[x + V.size(1) * c] =
              V[x + V.size(1) * (c - balance)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  //  compute dw^2
  offset += us.size(0);
  ww2 = 2.0 * hs_inv_idx_2 * hs_inv_idx_2;
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    x = offset + iPnt;
    for (i = 0; i < 9; i++) {
      V[x + V.size(1) * i] = 0.0;
    }
    V[x + V.size(1) * 9] = ww2 * V[iPnt];
  }
  c = 10;
  d = 6;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 3; deg <= i; deg++) {
    for (coder::SizeType j{0}; j <= deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    for (coder::SizeType k{0}; k < deg; k++) {
      b_degree = (deg - k) - 1;
      for (coder::SizeType b_i{0}; b_i <= b_degree; b_i++) {
        scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + 3 * stride) + V.size(1) * (((c - d) - deg) - 1)] *
              scalew;
        }
        c++;
      }
    }
    d = (d + deg) + 1;
  }
  // compute tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType k{0}; k < deg; k++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      b_degree = p + degree;
      x = ((b_degree << 1) - p) - 1;
      if (x < 0) {
        x = 0;
      }
      excess += x;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = nTermsInPrevLayer + counterBottomRow;
      for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
        x = (b_degree - k) - 1;
        if (x < 0) {
          x = -x;
        }
        partition = -degree - x;
        for (coder::SizeType j{0}; j <= partition; j++) {
          scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(iPnt + offset) + V.size(1) * c] =
                V[(iPnt + 3 * stride) + V.size(1) * (c - balance)] * scalew;
          }
          c++;
        }
      }
    }
  }
}

static real_T find_kth_shortest_dist(::coder::array<real_T, 1U> &arr,
                                     coder::SizeType k, coder::SizeType l,
                                     coder::SizeType r)
{
  real_T dist;
  real_T val;
  coder::SizeType i;
  coder::SizeType j;
  //  Find the kth smallest number in arr(l:r).
  if (k < l) {
    k = l;
  }
  if (k > r) {
    k = r;
  }
  val = arr[l - 1];
  i = l;
  j = r;
  while (i <= j) {
    real_T d;
    real_T d1;
    coder::SizeType exitg1;
    do {
      exitg1 = 0;
      d = arr[i - 1];
      if (d < val) {
        i++;
      } else {
        exitg1 = 1;
      }
    } while (exitg1 == 0);
    do {
      exitg1 = 0;
      d1 = arr[j - 1];
      if (d1 > val) {
        j--;
      } else {
        exitg1 = 1;
      }
    } while (exitg1 == 0);
    if (i <= j) {
      arr[i - 1] = d1;
      arr[j - 1] = d;
      i++;
      j--;
    }
  }
  if (k <= j) {
    dist = find_kth_shortest_dist(arr, k, l, j);
  } else if (k >= i) {
    dist = find_kth_shortest_dist(arr, k, i, r);
  } else {
    dist = val;
  }
  return dist;
}

//  gen_vander  Wrapper function for computing confluent Vandermonde matrix in
static void gen_vander(const ::coder::array<real_T, 2U> &us,
                       coder::SizeType npoints, coder::SizeType degree,
                       coder::SizeType order,
                       const ::coder::array<real_T, 1U> &weights,
                       ::coder::array<real_T, 2U> &V)
{
  switch (us.size(1)) {
  case 1: {
    coder::SizeType i;
    coder::SizeType i1;
    coder::SizeType nrblks;
    coder::SizeType r;
    coder::SizeType stride;
    coder::SizeType u0;
    boolean_T b;
    boolean_T b1;
    m2cAssert(us.size(1) == 1, "");
    //  Handle input arguments
    m2cAssert(npoints <= us.size(0), "Input us is too small.");
    m2cAssert(degree >= 0, "Degree must be nonnegative");
    if ((order < -4) || (order == -3)) {
      m2cErrMsgIdAndTxt("wlslib:WrongOrder",
                        "Order %d must be 0, 1, 2, -1, -2, or -4", (int)order);
    }
    stride = us.size(0);
    nrblks = order + 1;
    //  Number of row blocks
    switch (order) {
    case -1:
      nrblks = 2;
      break;
    case -2:
      nrblks = 3;
      break;
    case -4:
      nrblks = 4;
      break;
    }
    V.set_size(degree + 1, us.size(0) * nrblks);
    //  Compute rows corresponding to function values
    if (weights.size(0) == 0) {
      if (degree != 0) {
        b = true;
        b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
        i = us.size(1) * us.size(0);
        u0 = 0;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          if (b1 || (iPnt >= i)) {
            u0 = 0;
            b = true;
          } else if (b) {
            b = false;
            u0 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (u0 > MAX_int32_T - us.size(1)) {
              u0 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
            } else {
              u0 += us.size(1);
              if (u0 > i1) {
                u0 -= i1;
              }
            }
          }
          V[iPnt] = 1.0;
          V[iPnt + V.size(1)] = us[u0];
        }
      } else {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt] = 1.0;
        }
      }
    } else if (degree != 0) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      i = us.size(1) * us.size(0);
      u0 = 0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        if (b1 || (iPnt >= i)) {
          u0 = 0;
          b = true;
        } else if (b) {
          b = false;
          u0 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          i1 = us.size(1) * us.size(0) - 1;
          if (u0 > MAX_int32_T - us.size(1)) {
            u0 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            u0 += us.size(1);
            if (u0 > i1) {
              u0 -= i1;
            }
          }
        }
        V[iPnt] = weights[iPnt];
        V[iPnt + V.size(1)] = us[u0] * weights[iPnt];
      }
    } else {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt] = weights[iPnt];
      }
    }
    u0 = order;
    if (order > 0) {
      u0 = 0;
    }
    i = (degree + u0) + 1;
    for (coder::SizeType ii{2}; ii <= i; ii++) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      u0 = us.size(1) * us.size(0);
      i1 = 0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        if (b1 || (iPnt >= u0)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          coder::SizeType i2;
          i2 = us.size(1) * us.size(0) - 1;
          if (i1 > MAX_int32_T - us.size(1)) {
            i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i1 += us.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        V[iPnt + V.size(1) * (ii - 1)] =
            V[iPnt + V.size(1) * (ii - 2)] * us[i1];
      }
    }
    //  Add row blocks corresponding to kth derivatives
    r = us.size(0);
    if (order >= 0) {
      for (coder::SizeType k{0}; k < order; k++) {
        for (coder::SizeType j{0}; j <= k; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(r + iPnt) + V.size(1) * j] = 0.0;
          }
        }
        for (coder::SizeType j{k + 1}; j <= degree; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            u0 = r + iPnt;
            V[u0 + V.size(1) * j] =
                V[(u0 - stride) + V.size(1) * (j - 1)] * static_cast<real_T>(j);
          }
        }
        r += stride;
      }
    } else {
      //      computing negative orders
      if (-order > 2) {
        i = 2;
      } else {
        i = -order;
      }
      for (coder::SizeType k{0}; k < i; k++) {
        for (coder::SizeType j{0}; j <= k; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(r + iPnt) + V.size(1) * j] = 0.0;
          }
        }
        for (coder::SizeType j{k + 1}; j <= degree; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            u0 = r + iPnt;
            V[u0 + V.size(1) * j] =
                V[(u0 - stride) + V.size(1) * (j - 1)] * static_cast<real_T>(j);
          }
        }
        r += stride;
      }
      //      Calculate Biharmonic if order = -4
      if (order == -4) {
        for (coder::SizeType j{0}; j < 4; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(r + iPnt) + V.size(1) * j] = 0.0;
          }
        }
        for (coder::SizeType j{2}; j <= degree; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            u0 = r + iPnt;
            V[u0 + V.size(1) * j] = V[(u0 - stride) + V.size(1) * (j - 2)] *
                                    static_cast<real_T>(j) *
                                    (static_cast<real_T>(j) - 1.0);
          }
        }
      }
    }
  } break;
  case 2:
    gen_vander_2d(us, npoints, degree, order, weights, V);
    break;
  default:
    gen_vander_3d(us, npoints, degree, order, weights, V);
    break;
  }
}

//  gen_vander  Wrapper function for computing confluent Vandermonde matrix in
static void gen_vander(const real_T us_data[], const coder::SizeType us_size[2],
                       coder::SizeType degree, ::coder::array<real_T, 2U> &V)
{
  switch (us_size[1]) {
  case 1: {
    coder::SizeType i;
    m2cAssert(us_size[1] == 1, "");
    //  Handle input arguments
    //  Number of row blocks
    V.set_size(degree + 1, 1);
    //  Compute rows corresponding to function values
    V[0] = 1.0;
    V[V.size(1)] = us_data[0];
    i = degree + 1;
    for (coder::SizeType ii{2}; ii <= i; ii++) {
      V[V.size(1) * (ii - 1)] = V[V.size(1) * (ii - 2)] * us_data[0];
    }
    //  Add row blocks corresponding to kth derivatives
  } break;
  case 2:
    gen_vander_2d(us_data, degree, V);
    break;
  default:
    gen_vander_3d(us_data, degree, V);
    break;
  }
}

//  gen_vander  Wrapper function for computing confluent Vandermonde matrix in
static void gen_vander(const ::coder::array<real_T, 2U> &us,
                       coder::SizeType npoints, coder::SizeType degree,
                       coder::SizeType order, const real_T hs_inv_data[],
                       const coder::SizeType hs_inv_size[2],
                       ::coder::array<real_T, 2U> &V)
{
  switch (us.size(1)) {
  case 1: {
    real_T h_inv_;
    coder::SizeType b_npoints;
    coder::SizeType i;
    coder::SizeType i1;
    coder::SizeType nrblks;
    coder::SizeType r;
    coder::SizeType stride;
    coder::SizeType u0;
    boolean_T b;
    boolean_T b1;
    b_npoints = npoints - 1;
    m2cAssert(us.size(1) == 1, "");
    //  Handle input arguments
    if (npoints == 0) {
      b_npoints = us.size(0) - 1;
    } else {
      m2cAssert(npoints <= us.size(0), "Input us is too small.");
    }
    m2cAssert(degree >= 0, "Degree must be nonnegative");
    if ((order < -4) || (order == -3)) {
      m2cErrMsgIdAndTxt("wlslib:WrongOrder",
                        "Order %d must be 0, 1, 2, -1, -2, or -4", (int)order);
    }
    if (hs_inv_size[1] == 0) {
      h_inv_ = 1.0;
    } else {
      h_inv_ = hs_inv_data[0];
    }
    stride = us.size(0);
    nrblks = order + 1;
    //  Number of row blocks
    switch (order) {
    case -1:
      nrblks = 2;
      break;
    case -2:
      nrblks = 3;
      break;
    case -4:
      nrblks = 4;
      break;
    }
    V.set_size(degree + 1, us.size(0) * nrblks);
    //  Compute rows corresponding to function values
    if (degree != 0) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      i = us.size(1) * us.size(0);
      u0 = 0;
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= i)) {
          u0 = 0;
          b = true;
        } else if (b) {
          b = false;
          u0 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          i1 = us.size(1) * us.size(0) - 1;
          if (u0 > MAX_int32_T - us.size(1)) {
            u0 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            u0 += us.size(1);
            if (u0 > i1) {
              u0 -= i1;
            }
          }
        }
        V[iPnt] = 1.0;
        V[iPnt + V.size(1)] = us[u0];
      }
    } else {
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        V[iPnt] = 1.0;
      }
    }
    u0 = order;
    if (order > 0) {
      u0 = 0;
    }
    i = (degree + u0) + 1;
    for (coder::SizeType ii{2}; ii <= i; ii++) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      u0 = us.size(1) * us.size(0);
      i1 = 0;
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= u0)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          coder::SizeType i2;
          i2 = us.size(1) * us.size(0) - 1;
          if (i1 > MAX_int32_T - us.size(1)) {
            i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i1 += us.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        V[iPnt + V.size(1) * (ii - 1)] =
            V[iPnt + V.size(1) * (ii - 2)] * us[i1];
      }
    }
    //  Add row blocks corresponding to kth derivatives
    r = us.size(0);
    if (order >= 0) {
      for (coder::SizeType k{0}; k < order; k++) {
        for (coder::SizeType j{0}; j <= k; j++) {
          for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
            V[(r + iPnt) + V.size(1) * j] = 0.0;
          }
        }
        for (coder::SizeType j{k + 1}; j <= degree; j++) {
          real_T s;
          s = h_inv_ * static_cast<real_T>(j);
          for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
            u0 = r + iPnt;
            V[u0 + V.size(1) * j] = V[(u0 - stride) + V.size(1) * (j - 1)] * s;
          }
        }
        r += stride;
      }
    } else {
      real_T s;
      //      computing negative orders
      if (-order > 2) {
        i = 2;
      } else {
        i = -order;
      }
      for (coder::SizeType k{0}; k < i; k++) {
        for (coder::SizeType j{0}; j <= k; j++) {
          for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
            V[(r + iPnt) + V.size(1) * j] = 0.0;
          }
        }
        for (coder::SizeType j{k + 1}; j <= degree; j++) {
          s = h_inv_ * static_cast<real_T>(j);
          for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
            u0 = r + iPnt;
            V[u0 + V.size(1) * j] = V[(u0 - stride) + V.size(1) * (j - 1)] * s;
          }
        }
        r += stride;
      }
      //      Calculate Biharmonic if order = -4
      if (order == -4) {
        for (coder::SizeType j{0}; j < 4; j++) {
          for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
            V[(r + iPnt) + V.size(1) * j] = 0.0;
          }
        }
        for (coder::SizeType j{2}; j <= degree; j++) {
          s = h_inv_ * static_cast<real_T>(j);
          for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
            u0 = r + iPnt;
            V[u0 + V.size(1) * j] =
                V[(u0 - stride) + V.size(1) * (j - 2)] * s * (s - 1.0);
          }
        }
      }
    }
  } break;
  case 2:
    gen_vander_2d(us, npoints, degree, order, hs_inv_data, hs_inv_size, V);
    break;
  default:
    gen_vander_3d(us, npoints, degree, order, hs_inv_data, hs_inv_size, V);
    break;
  }
}

//  gen_vander  Wrapper function for computing confluent Vandermonde matrix in
static void gen_vander(const ::coder::array<real_T, 2U> &us,
                       coder::SizeType npoints, coder::SizeType degree,
                       const real_T hs_inv_data[],
                       const coder::SizeType hs_inv_size[2],
                       ::coder::array<real_T, 2U> &V)
{
  switch (us.size(1)) {
  case 1: {
    real_T h_inv_;
    real_T s;
    coder::SizeType V_tmp;
    coder::SizeType b_npoints;
    coder::SizeType i;
    coder::SizeType i1;
    coder::SizeType r;
    coder::SizeType stride;
    boolean_T b;
    boolean_T b1;
    b_npoints = npoints - 1;
    m2cAssert(us.size(1) == 1, "");
    //  Handle input arguments
    if (npoints == 0) {
      b_npoints = us.size(0) - 1;
    } else {
      m2cAssert(npoints <= us.size(0), "Input us is too small.");
    }
    m2cAssert(degree >= 0, "Degree must be nonnegative");
    if (hs_inv_size[1] == 0) {
      h_inv_ = 1.0;
    } else {
      h_inv_ = hs_inv_data[0];
    }
    stride = us.size(0);
    //  Number of row blocks
    V.set_size(degree + 1, us.size(0) << 2);
    //  Compute rows corresponding to function values
    if (degree != 0) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      V_tmp = us.size(1) * us.size(0);
      i = 0;
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= V_tmp)) {
          i = 0;
          b = true;
        } else if (b) {
          b = false;
          i = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          i1 = us.size(1) * us.size(0) - 1;
          if (i > MAX_int32_T - us.size(1)) {
            i = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i += us.size(1);
            if (i > i1) {
              i -= i1;
            }
          }
        }
        V[iPnt] = 1.0;
        V[iPnt + V.size(1)] = us[i];
      }
    } else {
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        V[iPnt] = 1.0;
      }
    }
    V_tmp = degree - 3;
    for (coder::SizeType ii{2}; ii <= V_tmp; ii++) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      i = us.size(1) * us.size(0);
      i1 = 0;
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          coder::SizeType i2;
          i2 = us.size(1) * us.size(0) - 1;
          if (i1 > MAX_int32_T - us.size(1)) {
            i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i1 += us.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        V[iPnt + V.size(1) * (ii - 1)] =
            V[iPnt + V.size(1) * (ii - 2)] * us[i1];
      }
    }
    //  Add row blocks corresponding to kth derivatives
    r = us.size(0);
    //      computing negative orders
    for (coder::SizeType k{0}; k < 2; k++) {
      for (coder::SizeType j{0}; j <= k; j++) {
        for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
          V[(r + iPnt) + V.size(1) * j] = 0.0;
        }
      }
      for (coder::SizeType j{k + 1}; j <= degree; j++) {
        s = h_inv_ * static_cast<real_T>(j);
        for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
          V_tmp = r + iPnt;
          V[V_tmp + V.size(1) * j] =
              V[(V_tmp - stride) + V.size(1) * (j - 1)] * s;
        }
      }
      r += stride;
    }
    //      Calculate Biharmonic if order = -4
    for (coder::SizeType j{0}; j < 4; j++) {
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        V[(r + iPnt) + V.size(1) * j] = 0.0;
      }
    }
    for (coder::SizeType j{2}; j <= degree; j++) {
      s = h_inv_ * static_cast<real_T>(j);
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        V_tmp = r + iPnt;
        V[V_tmp + V.size(1) * j] =
            V[(V_tmp - stride) + V.size(1) * (j - 2)] * s * (s - 1.0);
      }
    }
  } break;
  case 2:
    gen_vander_2d(us, npoints, degree, hs_inv_data, hs_inv_size, V);
    break;
  default:
    gen_vander_3d(us, npoints, degree, hs_inv_data, hs_inv_size, V);
    break;
  }
}

//  gen_vander  Wrapper function for computing confluent Vandermonde matrix in
static void gen_vander(const ::coder::array<real_T, 2U> &us,
                       coder::SizeType npoints, coder::SizeType degree,
                       ::coder::array<real_T, 2U> &V)
{
  switch (us.size(1)) {
  case 1: {
    coder::SizeType b_npoints;
    coder::SizeType i;
    coder::SizeType i1;
    coder::SizeType i2;
    boolean_T b;
    boolean_T b1;
    b_npoints = npoints - 1;
    m2cAssert(us.size(1) == 1, "");
    //  Handle input arguments
    if (npoints == 0) {
      b_npoints = us.size(0) - 1;
    } else {
      m2cAssert(npoints <= us.size(0), "Input us is too small.");
    }
    m2cAssert(degree >= 0, "Degree must be nonnegative");
    //  Number of row blocks
    V.set_size(degree + 1, us.size(0));
    //  Compute rows corresponding to function values
    if (degree != 0) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      i = us.size(1) * us.size(0);
      i1 = 0;
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          i2 = us.size(1) * us.size(0) - 1;
          if (i1 > MAX_int32_T - us.size(1)) {
            i1 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i1 += us.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        V[iPnt] = 1.0;
        V[iPnt + V.size(1)] = us[i1];
      }
    } else {
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        V[iPnt] = 1.0;
      }
    }
    i = degree + 1;
    for (coder::SizeType ii{2}; ii <= i; ii++) {
      b = true;
      b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
      i1 = us.size(1) * us.size(0);
      i2 = 0;
      for (coder::SizeType iPnt{0}; iPnt <= b_npoints; iPnt++) {
        if (b1 || (iPnt >= i1)) {
          i2 = 0;
          b = true;
        } else if (b) {
          b = false;
          i2 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
        } else {
          coder::SizeType i3;
          i3 = us.size(1) * us.size(0) - 1;
          if (i2 > MAX_int32_T - us.size(1)) {
            i2 = iPnt % us.size(0) * us.size(1) + iPnt / us.size(0);
          } else {
            i2 += us.size(1);
            if (i2 > i3) {
              i2 -= i3;
            }
          }
        }
        V[iPnt + V.size(1) * (ii - 1)] =
            V[iPnt + V.size(1) * (ii - 2)] * us[i2];
      }
    }
    //  Add row blocks corresponding to kth derivatives
  } break;
  case 2:
    gen_vander_2d(us, npoints, degree, V);
    break;
  default:
    gen_vander_3d(us, npoints, degree, V);
    break;
  }
}

static inline void gen_vander_1d_dag(coder::SizeType degree,
                                     ::coder::array<uint8_T, 2U> &dag)
{
  dag.set_size(degree + 2, 1);
  for (coder::SizeType i{0}; i < degree; i++) {
    dag[i] = 1U;
  }
  dag[degree] = 0U;
  //  a leaf has no child
  dag[dag.size(0) - 1] = static_cast<uint8_T>(degree + 127);
}

//  gen_vander_2d  Generate generalized/confluent Vandermonde matrix in 2D.
static void gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                          coder::SizeType npoints, coder::SizeType degree,
                          coder::SizeType order,
                          const ::coder::array<real_T, 1U> &weights,
                          ::coder::array<real_T, 2U> &V)
{
  coder::SizeType b_degree;
  coder::SizeType c;
  coder::SizeType deg;
  coder::SizeType i;
  coder::SizeType nrblks;
  coder::SizeType stride;
  coder::SizeType u0;
  coder::SizeType x;
  coder::SizeType x_tmp_tmp;
  if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if ((order < -4) || (order == -3)) {
    m2cErrMsgIdAndTxt("wlslib:WrongOrder",
                      "Order %d must be 0, 1, 2, -1, -2, or -4", (int)order);
  }
  stride = us.size(0);
  nrblks = (order + 1) * (order + 2) / 2;
  //  Number of row blocks
  switch (order) {
  case -1:
    nrblks = 3;
    break;
  case -2:
    nrblks = 5;
    break;
  case -4:
    if (degree > 0) {
      nrblks = 8;
    } else {
      nrblks = 11;
    }
    break;
  }
  //  Allocate storage for V
  if (degree >= 0) {
    b_degree = (degree + 1) * (degree + 2) / 2;
  } else {
    b_degree = (1 - degree) * (1 - degree);
  }
  V.set_size(b_degree, us.size(0) * nrblks);
  //  compute 0th order generalized Vandermonde matrix
  if (weights.size(0) == 0) {
    if (degree != 0) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt] = 1.0;
        V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
        V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
      }
    } else {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt] = 1.0;
      }
    }
  } else if (degree != 0) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = weights[iPnt];
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt] * weights[iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1] * weights[iPnt];
    }
  } else {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = weights[iPnt];
    }
  }
  c = 3;
  u0 = order;
  if (order > 0) {
    u0 = 0;
  }
  x_tmp_tmp = -degree;
  x = -degree;
  if (-degree > 0) {
    x = 1;
  } else if (-degree < 0) {
    x = -1;
  }
  x *= u0;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (x < 0) {
    x = 0;
  }
  i = b_degree - x;
  for (deg = 2; deg <= i; deg++) {
    for (coder::SizeType j{0}; j < deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt + V.size(1) * c] =
          V[iPnt + V.size(1) * ((c - deg) - 1)] * us[us.size(1) * iPnt + 1];
    }
    c++;
  }
  //  Compute the bi-degree terms if degree<0
  i = 1 - u0;
  for (deg = x_tmp_tmp; deg >= i; deg--) {
    for (coder::SizeType k{0}; k < deg; k++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
      }
      c++;
    }
  }
  //  compute higher order confluent Vandermonde matrix blocks incrementally
  if (order != 0) {
    real_T scaleu;
    real_T scalev;
    coder::SizeType offset;
    //  This is an optimized version of update_vander_ordern for first-order CVM
    m2cAssert(degree != 0, "");
    //  Compute derivative with respect to u
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[stride + iPnt] = 0.0;
      V[(stride + iPnt) + V.size(1)] = V[iPnt];
      V[(stride + iPnt) + V.size(1) * 2] = 0.0;
    }
    c = 3;
    u0 = order + 1;
    if (u0 > 0) {
      u0 = 0;
    }
    x = -degree;
    if (-degree > 0) {
      x = 1;
    } else if (-degree < 0) {
      x = -1;
    }
    x *= u0;
    if (degree < 0) {
      b_degree = -degree;
    } else {
      b_degree = degree;
    }
    if (x < 0) {
      x = 0;
    }
    i = b_degree - x;
    for (deg = 2; deg <= i; deg++) {
      scaleu = deg;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * static_cast<real_T>(deg);
      }
      c++;
      for (coder::SizeType j{0}; j <= deg - 2; j++) {
        scaleu--;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * scaleu;
        }
        c++;
      }
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    //  Compute the bi-degree terms if degree<0
    for (coder::SizeType len{x_tmp_tmp}; len >= u0; len--) {
      scaleu = 1 - degree;
      for (coder::SizeType k{0}; k < len; k++) {
        scaleu--;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - len)] * scaleu;
        }
        c++;
      }
    }
    //  Compute derivative with respect to v
    offset = us.size(0) + us.size(0);
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      x = offset + iPnt;
      V[x] = 0.0;
      V[x + V.size(1)] = 0.0;
      V[x + V.size(1) * 2] = V[iPnt];
    }
    c = 3;
    x = -degree;
    if (-degree > 0) {
      x = 1;
    } else if (-degree < 0) {
      x = -1;
    }
    x *= u0;
    if (degree < 0) {
      b_degree = -degree;
    } else {
      b_degree = degree;
    }
    if (x < 0) {
      x = 0;
    }
    i = b_degree - x;
    for (deg = 2; deg <= i; deg++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
      for (coder::SizeType j{0}; j < deg; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * ((c - deg) - 1)] *
              (static_cast<real_T>(j) + 1.0);
        }
        c++;
      }
    }
    //  Compute the bi-degree terms if degree<0
    deg = -degree;
    for (coder::SizeType len{x_tmp_tmp}; len >= u0; len--) {
      deg++;
      scalev = (deg + degree) - 1;
      for (coder::SizeType k{0}; k < len; k++) {
        scalev++;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * ((c - len) - 1)] * scalev;
        }
        c++;
      }
    }
    //      compute regular orders if order > 0
    if (order > 0) {
      for (coder::SizeType dd{2}; dd <= order; dd++) {
        coder::SizeType offset_prev;
        //  Compute order-N CVM row blocks from order-(N-1) CVM.
        m2cAssert(degree != 0, "");
        b_degree = dd * (dd + 1) / 2;
        offset = b_degree * stride;
        offset_prev = (dd - 1) * dd / 2 * stride;
        //  Compute derivative with respect to u
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (coder::SizeType b_i{0}; b_i < dd; b_i++) {
          //  Initialize block to zero
          u0 = offset + 1;
          x = offset + npoints;
          for (coder::SizeType col{0}; col < b_degree; col++) {
            for (coder::SizeType row{u0}; row <= x; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = b_degree;
          for (deg = dd; deg <= i; deg++) {
            scaleu = deg + 1;
            u0 = deg - 1;
            for (coder::SizeType j{0}; j <= u0; j++) {
              scaleu--;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
              }
              c++;
            }
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          //  Compute the bi-degree terms if degree<0
          for (coder::SizeType len{x_tmp_tmp}; len >= 0; len--) {
            scaleu = 1 - degree;
            for (coder::SizeType k{0}; k < len; k++) {
              scaleu--;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
              }
              c++;
            }
          }
          offset += stride;
          offset_prev += stride;
        }
        //  Compute derivative with respect to v
        i = offset + 1;
        u0 = offset + npoints;
        for (coder::SizeType col{0}; col < b_degree; col++) {
          for (coder::SizeType row{i}; row <= u0; row++) {
            V[(row + V.size(1) * col) - 1] = 0.0;
          }
        }
        c = b_degree;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = dd; deg <= i; deg++) {
          u0 = dd - 1;
          for (coder::SizeType j{0}; j <= u0; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (coder::SizeType j{dd}; j <= deg; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[((offset_prev - stride) + iPnt) +
                    V.size(1) * ((c - deg) - 1)] *
                  static_cast<real_T>(j);
            }
            c++;
          }
        }
        //  Compute the bi-degree terms if degree<0
        deg = -degree;
        for (coder::SizeType len{x_tmp_tmp}; len >= 0; len--) {
          deg++;
          scalev = (deg + degree) - 1;
          for (coder::SizeType k{0}; k < len; k++) {
            scalev++;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[((offset_prev - stride) + iPnt) +
                    V.size(1) * ((c - len) - 1)] *
                  scalev;
            }
            c++;
          }
        }
      }
    } else if (order < -1) {
      //          compute efficient laplacian and bi-laplacian
      switch (order) {
      case -2: {
        coder::SizeType offset_prev;
        //  Compute order-N CVM row blocks from order-(N-1) CVM.
        m2cAssert(degree != 0, "");
        offset = 3 * us.size(0);
        offset_prev = us.size(0);
        //  Compute derivative with respect to u
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        //  Initialize block to zero
        u0 = offset + 1;
        x = offset + npoints;
        for (coder::SizeType col{0}; col < 3; col++) {
          for (coder::SizeType row{u0}; row <= x; row++) {
            V[(row + V.size(1) * col) - 1] = 0.0;
          }
        }
        c = 3;
        for (deg = 2; deg <= i; deg++) {
          scaleu = deg + 1;
          u0 = deg - 1;
          for (coder::SizeType j{0}; j <= u0; j++) {
            scaleu--;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
            }
            c++;
          }
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        //  Compute the bi-degree terms if degree<0
        for (coder::SizeType len{x_tmp_tmp}; len >= -2; len--) {
          scaleu = 1 - degree;
          for (coder::SizeType k{0}; k < len; k++) {
            scaleu--;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
            }
            c++;
          }
        }
        offset += us.size(0);
        //  Compute derivative with respect to v
        offset_prev = (us.size(0) + us.size(0)) + us.size(0);
        i = offset + 1;
        u0 = offset + npoints;
        for (coder::SizeType col{0}; col < 3; col++) {
          for (coder::SizeType row{i}; row <= u0; row++) {
            V[(row + V.size(1) * col) - 1] = 0.0;
          }
        }
        c = 3;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (coder::SizeType j{0}; j < 2; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (coder::SizeType j{2}; j <= deg; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[((offset_prev - stride) + iPnt) +
                    V.size(1) * ((c - deg) - 1)] *
                  static_cast<real_T>(j);
            }
            c++;
          }
        }
        //  Compute the bi-degree terms if degree<0
        deg = -degree;
        for (coder::SizeType len{x_tmp_tmp}; len >= -2; len--) {
          deg++;
          scalev = (deg + degree) - 1;
          for (coder::SizeType k{0}; k < len; k++) {
            scalev++;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[((offset_prev - stride) + iPnt) +
                    V.size(1) * ((c - len) - 1)] *
                  scalev;
            }
            c++;
          }
        }
      } break;
      case -4: {
        if (degree > 0) {
          coder::SizeType offset_prev;
          //  Compute order-N CVM row blocks from order-(N-1) CVM.
          m2cAssert(true, "");
          offset = 3 * us.size(0);
          //  Compute derivative with respect to u
          i = offset + 1;
          u0 = offset + npoints;
          for (coder::SizeType col{0}; col < 3; col++) {
            for (coder::SizeType row{i}; row <= u0; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 3;
          for (deg = 2; deg <= degree; deg++) {
            scaleu = deg + 1;
            i = deg - 1;
            for (coder::SizeType j{0}; j <= i; j++) {
              scaleu--;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(us.size(0) + iPnt) + V.size(1) * (c - deg)] * scaleu;
              }
              c++;
            }
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          //  Compute the bi-degree terms if degree<0
          offset += us.size(0);
          //  Compute derivative with respect to v
          offset_prev = (us.size(0) + us.size(0)) + us.size(0);
          i = offset + 1;
          u0 = offset + npoints;
          for (coder::SizeType col{0}; col < 3; col++) {
            for (coder::SizeType row{i}; row <= u0; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 3;
          for (deg = 2; deg <= degree; deg++) {
            for (coder::SizeType j{0}; j < 2; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            for (coder::SizeType j{2}; j <= deg; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - deg) - 1)] *
                    static_cast<real_T>(j);
              }
              c++;
            }
          }
          //  Compute the bi-degree terms if degree<0
          offset = 5 * us.size(0);
          offset_prev = 3 * us.size(0);
          m2cAssert(degree >= 4, "");
          //  compute du^4 and du^2*dv^2
          for (coder::SizeType terms{0}; terms < 2; terms++) {
            i = offset + 1;
            u0 = offset + npoints;
            for (coder::SizeType col{0}; col < 10; col++) {
              for (coder::SizeType row{i}; row <= u0; row++) {
                V[(row + V.size(1) * col) - 1] = 0.0;
              }
            }
            c = 10;
            for (deg = 4; deg <= degree; deg++) {
              scaleu = deg + 1;
              i = deg - 1;
              for (coder::SizeType j{0}; j <= i; j++) {
                scaleu--;
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(offset + iPnt) + V.size(1) * c] =
                      V[(offset_prev + iPnt) +
                        V.size(1) * ((c - (deg << 1)) + 1)] *
                      scaleu * (scaleu - 1.0);
                }
                c++;
              }
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            offset += stride;
            offset_prev += stride;
          }
          //  compute dv^4
          i = offset + 1;
          u0 = offset + npoints;
          for (coder::SizeType col{0}; col < 10; col++) {
            for (coder::SizeType row{i}; row <= u0; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 10;
          for (deg = 4; deg <= degree; deg++) {
            for (coder::SizeType j{0}; j < 4; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            for (coder::SizeType j{4}; j <= deg; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - (deg << 1)) - 1)] *
                    static_cast<real_T>(j) * (static_cast<real_T>(j) - 1.0);
              }
              c++;
            }
          }
        } else {
          coder::SizeType offset_prev;
          //  Compute order-N CVM row blocks from order-(N-1) CVM.
          m2cAssert(degree != 0, "");
          offset = 3 * us.size(0);
          offset_prev = us.size(0);
          //  Compute derivative with respect to u
          if (degree < 0) {
            i = -degree;
          } else {
            i = 0;
          }
          //  Initialize block to zero
          u0 = offset + 1;
          x = offset + npoints;
          for (coder::SizeType col{0}; col < 3; col++) {
            for (coder::SizeType row{u0}; row <= x; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 3;
          for (deg = 2; deg <= i; deg++) {
            scaleu = deg + 1;
            u0 = deg - 1;
            for (coder::SizeType j{0}; j <= u0; j++) {
              scaleu--;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
              }
              c++;
            }
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          //  Compute the bi-degree terms if degree<0
          for (coder::SizeType len{x_tmp_tmp}; len >= -2; len--) {
            scaleu = 1 - degree;
            for (coder::SizeType k{0}; k < len; k++) {
              scaleu--;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
              }
              c++;
            }
          }
          offset += us.size(0);
          //  Compute derivative with respect to v
          offset_prev = (us.size(0) + us.size(0)) + us.size(0);
          i = offset + 1;
          u0 = offset + npoints;
          for (coder::SizeType col{0}; col < 3; col++) {
            for (coder::SizeType row{i}; row <= u0; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 3;
          if (degree < 0) {
            i = -degree;
          } else {
            i = 0;
          }
          for (deg = 2; deg <= i; deg++) {
            for (coder::SizeType j{0}; j < 2; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            for (coder::SizeType j{2}; j <= deg; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - deg) - 1)] *
                    static_cast<real_T>(j);
              }
              c++;
            }
          }
          //  Compute the bi-degree terms if degree<0
          deg = -degree;
          for (coder::SizeType len{x_tmp_tmp}; len >= -2; len--) {
            deg++;
            scalev = (deg + degree) - 1;
            for (coder::SizeType k{0}; k < len; k++) {
              scalev++;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - len) - 1)] *
                    scalev;
              }
              c++;
            }
          }
          //  Compute order-N CVM row blocks from order-(N-1) CVM.
          m2cAssert(degree != 0, "");
          offset = 5 * us.size(0);
          offset_prev = 3 * us.size(0);
          //  Compute derivative with respect to u
          if (degree < 0) {
            i = -degree;
          } else {
            i = 0;
          }
          for (coder::SizeType b_i{0}; b_i < 2; b_i++) {
            //  Initialize block to zero
            u0 = offset + 1;
            x = offset + npoints;
            for (coder::SizeType col{0}; col < 6; col++) {
              for (coder::SizeType row{u0}; row <= x; row++) {
                V[(row + V.size(1) * col) - 1] = 0.0;
              }
            }
            c = 6;
            for (deg = 3; deg <= i; deg++) {
              scaleu = deg + 1;
              u0 = deg - 1;
              for (coder::SizeType j{0}; j <= u0; j++) {
                scaleu--;
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(offset + iPnt) + V.size(1) * c] =
                      V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
                }
                c++;
              }
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            //  Compute the bi-degree terms if degree<0
            for (coder::SizeType len{x_tmp_tmp}; len >= -3; len--) {
              scaleu = 1 - degree;
              for (coder::SizeType k{0}; k < len; k++) {
                scaleu--;
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(offset + iPnt) + V.size(1) * c] =
                      V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
                }
                c++;
              }
            }
            offset += stride;
            offset_prev += stride;
          }
          //  Compute derivative with respect to v
          i = offset + 1;
          u0 = offset + npoints;
          for (coder::SizeType col{0}; col < 6; col++) {
            for (coder::SizeType row{i}; row <= u0; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 6;
          if (degree < 0) {
            i = -degree;
          } else {
            i = 0;
          }
          for (deg = 3; deg <= i; deg++) {
            for (coder::SizeType j{0}; j < 3; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            for (coder::SizeType j{3}; j <= deg; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - deg) - 1)] *
                    static_cast<real_T>(j);
              }
              c++;
            }
          }
          //  Compute the bi-degree terms if degree<0
          deg = -degree;
          for (coder::SizeType len{x_tmp_tmp}; len >= -3; len--) {
            deg++;
            scalev = (deg + degree) - 1;
            for (coder::SizeType k{0}; k < len; k++) {
              scalev++;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - len) - 1)] *
                    scalev;
              }
              c++;
            }
          }
          //  Compute order-N CVM row blocks from order-(N-1) CVM.
          m2cAssert(degree != 0, "");
          offset = us.size(0) << 3;
          offset_prev = 5 * us.size(0);
          //  Compute derivative with respect to u
          if (degree < 0) {
            i = -degree;
          } else {
            i = 0;
          }
          for (coder::SizeType b_i{0}; b_i < 2; b_i++) {
            //  Initialize block to zero
            u0 = offset + 1;
            x = offset + npoints;
            for (coder::SizeType col{0}; col < 10; col++) {
              for (coder::SizeType row{u0}; row <= x; row++) {
                V[(row + V.size(1) * col) - 1] = 0.0;
              }
            }
            c = 10;
            for (deg = 4; deg <= i; deg++) {
              scaleu = deg + 1;
              u0 = deg - 1;
              for (coder::SizeType j{0}; j <= u0; j++) {
                scaleu--;
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(offset + iPnt) + V.size(1) * c] =
                      V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
                }
                c++;
              }
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            //  Compute the bi-degree terms if degree<0
            for (coder::SizeType len{x_tmp_tmp}; len >= -4; len--) {
              scaleu = 1 - degree;
              for (coder::SizeType k{0}; k < len; k++) {
                scaleu--;
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(offset + iPnt) + V.size(1) * c] =
                      V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
                }
                c++;
              }
            }
            offset += stride;
            offset_prev += stride;
          }
          //  Compute derivative with respect to v
          offset_prev += us.size(0);
          i = offset + 1;
          u0 = offset + npoints;
          for (coder::SizeType col{0}; col < 10; col++) {
            for (coder::SizeType row{i}; row <= u0; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 10;
          if (degree < 0) {
            i = -degree;
          } else {
            i = 0;
          }
          for (deg = 4; deg <= i; deg++) {
            for (coder::SizeType j{0}; j < 4; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            for (coder::SizeType j{4}; j <= deg; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - deg) - 1)] *
                    static_cast<real_T>(j);
              }
              c++;
            }
          }
          //  Compute the bi-degree terms if degree<0
          deg = -degree;
          for (coder::SizeType len{x_tmp_tmp}; len >= -4; len--) {
            deg++;
            scalev = (deg + degree) - 1;
            for (coder::SizeType k{0}; k < len; k++) {
              scalev++;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - len) - 1)] *
                    scalev;
              }
              c++;
            }
          }
        }
      } break;
      default:
        m2cAssert(false, "Order must be 0, 1, 2, -1, -2, or -4");
        break;
      }
    }
  }
}

//  gen_vander_2d  Generate generalized/confluent Vandermonde matrix in 2D.
static void gen_vander_2d(const real_T us_data[], coder::SizeType degree,
                          ::coder::array<real_T, 2U> &V)
{
  coder::SizeType c;
  coder::SizeType i;
  V.set_size((degree + 1) * (degree + 2) / 2, 1);
  //  compute 0th order generalized Vandermonde matrix
  V[V.size(1) * 2] = us_data[1];
  V[V.size(1)] = us_data[0];
  V[0] = 1.0;
  c = 3;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (coder::SizeType deg{2}; deg <= i; deg++) {
    for (coder::SizeType j{0}; j < deg; j++) {
      V[V.size(1) * c] = V[V.size(1) * (c - deg)] * us_data[0];
      c++;
    }
    V[V.size(1) * c] = V[V.size(1) * ((c - deg) - 1)] * us_data[1];
    c++;
  }
  //  Compute the bi-degree terms if degree<0
}

//  gen_vander_2d  Generate generalized/confluent Vandermonde matrix in 2D.
static void gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                          coder::SizeType npoints, coder::SizeType degree,
                          ::coder::array<real_T, 2U> &V)
{
  coder::SizeType b_degree;
  coder::SizeType c;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  //  Number of row blocks
  if (degree >= 0) {
    b_degree = (degree + 1) * (degree + 2) / 2;
  } else {
    b_degree = (1 - degree) * (1 - degree);
  }
  V.set_size(b_degree, us.size(0));
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
    }
  } else {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 3;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  for (coder::SizeType deg{2}; deg <= b_degree; deg++) {
    for (coder::SizeType j{0}; j < deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt + V.size(1) * c] =
          V[iPnt + V.size(1) * ((c - deg) - 1)] * us[us.size(1) * iPnt + 1];
    }
    c++;
  }
  //  Compute the bi-degree terms if degree<0
  b_degree = -degree;
  for (coder::SizeType deg{b_degree}; deg >= 1; deg--) {
    for (coder::SizeType k{0}; k < deg; k++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
      }
      c++;
    }
  }
  //  compute higher order confluent Vandermonde matrix blocks incrementally
}

//  gen_vander_2d  Generate generalized/confluent Vandermonde matrix in 2D.
static void gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                          coder::SizeType npoints, coder::SizeType degree,
                          coder::SizeType order, const real_T hs_inv_data[],
                          const coder::SizeType hs_inv_size[2],
                          ::coder::array<real_T, 2U> &V)
{
  real_T hs_inv__idx_0;
  real_T hs_inv__idx_1;
  coder::SizeType b_degree;
  coder::SizeType c;
  coder::SizeType deg;
  coder::SizeType i;
  coder::SizeType nrblks;
  coder::SizeType stride;
  coder::SizeType u0;
  coder::SizeType x;
  coder::SizeType x_tmp_tmp;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if ((order < -4) || (order == -3)) {
    m2cErrMsgIdAndTxt("wlslib:WrongOrder",
                      "Order %d must be 0, 1, 2, -1, -2, or -4", (int)order);
  }
  if (hs_inv_size[1] == 0) {
    hs_inv__idx_0 = 1.0;
    hs_inv__idx_1 = 1.0;
  } else {
    hs_inv__idx_0 = hs_inv_data[0];
    hs_inv__idx_1 = hs_inv_data[1];
  }
  stride = us.size(0);
  nrblks = (order + 1) * (order + 2) / 2;
  //  Number of row blocks
  switch (order) {
  case -1:
    nrblks = 3;
    break;
  case -2:
    nrblks = 5;
    break;
  case -4:
    if (degree > 0) {
      nrblks = 8;
    } else {
      nrblks = 11;
    }
    break;
  }
  //  Allocate storage for V
  if (degree >= 0) {
    b_degree = (degree + 1) * (degree + 2) / 2;
  } else {
    b_degree = (1 - degree) * (1 - degree);
  }
  V.set_size(b_degree, us.size(0) * nrblks);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
    }
  } else {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 3;
  u0 = order;
  if (order > 0) {
    u0 = 0;
  }
  x_tmp_tmp = -degree;
  x = -degree;
  if (-degree > 0) {
    x = 1;
  } else if (-degree < 0) {
    x = -1;
  }
  x *= u0;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (x < 0) {
    x = 0;
  }
  i = b_degree - x;
  for (deg = 2; deg <= i; deg++) {
    for (coder::SizeType j{0}; j < deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt + V.size(1) * c] =
          V[iPnt + V.size(1) * ((c - deg) - 1)] * us[us.size(1) * iPnt + 1];
    }
    c++;
  }
  //  Compute the bi-degree terms if degree<0
  i = 1 - u0;
  for (deg = x_tmp_tmp; deg >= i; deg--) {
    for (coder::SizeType k{0}; k < deg; k++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
      }
      c++;
    }
  }
  //  compute higher order confluent Vandermonde matrix blocks incrementally
  if (order != 0) {
    real_T scaleu;
    real_T scalev;
    coder::SizeType offset;
    //  This is an optimized version of update_vander_ordern for first-order CVM
    m2cAssert(degree != 0, "");
    //  Compute derivative with respect to u
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      x = stride + iPnt;
      V[x] = 0.0;
      V[x + V.size(1)] = V[iPnt] * hs_inv__idx_0;
      V[x + V.size(1) * 2] = 0.0;
    }
    c = 3;
    u0 = order + 1;
    if (u0 > 0) {
      u0 = 0;
    }
    x = -degree;
    if (-degree > 0) {
      x = 1;
    } else if (-degree < 0) {
      x = -1;
    }
    x *= u0;
    if (degree < 0) {
      b_degree = -degree;
    } else {
      b_degree = degree;
    }
    if (x < 0) {
      x = 0;
    }
    i = b_degree - x;
    for (deg = 2; deg <= i; deg++) {
      scaleu = static_cast<real_T>(deg) * hs_inv__idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * scaleu;
      }
      c++;
      for (coder::SizeType j{0}; j <= deg - 2; j++) {
        scaleu -= hs_inv__idx_0;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - deg)] * scaleu;
        }
        c++;
      }
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    //  Compute the bi-degree terms if degree<0
    for (coder::SizeType len{x_tmp_tmp}; len >= u0; len--) {
      scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
      for (coder::SizeType k{0}; k < len; k++) {
        scaleu -= hs_inv__idx_0;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - len)] * scaleu;
        }
        c++;
      }
    }
    //  Compute derivative with respect to v
    offset = us.size(0) + us.size(0);
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      x = offset + iPnt;
      V[x] = 0.0;
      V[x + V.size(1)] = 0.0;
      V[x + V.size(1) * 2] = V[iPnt] * hs_inv__idx_1;
    }
    c = 3;
    x = -degree;
    if (-degree > 0) {
      x = 1;
    } else if (-degree < 0) {
      x = -1;
    }
    x *= u0;
    if (degree < 0) {
      b_degree = -degree;
    } else {
      b_degree = degree;
    }
    if (x < 0) {
      x = 0;
    }
    i = b_degree - x;
    for (deg = 2; deg <= i; deg++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
      for (coder::SizeType j{0}; j < deg; j++) {
        scalev = (static_cast<real_T>(j) + 1.0) * hs_inv__idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * ((c - deg) - 1)] * scalev;
        }
        c++;
      }
    }
    //  Compute the bi-degree terms if degree<0
    deg = -degree;
    for (coder::SizeType len{x_tmp_tmp}; len >= u0; len--) {
      deg++;
      scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
      for (coder::SizeType k{0}; k < len; k++) {
        scalev += hs_inv__idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * ((c - len) - 1)] * scalev;
        }
        c++;
      }
    }
    //      compute regular orders if order > 0
    if (order > 0) {
      for (coder::SizeType dd{2}; dd <= order; dd++) {
        coder::SizeType offset_prev;
        //  Compute order-N CVM row blocks from order-(N-1) CVM.
        m2cAssert(degree != 0, "");
        b_degree = dd * (dd + 1) / 2;
        offset = b_degree * stride;
        offset_prev = (dd - 1) * dd / 2 * stride;
        //  Compute derivative with respect to u
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (coder::SizeType b_i{0}; b_i < dd; b_i++) {
          //  Initialize block to zero
          u0 = offset + 1;
          x = offset + npoints;
          for (coder::SizeType col{0}; col < b_degree; col++) {
            for (coder::SizeType row{u0}; row <= x; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = b_degree;
          for (deg = dd; deg <= i; deg++) {
            scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
            u0 = deg - 1;
            for (coder::SizeType j{0}; j <= u0; j++) {
              scaleu -= hs_inv__idx_0;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
              }
              c++;
            }
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          //  Compute the bi-degree terms if degree<0
          for (coder::SizeType len{x_tmp_tmp}; len >= 0; len--) {
            scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
            for (coder::SizeType k{0}; k < len; k++) {
              scaleu -= hs_inv__idx_0;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
              }
              c++;
            }
          }
          offset += stride;
          offset_prev += stride;
        }
        //  Compute derivative with respect to v
        i = offset + 1;
        u0 = offset + npoints;
        for (coder::SizeType col{0}; col < b_degree; col++) {
          for (coder::SizeType row{i}; row <= u0; row++) {
            V[(row + V.size(1) * col) - 1] = 0.0;
          }
        }
        c = b_degree;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = dd; deg <= i; deg++) {
          u0 = dd - 1;
          for (coder::SizeType j{0}; j <= u0; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (coder::SizeType j{dd}; j <= deg; j++) {
            scalev = static_cast<real_T>(j) * hs_inv__idx_1;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[((offset_prev - stride) + iPnt) +
                    V.size(1) * ((c - deg) - 1)] *
                  scalev;
            }
            c++;
          }
        }
        //  Compute the bi-degree terms if degree<0
        deg = -degree;
        for (coder::SizeType len{x_tmp_tmp}; len >= 0; len--) {
          deg++;
          scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
          for (coder::SizeType k{0}; k < len; k++) {
            scalev += hs_inv__idx_1;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[((offset_prev - stride) + iPnt) +
                    V.size(1) * ((c - len) - 1)] *
                  scalev;
            }
            c++;
          }
        }
      }
    } else if (order < -1) {
      //          compute efficient laplacian and bi-laplacian
      switch (order) {
      case -2: {
        coder::SizeType offset_prev;
        //  Compute order-N CVM row blocks from order-(N-1) CVM.
        m2cAssert(degree != 0, "");
        offset = 3 * us.size(0);
        offset_prev = us.size(0);
        //  Compute derivative with respect to u
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        //  Initialize block to zero
        u0 = offset + 1;
        x = offset + npoints;
        for (coder::SizeType col{0}; col < 3; col++) {
          for (coder::SizeType row{u0}; row <= x; row++) {
            V[(row + V.size(1) * col) - 1] = 0.0;
          }
        }
        c = 3;
        for (deg = 2; deg <= i; deg++) {
          scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
          u0 = deg - 1;
          for (coder::SizeType j{0}; j <= u0; j++) {
            scaleu -= hs_inv__idx_0;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
            }
            c++;
          }
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        //  Compute the bi-degree terms if degree<0
        for (coder::SizeType len{x_tmp_tmp}; len >= -2; len--) {
          scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
          for (coder::SizeType k{0}; k < len; k++) {
            scaleu -= hs_inv__idx_0;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
            }
            c++;
          }
        }
        offset += us.size(0);
        //  Compute derivative with respect to v
        offset_prev = (us.size(0) + us.size(0)) + us.size(0);
        i = offset + 1;
        u0 = offset + npoints;
        for (coder::SizeType col{0}; col < 3; col++) {
          for (coder::SizeType row{i}; row <= u0; row++) {
            V[(row + V.size(1) * col) - 1] = 0.0;
          }
        }
        c = 3;
        if (degree < 0) {
          i = -degree;
        } else {
          i = degree;
        }
        for (deg = 2; deg <= i; deg++) {
          for (coder::SizeType j{0}; j < 2; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (coder::SizeType j{2}; j <= deg; j++) {
            scalev = static_cast<real_T>(j) * hs_inv__idx_1;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[((offset_prev - stride) + iPnt) +
                    V.size(1) * ((c - deg) - 1)] *
                  scalev;
            }
            c++;
          }
        }
        //  Compute the bi-degree terms if degree<0
        deg = -degree;
        for (coder::SizeType len{x_tmp_tmp}; len >= -2; len--) {
          deg++;
          scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
          for (coder::SizeType k{0}; k < len; k++) {
            scalev += hs_inv__idx_1;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[((offset_prev - stride) + iPnt) +
                    V.size(1) * ((c - len) - 1)] *
                  scalev;
            }
            c++;
          }
        }
      } break;
      case -4: {
        if (degree > 0) {
          coder::SizeType offset_prev;
          //  Compute order-N CVM row blocks from order-(N-1) CVM.
          m2cAssert(true, "");
          offset = 3 * us.size(0);
          //  Compute derivative with respect to u
          i = offset + 1;
          u0 = offset + npoints;
          for (coder::SizeType col{0}; col < 3; col++) {
            for (coder::SizeType row{i}; row <= u0; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 3;
          for (deg = 2; deg <= degree; deg++) {
            scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
            i = deg - 1;
            for (coder::SizeType j{0}; j <= i; j++) {
              scaleu -= hs_inv__idx_0;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(us.size(0) + iPnt) + V.size(1) * (c - deg)] * scaleu;
              }
              c++;
            }
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          //  Compute the bi-degree terms if degree<0
          offset += us.size(0);
          //  Compute derivative with respect to v
          offset_prev = (us.size(0) + us.size(0)) + us.size(0);
          i = offset + 1;
          u0 = offset + npoints;
          for (coder::SizeType col{0}; col < 3; col++) {
            for (coder::SizeType row{i}; row <= u0; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 3;
          for (deg = 2; deg <= degree; deg++) {
            for (coder::SizeType j{0}; j < 2; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            for (coder::SizeType j{2}; j <= deg; j++) {
              scalev = static_cast<real_T>(j) * hs_inv__idx_1;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - deg) - 1)] *
                    scalev;
              }
              c++;
            }
          }
          //  Compute the bi-degree terms if degree<0
          offset = 5 * us.size(0);
          offset_prev = 3 * us.size(0);
          m2cAssert(degree >= 4, "");
          //  compute du^4 and du^2*dv^2
          for (coder::SizeType terms{0}; terms < 2; terms++) {
            i = offset + 1;
            u0 = offset + npoints;
            for (coder::SizeType col{0}; col < 10; col++) {
              for (coder::SizeType row{i}; row <= u0; row++) {
                V[(row + V.size(1) * col) - 1] = 0.0;
              }
            }
            c = 10;
            for (deg = 4; deg <= degree; deg++) {
              scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
              i = deg - 1;
              for (coder::SizeType j{0}; j <= i; j++) {
                scaleu -= hs_inv__idx_0;
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(offset + iPnt) + V.size(1) * c] =
                      V[(offset_prev + iPnt) +
                        V.size(1) * ((c - (deg << 1)) + 1)] *
                      scaleu * (scaleu - hs_inv__idx_0);
                }
                c++;
              }
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            offset += stride;
            offset_prev += stride;
          }
          //  compute dv^4
          i = offset + 1;
          u0 = offset + npoints;
          for (coder::SizeType col{0}; col < 10; col++) {
            for (coder::SizeType row{i}; row <= u0; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 10;
          for (deg = 4; deg <= degree; deg++) {
            for (coder::SizeType j{0}; j < 4; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            for (coder::SizeType j{4}; j <= deg; j++) {
              scalev = static_cast<real_T>(j) * (hs_inv__idx_1 * hs_inv__idx_1);
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - (deg << 1)) - 1)] *
                    scalev * (static_cast<real_T>(j) - 1.0);
              }
              c++;
            }
          }
        } else {
          coder::SizeType offset_prev;
          //  Compute order-N CVM row blocks from order-(N-1) CVM.
          m2cAssert(degree != 0, "");
          offset = 3 * us.size(0);
          offset_prev = us.size(0);
          //  Compute derivative with respect to u
          if (degree < 0) {
            i = -degree;
          } else {
            i = 0;
          }
          //  Initialize block to zero
          u0 = offset + 1;
          x = offset + npoints;
          for (coder::SizeType col{0}; col < 3; col++) {
            for (coder::SizeType row{u0}; row <= x; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 3;
          for (deg = 2; deg <= i; deg++) {
            scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
            u0 = deg - 1;
            for (coder::SizeType j{0}; j <= u0; j++) {
              scaleu -= hs_inv__idx_0;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
              }
              c++;
            }
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          //  Compute the bi-degree terms if degree<0
          for (coder::SizeType len{x_tmp_tmp}; len >= -2; len--) {
            scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
            for (coder::SizeType k{0}; k < len; k++) {
              scaleu -= hs_inv__idx_0;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
              }
              c++;
            }
          }
          offset += us.size(0);
          //  Compute derivative with respect to v
          offset_prev = (us.size(0) + us.size(0)) + us.size(0);
          i = offset + 1;
          u0 = offset + npoints;
          for (coder::SizeType col{0}; col < 3; col++) {
            for (coder::SizeType row{i}; row <= u0; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 3;
          if (degree < 0) {
            i = -degree;
          } else {
            i = 0;
          }
          for (deg = 2; deg <= i; deg++) {
            for (coder::SizeType j{0}; j < 2; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            for (coder::SizeType j{2}; j <= deg; j++) {
              scalev = static_cast<real_T>(j) * hs_inv__idx_1;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - deg) - 1)] *
                    scalev;
              }
              c++;
            }
          }
          //  Compute the bi-degree terms if degree<0
          deg = -degree;
          for (coder::SizeType len{x_tmp_tmp}; len >= -2; len--) {
            deg++;
            scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
            for (coder::SizeType k{0}; k < len; k++) {
              scalev += hs_inv__idx_1;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - len) - 1)] *
                    scalev;
              }
              c++;
            }
          }
          //  Compute order-N CVM row blocks from order-(N-1) CVM.
          m2cAssert(degree != 0, "");
          offset = 5 * us.size(0);
          offset_prev = 3 * us.size(0);
          //  Compute derivative with respect to u
          if (degree < 0) {
            i = -degree;
          } else {
            i = 0;
          }
          for (coder::SizeType b_i{0}; b_i < 2; b_i++) {
            //  Initialize block to zero
            u0 = offset + 1;
            x = offset + npoints;
            for (coder::SizeType col{0}; col < 6; col++) {
              for (coder::SizeType row{u0}; row <= x; row++) {
                V[(row + V.size(1) * col) - 1] = 0.0;
              }
            }
            c = 6;
            for (deg = 3; deg <= i; deg++) {
              scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
              u0 = deg - 1;
              for (coder::SizeType j{0}; j <= u0; j++) {
                scaleu -= hs_inv__idx_0;
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(offset + iPnt) + V.size(1) * c] =
                      V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
                }
                c++;
              }
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            //  Compute the bi-degree terms if degree<0
            for (coder::SizeType len{x_tmp_tmp}; len >= -3; len--) {
              scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
              for (coder::SizeType k{0}; k < len; k++) {
                scaleu -= hs_inv__idx_0;
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(offset + iPnt) + V.size(1) * c] =
                      V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
                }
                c++;
              }
            }
            offset += stride;
            offset_prev += stride;
          }
          //  Compute derivative with respect to v
          i = offset + 1;
          u0 = offset + npoints;
          for (coder::SizeType col{0}; col < 6; col++) {
            for (coder::SizeType row{i}; row <= u0; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 6;
          if (degree < 0) {
            i = -degree;
          } else {
            i = 0;
          }
          for (deg = 3; deg <= i; deg++) {
            for (coder::SizeType j{0}; j < 3; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            for (coder::SizeType j{3}; j <= deg; j++) {
              scalev = static_cast<real_T>(j) * hs_inv__idx_1;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - deg) - 1)] *
                    scalev;
              }
              c++;
            }
          }
          //  Compute the bi-degree terms if degree<0
          deg = -degree;
          for (coder::SizeType len{x_tmp_tmp}; len >= -3; len--) {
            deg++;
            scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
            for (coder::SizeType k{0}; k < len; k++) {
              scalev += hs_inv__idx_1;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - len) - 1)] *
                    scalev;
              }
              c++;
            }
          }
          //  Compute order-N CVM row blocks from order-(N-1) CVM.
          m2cAssert(degree != 0, "");
          offset = us.size(0) << 3;
          offset_prev = 5 * us.size(0);
          //  Compute derivative with respect to u
          if (degree < 0) {
            i = -degree;
          } else {
            i = 0;
          }
          for (coder::SizeType b_i{0}; b_i < 2; b_i++) {
            //  Initialize block to zero
            u0 = offset + 1;
            x = offset + npoints;
            for (coder::SizeType col{0}; col < 10; col++) {
              for (coder::SizeType row{u0}; row <= x; row++) {
                V[(row + V.size(1) * col) - 1] = 0.0;
              }
            }
            c = 10;
            for (deg = 4; deg <= i; deg++) {
              scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
              u0 = deg - 1;
              for (coder::SizeType j{0}; j <= u0; j++) {
                scaleu -= hs_inv__idx_0;
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(offset + iPnt) + V.size(1) * c] =
                      V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
                }
                c++;
              }
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            //  Compute the bi-degree terms if degree<0
            for (coder::SizeType len{x_tmp_tmp}; len >= -4; len--) {
              scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
              for (coder::SizeType k{0}; k < len; k++) {
                scaleu -= hs_inv__idx_0;
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(offset + iPnt) + V.size(1) * c] =
                      V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
                }
                c++;
              }
            }
            offset += stride;
            offset_prev += stride;
          }
          //  Compute derivative with respect to v
          offset_prev += us.size(0);
          i = offset + 1;
          u0 = offset + npoints;
          for (coder::SizeType col{0}; col < 10; col++) {
            for (coder::SizeType row{i}; row <= u0; row++) {
              V[(row + V.size(1) * col) - 1] = 0.0;
            }
          }
          c = 10;
          if (degree < 0) {
            i = -degree;
          } else {
            i = 0;
          }
          for (deg = 4; deg <= i; deg++) {
            for (coder::SizeType j{0}; j < 4; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
            }
            for (coder::SizeType j{4}; j <= deg; j++) {
              scalev = static_cast<real_T>(j) * hs_inv__idx_1;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - deg) - 1)] *
                    scalev;
              }
              c++;
            }
          }
          //  Compute the bi-degree terms if degree<0
          deg = -degree;
          for (coder::SizeType len{x_tmp_tmp}; len >= -4; len--) {
            deg++;
            scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
            for (coder::SizeType k{0}; k < len; k++) {
              scalev += hs_inv__idx_1;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((offset_prev - stride) + iPnt) +
                      V.size(1) * ((c - len) - 1)] *
                    scalev;
              }
              c++;
            }
          }
        }
      } break;
      default:
        m2cAssert(false, "Order must be 0, 1, 2, -1, -2, or -4");
        break;
      }
    }
  }
}

//  gen_vander_2d  Generate generalized/confluent Vandermonde matrix in 2D.
static void gen_vander_2d(const ::coder::array<real_T, 2U> &us,
                          coder::SizeType npoints, coder::SizeType degree,
                          const real_T hs_inv_data[],
                          const coder::SizeType hs_inv_size[2],
                          ::coder::array<real_T, 2U> &V)
{
  real_T hs_inv__idx_0;
  real_T hs_inv__idx_1;
  real_T scaleu;
  real_T scalev;
  coder::SizeType b_degree;
  coder::SizeType c;
  coder::SizeType c_degree;
  coder::SizeType deg;
  coder::SizeType i;
  coder::SizeType offset;
  coder::SizeType stride;
  coder::SizeType x_tmp_tmp;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (hs_inv_size[1] == 0) {
    hs_inv__idx_0 = 1.0;
    hs_inv__idx_1 = 1.0;
  } else {
    hs_inv__idx_0 = hs_inv_data[0];
    hs_inv__idx_1 = hs_inv_data[1];
  }
  stride = us.size(0);
  //  Number of row blocks
  if (degree >= 0) {
    b_degree = (degree + 1) * (degree + 2) / 2;
  } else {
    b_degree = (1 - degree) * (1 - degree);
  }
  if (degree > 0) {
    c_degree = 8;
  } else {
    c_degree = 11;
  }
  V.set_size(b_degree, us.size(0) * c_degree);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
    }
  } else {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 3;
  x_tmp_tmp = -degree;
  c_degree = -degree;
  if (-degree > 0) {
    c_degree = 1;
  } else if (-degree < 0) {
    c_degree = -1;
  }
  c_degree *= -4;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (c_degree < 0) {
    c_degree = 0;
  }
  i = b_degree - c_degree;
  for (deg = 2; deg <= i; deg++) {
    for (coder::SizeType j{0}; j < deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt + V.size(1) * c] =
          V[iPnt + V.size(1) * ((c - deg) - 1)] * us[us.size(1) * iPnt + 1];
    }
    c++;
  }
  //  Compute the bi-degree terms if degree<0
  for (deg = x_tmp_tmp; deg >= 5; deg--) {
    for (coder::SizeType k{0}; k < deg; k++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * us[us.size(1) * iPnt];
      }
      c++;
    }
  }
  //  compute higher order confluent Vandermonde matrix blocks incrementally
  m2cAssert(degree != 0, "");
  //  Compute derivative with respect to u
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    c_degree = stride + iPnt;
    V[c_degree] = 0.0;
    V[c_degree + V.size(1)] = V[iPnt] * hs_inv__idx_0;
    V[c_degree + V.size(1) * 2] = 0.0;
  }
  c = 3;
  c_degree = -degree;
  if (-degree > 0) {
    c_degree = 1;
  } else if (-degree < 0) {
    c_degree = -1;
  }
  c_degree *= -3;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (c_degree < 0) {
    c_degree = 0;
  }
  i = b_degree - c_degree;
  for (deg = 2; deg <= i; deg++) {
    scaleu = static_cast<real_T>(deg) * hs_inv__idx_0;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] =
          V[iPnt + V.size(1) * (c - deg)] * scaleu;
    }
    c++;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      scaleu -= hs_inv__idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - deg)] * scaleu;
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
  }
  //  Compute the bi-degree terms if degree<0
  for (coder::SizeType len{x_tmp_tmp}; len >= -3; len--) {
    scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
    for (coder::SizeType k{0}; k < len; k++) {
      scaleu -= hs_inv__idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - len)] * scaleu;
      }
      c++;
    }
  }
  //  Compute derivative with respect to v
  offset = us.size(0) + us.size(0);
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    c_degree = offset + iPnt;
    V[c_degree] = 0.0;
    V[c_degree + V.size(1)] = 0.0;
    V[c_degree + V.size(1) * 2] = V[iPnt] * hs_inv__idx_1;
  }
  c = 3;
  c_degree = -degree;
  if (-degree > 0) {
    c_degree = 1;
  } else if (-degree < 0) {
    c_degree = -1;
  }
  c_degree *= -3;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (c_degree < 0) {
    c_degree = 0;
  }
  i = b_degree - c_degree;
  for (deg = 2; deg <= i; deg++) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    for (coder::SizeType j{0}; j < deg; j++) {
      scalev = (static_cast<real_T>(j) + 1.0) * hs_inv__idx_1;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - deg) - 1)] * scalev;
      }
      c++;
    }
  }
  //  Compute the bi-degree terms if degree<0
  deg = -degree;
  for (coder::SizeType len{x_tmp_tmp}; len >= -3; len--) {
    deg++;
    scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
    for (coder::SizeType k{0}; k < len; k++) {
      scalev += hs_inv__idx_1;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * ((c - len) - 1)] * scalev;
      }
      c++;
    }
  }
  //      compute regular orders if order > 0
  if (degree > 0) {
    coder::SizeType offset_prev;
    //  Compute order-N CVM row blocks from order-(N-1) CVM.
    m2cAssert(true, "");
    offset = 3 * us.size(0);
    //  Compute derivative with respect to u
    i = offset + 1;
    b_degree = offset + npoints;
    for (coder::SizeType col{0}; col < 3; col++) {
      for (coder::SizeType row{i}; row <= b_degree; row++) {
        V[(row + V.size(1) * col) - 1] = 0.0;
      }
    }
    c = 3;
    for (deg = 2; deg <= degree; deg++) {
      scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
      i = deg - 1;
      for (coder::SizeType j{0}; j <= i; j++) {
        scaleu -= hs_inv__idx_0;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(us.size(0) + iPnt) + V.size(1) * (c - deg)] * scaleu;
        }
        c++;
      }
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    //  Compute the bi-degree terms if degree<0
    offset += us.size(0);
    //  Compute derivative with respect to v
    offset_prev = (us.size(0) + us.size(0)) + us.size(0);
    i = offset + 1;
    b_degree = offset + npoints;
    for (coder::SizeType col{0}; col < 3; col++) {
      for (coder::SizeType row{i}; row <= b_degree; row++) {
        V[(row + V.size(1) * col) - 1] = 0.0;
      }
    }
    c = 3;
    for (deg = 2; deg <= degree; deg++) {
      for (coder::SizeType j{0}; j < 2; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      for (coder::SizeType j{2}; j <= deg; j++) {
        scalev = static_cast<real_T>(j) * hs_inv__idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - deg) - 1)] *
              scalev;
        }
        c++;
      }
    }
    //  Compute the bi-degree terms if degree<0
    offset = 5 * us.size(0);
    offset_prev = 3 * us.size(0);
    m2cAssert(degree >= 4, "");
    //  compute du^4 and du^2*dv^2
    for (coder::SizeType terms{0}; terms < 2; terms++) {
      i = offset + 1;
      b_degree = offset + npoints;
      for (coder::SizeType col{0}; col < 10; col++) {
        for (coder::SizeType row{i}; row <= b_degree; row++) {
          V[(row + V.size(1) * col) - 1] = 0.0;
        }
      }
      c = 10;
      for (deg = 4; deg <= degree; deg++) {
        scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
        i = deg - 1;
        for (coder::SizeType j{0}; j <= i; j++) {
          scaleu -= hs_inv__idx_0;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(offset_prev + iPnt) + V.size(1) * ((c - (deg << 1)) + 1)] *
                scaleu * (scaleu - hs_inv__idx_0);
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      offset += stride;
      offset_prev += stride;
    }
    //  compute dv^4
    i = offset + 1;
    b_degree = offset + npoints;
    for (coder::SizeType col{0}; col < 10; col++) {
      for (coder::SizeType row{i}; row <= b_degree; row++) {
        V[(row + V.size(1) * col) - 1] = 0.0;
      }
    }
    c = 10;
    for (deg = 4; deg <= degree; deg++) {
      for (coder::SizeType j{0}; j < 4; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      for (coder::SizeType j{4}; j <= deg; j++) {
        scalev = static_cast<real_T>(j) * (hs_inv__idx_1 * hs_inv__idx_1);
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((offset_prev - stride) + iPnt) +
                V.size(1) * ((c - (deg << 1)) - 1)] *
              scalev * (static_cast<real_T>(j) - 1.0);
        }
        c++;
      }
    }
  } else {
    coder::SizeType offset_prev;
    //  Compute order-N CVM row blocks from order-(N-1) CVM.
    m2cAssert(degree != 0, "");
    offset = 3 * us.size(0);
    offset_prev = us.size(0);
    //  Compute derivative with respect to u
    if (degree < 0) {
      i = -degree;
    } else {
      i = 0;
    }
    //  Initialize block to zero
    b_degree = offset + 1;
    c_degree = offset + npoints;
    for (coder::SizeType col{0}; col < 3; col++) {
      for (coder::SizeType row{b_degree}; row <= c_degree; row++) {
        V[(row + V.size(1) * col) - 1] = 0.0;
      }
    }
    c = 3;
    for (deg = 2; deg <= i; deg++) {
      scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
      b_degree = deg - 1;
      for (coder::SizeType j{0}; j <= b_degree; j++) {
        scaleu -= hs_inv__idx_0;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
        }
        c++;
      }
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    //  Compute the bi-degree terms if degree<0
    for (coder::SizeType len{x_tmp_tmp}; len >= -2; len--) {
      scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
      for (coder::SizeType k{0}; k < len; k++) {
        scaleu -= hs_inv__idx_0;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
        }
        c++;
      }
    }
    offset += us.size(0);
    //  Compute derivative with respect to v
    offset_prev = (us.size(0) + us.size(0)) + us.size(0);
    i = offset + 1;
    b_degree = offset + npoints;
    for (coder::SizeType col{0}; col < 3; col++) {
      for (coder::SizeType row{i}; row <= b_degree; row++) {
        V[(row + V.size(1) * col) - 1] = 0.0;
      }
    }
    c = 3;
    if (degree < 0) {
      i = -degree;
    } else {
      i = 0;
    }
    for (deg = 2; deg <= i; deg++) {
      for (coder::SizeType j{0}; j < 2; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      for (coder::SizeType j{2}; j <= deg; j++) {
        scalev = static_cast<real_T>(j) * hs_inv__idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - deg) - 1)] *
              scalev;
        }
        c++;
      }
    }
    //  Compute the bi-degree terms if degree<0
    deg = -degree;
    for (coder::SizeType len{x_tmp_tmp}; len >= -2; len--) {
      deg++;
      scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
      for (coder::SizeType k{0}; k < len; k++) {
        scalev += hs_inv__idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - len) - 1)] *
              scalev;
        }
        c++;
      }
    }
    //  Compute order-N CVM row blocks from order-(N-1) CVM.
    m2cAssert(degree != 0, "");
    offset = 5 * us.size(0);
    offset_prev = 3 * us.size(0);
    //  Compute derivative with respect to u
    if (degree < 0) {
      i = -degree;
    } else {
      i = 0;
    }
    for (coder::SizeType b_i{0}; b_i < 2; b_i++) {
      //  Initialize block to zero
      b_degree = offset + 1;
      c_degree = offset + npoints;
      for (coder::SizeType col{0}; col < 6; col++) {
        for (coder::SizeType row{b_degree}; row <= c_degree; row++) {
          V[(row + V.size(1) * col) - 1] = 0.0;
        }
      }
      c = 6;
      for (deg = 3; deg <= i; deg++) {
        scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
        b_degree = deg - 1;
        for (coder::SizeType j{0}; j <= b_degree; j++) {
          scaleu -= hs_inv__idx_0;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      //  Compute the bi-degree terms if degree<0
      for (coder::SizeType len{x_tmp_tmp}; len >= -3; len--) {
        scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
        for (coder::SizeType k{0}; k < len; k++) {
          scaleu -= hs_inv__idx_0;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
          }
          c++;
        }
      }
      offset += stride;
      offset_prev += stride;
    }
    //  Compute derivative with respect to v
    i = offset + 1;
    b_degree = offset + npoints;
    for (coder::SizeType col{0}; col < 6; col++) {
      for (coder::SizeType row{i}; row <= b_degree; row++) {
        V[(row + V.size(1) * col) - 1] = 0.0;
      }
    }
    c = 6;
    if (degree < 0) {
      i = -degree;
    } else {
      i = 0;
    }
    for (deg = 3; deg <= i; deg++) {
      for (coder::SizeType j{0}; j < 3; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      for (coder::SizeType j{3}; j <= deg; j++) {
        scalev = static_cast<real_T>(j) * hs_inv__idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - deg) - 1)] *
              scalev;
        }
        c++;
      }
    }
    //  Compute the bi-degree terms if degree<0
    deg = -degree;
    for (coder::SizeType len{x_tmp_tmp}; len >= -3; len--) {
      deg++;
      scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
      for (coder::SizeType k{0}; k < len; k++) {
        scalev += hs_inv__idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - len) - 1)] *
              scalev;
        }
        c++;
      }
    }
    //  Compute order-N CVM row blocks from order-(N-1) CVM.
    m2cAssert(degree != 0, "");
    offset = us.size(0) << 3;
    offset_prev = 5 * us.size(0);
    //  Compute derivative with respect to u
    if (degree < 0) {
      i = -degree;
    } else {
      i = 0;
    }
    for (coder::SizeType b_i{0}; b_i < 2; b_i++) {
      //  Initialize block to zero
      b_degree = offset + 1;
      c_degree = offset + npoints;
      for (coder::SizeType col{0}; col < 10; col++) {
        for (coder::SizeType row{b_degree}; row <= c_degree; row++) {
          V[(row + V.size(1) * col) - 1] = 0.0;
        }
      }
      c = 10;
      for (deg = 4; deg <= i; deg++) {
        scaleu = static_cast<real_T>(deg + 1) * hs_inv__idx_0;
        b_degree = deg - 1;
        for (coder::SizeType j{0}; j <= b_degree; j++) {
          scaleu -= hs_inv__idx_0;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(offset_prev + iPnt) + V.size(1) * (c - deg)] * scaleu;
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      //  Compute the bi-degree terms if degree<0
      for (coder::SizeType len{x_tmp_tmp}; len >= -4; len--) {
        scaleu = static_cast<real_T>(1 - degree) * hs_inv__idx_0;
        for (coder::SizeType k{0}; k < len; k++) {
          scaleu -= hs_inv__idx_0;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(offset_prev + iPnt) + V.size(1) * (c - len)] * scaleu;
          }
          c++;
        }
      }
      offset += stride;
      offset_prev += stride;
    }
    //  Compute derivative with respect to v
    offset_prev += us.size(0);
    i = offset + 1;
    b_degree = offset + npoints;
    for (coder::SizeType col{0}; col < 10; col++) {
      for (coder::SizeType row{i}; row <= b_degree; row++) {
        V[(row + V.size(1) * col) - 1] = 0.0;
      }
    }
    c = 10;
    if (degree < 0) {
      i = -degree;
    } else {
      i = 0;
    }
    for (deg = 4; deg <= i; deg++) {
      for (coder::SizeType j{0}; j < 4; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
      }
      for (coder::SizeType j{4}; j <= deg; j++) {
        scalev = static_cast<real_T>(j) * hs_inv__idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - deg) - 1)] *
              scalev;
        }
        c++;
      }
    }
    //  Compute the bi-degree terms if degree<0
    deg = -degree;
    for (coder::SizeType len{x_tmp_tmp}; len >= -4; len--) {
      deg++;
      scalev = static_cast<real_T>((deg + degree) - 1) * hs_inv__idx_1;
      for (coder::SizeType k{0}; k < len; k++) {
        scalev += hs_inv__idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((offset_prev - stride) + iPnt) + V.size(1) * ((c - len) - 1)] *
              scalev;
        }
        c++;
      }
    }
  }
}

static void gen_vander_2d_dag(coder::SizeType degree,
                              ::coder::array<uint8_T, 2U> &dag)
{
  coder::SizeType b_degree;
  coder::SizeType c;
  coder::SizeType j;
  if (degree >= 0) {
    b_degree = (degree + 1) * (degree + 2) / 2;
  } else {
    b_degree = (1 - degree) * (1 - degree);
  }
  dag.set_size(b_degree + 1, 2);
  if (degree != 0) {
    dag[0] = 1U;
    //  x-child
    dag[1] = 2U;
    //  y-child
  } else {
    dag[0] = 0U;
    dag[1] = 0U;
    //  No children
  }
  c = 2;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  for (coder::SizeType deg{2}; deg <= b_degree; deg++) {
    dag[2 * ((c - deg) + 1)] = static_cast<uint8_T>(deg);
    //  x-child
    c += 2;
    for (j = 2; j <= deg; j++) {
      dag[2 * (((c + j) - deg) - 2)] = static_cast<uint8_T>(deg);
      //  x-child
      dag[2 * (((c + j) - deg) - 3) + 1] = static_cast<uint8_T>(deg + 1);
      //  y-child
    }
    c = (c + deg) - 1;
    dag[2 * ((c - deg) - 1) + 1] = static_cast<uint8_T>(deg + 1);
    //  y-child
  }
  //  Set the children of last row to zero
  if (degree > 0) {
    c -= degree;
    for (j = 0; j <= degree; j++) {
      dag[2 * c] = 0U;
      dag[2 * c + 1] = 0U;
      //  no children
      c++;
    }
  } else if (degree < 0) {
    //  Compute the bi-degree terms if degree<0
    b_degree = -degree;
    for (coder::SizeType deg{b_degree}; deg >= 1; deg--) {
      j = c - deg;
      dag[2 * j] = 0U;
      //  no x-child
      dag[2 * j + 1] = static_cast<uint8_T>(deg + 1);
      //  y-child
      dag[2 * (j + 1)] = static_cast<uint8_T>(deg);
      //  x-child
      c++;
      for (coder::SizeType k{2}; k <= deg; k++) {
        j = (c + k) - deg;
        dag[2 * (j - 1)] = static_cast<uint8_T>(deg);
        //  x-child
        dag[2 * (j - 2) + 1] = static_cast<uint8_T>(deg + 1);
        //  y-child
      }
      c = (c + deg) - 1;
      dag[2 * (c - deg) + 1] = 0U;
      //  no y-child
    }
    dag[2 * c] = 0U;
    dag[2 * c + 1] = 0U;
  }
  //  Use last entry as signature
  b_degree = (dag.size(0) << 1) - 1;
  dag[((b_degree % dag.size(0)) << 1) + b_degree / dag.size(0)] =
      static_cast<uint8_T>(degree + 127);
}

//  gen_vander_3d  Generate generalized/confluent Vandermonde matrix in 3D.
static void gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                          coder::SizeType npoints, coder::SizeType degree,
                          coder::SizeType order, const real_T hs_inv_data[],
                          const coder::SizeType hs_inv_size[2],
                          ::coder::array<real_T, 2U> &V)
{
  real_T hs_inv_idx_0;
  real_T hs_inv_idx_1;
  real_T hs_inv_idx_2;
  coder::SizeType b_degree;
  coder::SizeType c;
  coder::SizeType cornerTriangle;
  coder::SizeType counterBottomRow;
  coder::SizeType d;
  coder::SizeType deg;
  coder::SizeType excess;
  coder::SizeType i;
  coder::SizeType i1;
  coder::SizeType maxLayers;
  coder::SizeType nTermsInLayer;
  coder::SizeType nTermsInPrevLayer;
  coder::SizeType nrblks;
  coder::SizeType stride;
  coder::SizeType u0;
  coder::SizeType x;
  coder::SizeType x_tmp_tmp;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if ((order < -4) || (order == -3)) {
    m2cErrMsgIdAndTxt("wlslib:WrongOrder",
                      "Order %d must be 0, 1, 2, -1, -2, or -4", (int)order);
  }
  if (hs_inv_size[1] == 0) {
    hs_inv_idx_0 = 1.0;
    hs_inv_idx_1 = 1.0;
    hs_inv_idx_2 = 1.0;
  } else {
    hs_inv_idx_0 = hs_inv_data[0];
    hs_inv_idx_1 = hs_inv_data[1];
    hs_inv_idx_2 = hs_inv_data[2];
  }
  stride = us.size(0);
  nrblks = (order + 1) * (order + 2) * (order + 3) / 6;
  switch (order) {
  case -1:
    nrblks = 4;
    break;
  case -2:
    nrblks = 7;
    break;
  case -4:
    if (degree > 0) {
      nrblks = 13;
    } else {
      nrblks = 19;
    }
    break;
  }
  //  Allocate storage for V
  if (degree >= 0) {
    b_degree = (degree + 1) * (degree + 2) * (degree + 3) / 6;
  } else {
    b_degree = (1 - degree) * (1 - degree) * (1 - degree);
  }
  V.set_size(b_degree, us.size(0) * nrblks);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
      V[iPnt + V.size(1) * 3] = us[us.size(1) * iPnt + 2];
    }
  } else {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 4;
  d = 3;
  u0 = order;
  if (order > 0) {
    u0 = 0;
  }
  x_tmp_tmp = -degree;
  x = -degree;
  if (-degree > 0) {
    x = 1;
  } else if (-degree < 0) {
    x = -1;
  }
  x *= u0;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (x < 0) {
    x = 0;
  }
  i = b_degree - x;
  for (deg = 2; deg <= i; deg++) {
    //  Within each level, use convention of Pascal triangle with x^deg at peak
    for (coder::SizeType j{0}; j < deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * us[us.size(1) * iPnt];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt + V.size(1) * c] =
          V[iPnt + V.size(1) * ((c - d) - 1)] * us[us.size(1) * iPnt + 1];
    }
    c++;
    for (coder::SizeType j{0}; j < d; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] = V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
                                  us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    d = (d + deg) + 1;
  }
  //  Compute the tri-degree terms if degree<0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3 + u0;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      coder::SizeType gap;
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 1;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType k{0}; k < deg; k++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] = V[iPnt + V.size(1) * (c - nTermsInLayer)] *
                                    us[us.size(1) * iPnt + 1];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      x = ((degree + degree) + p) - 1;
      if (x < 0) {
        x = 0;
      }
      excess += x;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      gap = (nTermsInPrevLayer + counterBottomRow) - 1;
      i1 = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= i1; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - gap)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  m2cAssert(order <= 2, "");
  if (order != 0) {
    //      compute higher order confluent Vandermonde matrix blocks
    switch (order) {
    case 1: {
      real_T scalew;
      coder::SizeType balance;
      coder::SizeType offset;
      //  Compute order-1 CVM row blocks from order-0 GVM.
      m2cAssert(degree != 0, "");
      // compute derivatives with respect to u
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        b_degree = stride + iPnt;
        V[b_degree] = 0.0;
        V[b_degree + V.size(1)] = V[iPnt] * hs_inv_idx_0;
        V[b_degree + V.size(1) * 2] = 0.0;
        V[b_degree + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 3;
      u0 = order + 1;
      if (u0 > 0) {
        u0 = 0;
      }
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        real_T scaleu;
        scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * scaleu;
        }
        c++;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu -= hs_inv_idx_0;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scaleu;
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] = 0.0;
        }
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = stride + iPnt;
            V[b_degree + V.size(1) * (c + 1)] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      // tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 1;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = stride + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt + 1];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = (nTermsInPrevLayer + counterBottomRow) - 1;
          i1 = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= i1; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = stride + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to v
      offset = us.size(0) + us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        b_degree = offset + iPnt;
        V[b_degree] = 0.0;
        V[b_degree + V.size(1)] = 0.0;
        V[b_degree + V.size(1) * 2] = V[iPnt] * hs_inv_idx_1;
        V[b_degree + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 4;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        real_T scalev;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        scalev = hs_inv_idx_1;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scalev;
          }
          scalev += hs_inv_idx_1;
          c++;
        }
        scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * scalev;
        }
        c++;
        for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * c] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        d = (d + deg) + 1;
      }
      // compute the tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        x = order + 1;
        if (x > 0) {
          x = 0;
        }
        maxLayers = -degree * 3 + x;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d - 2;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer + 1;
          nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
          balance = nTermsInPrevLayer + counterBottomRow;
          i1 = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= i1; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to w
      offset += us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        V[x] = 0.0;
        V[x + V.size(1)] = 0.0;
        V[x + V.size(1) * 2] = 0.0;
        V[x + V.size(1) * 3] = V[iPnt] * hs_inv_idx_2;
      }
      c = 4;
      d = 3;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (((c - d) - deg) - 1)] * scalew;
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      // compute tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        u0 = order + 1;
        if (u0 > 0) {
          u0 = 0;
        }
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType k{0}; k < deg; k++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          b_degree = p + degree;
          x = ((b_degree << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = nTermsInPrevLayer + counterBottomRow;
          for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
            coder::SizeType partition;
            x = (b_degree - k) - 1;
            if (x < 0) {
              x = -x;
            }
            partition = -degree - x;
            for (coder::SizeType j{0}; j <= partition; j++) {
              scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(iPnt + offset) + V.size(1) * c] =
                    V[iPnt + V.size(1) * (c - balance)] * scalew;
              }
              c++;
            }
          }
        }
      }
    } break;
    case 2: {
      real_T scaleu;
      real_T scalev;
      real_T scalew;
      real_T uu2;
      real_T vv2;
      real_T ww2;
      coder::SizeType balance;
      coder::SizeType offset;
      coder::SizeType partition;
      //  Compute order-1 CVM row blocks from order-0 GVM.
      m2cAssert(degree != 0, "");
      // compute derivatives with respect to u
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        b_degree = stride + iPnt;
        V[b_degree] = 0.0;
        V[b_degree + V.size(1)] = V[iPnt] * hs_inv_idx_0;
        V[b_degree + V.size(1) * 2] = 0.0;
        V[b_degree + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 3;
      u0 = order + 1;
      if (u0 > 0) {
        u0 = 0;
      }
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * scaleu;
        }
        c++;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu -= hs_inv_idx_0;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scaleu;
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] = 0.0;
        }
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = stride + iPnt;
            V[b_degree + V.size(1) * (c + 1)] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      // tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 1;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = stride + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt + 1];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = (nTermsInPrevLayer + counterBottomRow) - 1;
          i1 = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= i1; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = stride + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to v
      offset = us.size(0) + us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        b_degree = offset + iPnt;
        V[b_degree] = 0.0;
        V[b_degree + V.size(1)] = 0.0;
        V[b_degree + V.size(1) * 2] = V[iPnt] * hs_inv_idx_1;
        V[b_degree + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 4;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        scalev = hs_inv_idx_1;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scalev;
          }
          scalev += hs_inv_idx_1;
          c++;
        }
        scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * scalev;
        }
        c++;
        for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * c] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        d = (d + deg) + 1;
      }
      // compute the tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        x = order + 1;
        if (x > 0) {
          x = 0;
        }
        maxLayers = -degree * 3 + x;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d - 2;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer + 1;
          nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
          balance = nTermsInPrevLayer + counterBottomRow;
          i1 = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= i1; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to w
      offset += us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        V[x] = 0.0;
        V[x + V.size(1)] = 0.0;
        V[x + V.size(1) * 2] = 0.0;
        V[x + V.size(1) * 3] = V[iPnt] * hs_inv_idx_2;
      }
      c = 4;
      d = 3;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (((c - d) - deg) - 1)] * scalew;
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      // compute tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        u0 = order + 1;
        if (u0 > 0) {
          u0 = 0;
        }
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType k{0}; k < deg; k++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          b_degree = p + degree;
          x = ((b_degree << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = nTermsInPrevLayer + counterBottomRow;
          for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
            x = (b_degree - k) - 1;
            if (x < 0) {
              x = -x;
            }
            partition = -degree - x;
            for (coder::SizeType j{0}; j <= partition; j++) {
              scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(iPnt + offset) + V.size(1) * c] =
                    V[iPnt + V.size(1) * (c - balance)] * scalew;
              }
              c++;
            }
          }
        }
      }
      //  compute du^2
      offset = us.size(0) << 2;
      uu2 = 2.0 * hs_inv_idx_0 * hs_inv_idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        V[x] = 0.0;
        V[x + V.size(1)] = 0.0;
        V[x + V.size(1) * 2] = 0.0;
        V[x + V.size(1) * 3] = 0.0;
        V[x + V.size(1) * 4] = uu2 * V[iPnt];
        for (i = 0; i < 5; i++) {
          V[x + V.size(1) * (i + 5)] = 0.0;
        }
      }
      c = 10;
      d = 6;
      u0 = order + 2;
      if (u0 > 0) {
        u0 = 0;
      }
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (x < 0) {
        x = 0;
      }
      i1 = i - x;
      for (deg = 3; deg <= i1; deg++) {
        scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
        }
        c++;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu -= hs_inv_idx_0;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * (c + 1)] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      // compute tri degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i1 = 1 - degree;
        for (coder::SizeType p{i1}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 1;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt + 1];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = (nTermsInPrevLayer + counterBottomRow) - 1;
          x = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= x; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      if (order > 0) {
        real_T uv;
        //      compute du*dv
        offset += us.size(0);
        uv = hs_inv_idx_0 * hs_inv_idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = offset + iPnt;
          for (i1 = 0; i1 < 5; i1++) {
            V[x + V.size(1) * i1] = 0.0;
          }
          V[x + V.size(1) * 5] = uv * V[iPnt];
          V[x + V.size(1) * 6] = 0.0;
          V[x + V.size(1) * 7] = 0.0;
          V[x + V.size(1) * 8] = 0.0;
          V[x + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 7;
        for (deg = 3; deg <= i; deg++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = hs_inv_idx_1;
          for (coder::SizeType j{0}; j <= deg - 2; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + stride) + V.size(1) * (c - d)] * scalev;
            }
            scalev += hs_inv_idx_1;
            c++;
          }
          scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] * scalev;
          }
          c++;
          for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * ((c - d) - deg)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i1 = 1 - degree;
          for (coder::SizeType p{i1}; p <= maxLayers; p++) {
            //  implicitly calculating number of elements in corner Pascal
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((stride << 1) + iPnt) +
                      V.size(1) * (c - nTermsInLayer)] *
                    static_cast<real_T>(-degree - kdegree) * hs_inv_idx_0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x = (((p + degree) << 1) - p) - 1;
            if (x < 0) {
              x = 0;
            }
            excess += x;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            x = nTermsInLayer - counterBottomRow;
            for (coder::SizeType j{0}; j <= x; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                b_degree = offset + iPnt;
                V[b_degree + V.size(1) * c] =
                    V[b_degree + V.size(1) * (c - balance)] *
                    us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      }
      //  compute dv^2
      offset += us.size(0);
      vv2 = 2.0 * hs_inv_idx_1 * hs_inv_idx_1;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        for (i1 = 0; i1 < 6; i1++) {
          V[x + V.size(1) * i1] = 0.0;
        }
        V[x + V.size(1) * 6] = vv2 * V[iPnt];
        V[x + V.size(1) * 7] = 0.0;
        V[x + V.size(1) * 8] = 0.0;
        V[x + V.size(1) * 9] = 0.0;
      }
      c = 10;
      d = 7;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i1 = b_degree - x;
      for (deg = 3; deg <= i1; deg++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        scalev = hs_inv_idx_1;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + (stride << 1)) + V.size(1) * (c - d)] * scalev;
          }
          scalev += hs_inv_idx_1;
          c++;
        }
        scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((stride << 1) + iPnt) + V.size(1) * (c - d)] * scalev;
        }
        c++;
        for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * c] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        d = (d + deg) + 1;
      }
      // compute the tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        x = order + 2;
        if (x > 0) {
          x = 0;
        }
        maxLayers = -degree * 3 + x;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d - 2;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i1 = 1 - degree;
        for (coder::SizeType p{i1}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer + 1;
          nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
          balance = nTermsInPrevLayer + counterBottomRow;
          x = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= x; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      if (order > 0) {
        real_T uw;
        real_T vw;
        //      compute du*dw
        offset = (offset + us.size(0)) - 1;
        uw = hs_inv_idx_0 * hs_inv_idx_2;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = (offset + iPnt) + 1;
          for (i1 = 0; i1 < 7; i1++) {
            V[x + V.size(1) * i1] = 0.0;
          }
          V[x + V.size(1) * 7] = uw * V[iPnt];
          V[x + V.size(1) * 8] = 0.0;
          V[x + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        for (deg = 3; deg <= i; deg++) {
          for (coder::SizeType j{0}; j <= deg; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
            }
            c++;
          }
          for (coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] =
                    V[(iPnt + stride) + V.size(1) * (((c - d) - deg) - 1)] *
                    scalew;
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i1 = 1 - degree;
          for (coder::SizeType p{i1}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (coder::SizeType k{0}; k < deg; k++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            b_degree = p + degree;
            x = ((b_degree << 1) - p) - 1;
            if (x < 0) {
              x = 0;
            }
            excess += x;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
              x = (b_degree - k) - 1;
              if (x < 0) {
                x = -x;
              }
              partition = -degree - x;
              for (coder::SizeType j{0}; j <= partition; j++) {
                scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[((iPnt + offset) + V.size(1) * c) + 1] =
                      V[(iPnt + stride) + V.size(1) * (c - balance)] * scalew;
                }
                c++;
              }
            }
          }
        }
        //      compute dv*dw
        offset = (offset + us.size(0)) + 1;
        vw = hs_inv_idx_1 * hs_inv_idx_2;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = offset + iPnt;
          for (i1 = 0; i1 < 8; i1++) {
            V[x + V.size(1) * i1] = 0.0;
          }
          V[x + V.size(1) * 8] = vw * V[iPnt];
          V[x + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        for (deg = 3; deg <= i; deg++) {
          for (coder::SizeType j{0}; j <= deg; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(iPnt + (stride << 1)) +
                      V.size(1) * (((c - d) - deg) - 1)] *
                    scalew;
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (coder::SizeType k{0}; k < deg; k++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            b_degree = p + degree;
            x = ((b_degree << 1) - p) - 1;
            if (x < 0) {
              x = 0;
            }
            excess += x;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
              x = (b_degree - k) - 1;
              if (x < 0) {
                x = -x;
              }
              partition = -degree - x;
              for (coder::SizeType j{0}; j <= partition; j++) {
                scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[(iPnt + (stride << 1)) + V.size(1) * (c - balance)] *
                      scalew;
                }
                c++;
              }
            }
          }
        }
      }
      //  compute dw^2
      offset += us.size(0);
      ww2 = 2.0 * hs_inv_idx_2 * hs_inv_idx_2;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        for (i = 0; i < 9; i++) {
          V[x + V.size(1) * i] = 0.0;
        }
        V[x + V.size(1) * 9] = ww2 * V[iPnt];
      }
      c = 10;
      d = 6;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 3; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + 3 * stride) + V.size(1) * (((c - d) - deg) - 1)] *
                  scalew;
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      // compute tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        u0 = order + 2;
        if (u0 > 0) {
          u0 = 0;
        }
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType k{0}; k < deg; k++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          b_degree = p + degree;
          x = ((b_degree << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = nTermsInPrevLayer + counterBottomRow;
          for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
            x = (b_degree - k) - 1;
            if (x < 0) {
              x = -x;
            }
            partition = -degree - x;
            for (coder::SizeType j{0}; j <= partition; j++) {
              scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(iPnt + offset) + V.size(1) * c] =
                    V[(iPnt + 3 * stride) + V.size(1) * (c - balance)] * scalew;
              }
              c++;
            }
          }
        }
      }
    } break;
    case -1: {
      real_T scalew;
      coder::SizeType balance;
      coder::SizeType offset;
      //  Compute order-1 CVM row blocks from order-0 GVM.
      m2cAssert(degree != 0, "");
      // compute derivatives with respect to u
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        b_degree = stride + iPnt;
        V[b_degree] = 0.0;
        V[b_degree + V.size(1)] = V[iPnt] * hs_inv_idx_0;
        V[b_degree + V.size(1) * 2] = 0.0;
        V[b_degree + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 3;
      u0 = order + 1;
      if (u0 > 0) {
        u0 = 0;
      }
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        real_T scaleu;
        scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * scaleu;
        }
        c++;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu -= hs_inv_idx_0;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scaleu;
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] = 0.0;
        }
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = stride + iPnt;
            V[b_degree + V.size(1) * (c + 1)] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      // tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 1;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = stride + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt + 1];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = (nTermsInPrevLayer + counterBottomRow) - 1;
          i1 = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= i1; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = stride + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to v
      offset = us.size(0) + us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        b_degree = offset + iPnt;
        V[b_degree] = 0.0;
        V[b_degree + V.size(1)] = 0.0;
        V[b_degree + V.size(1) * 2] = V[iPnt] * hs_inv_idx_1;
        V[b_degree + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 4;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        real_T scalev;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        scalev = hs_inv_idx_1;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scalev;
          }
          scalev += hs_inv_idx_1;
          c++;
        }
        scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * scalev;
        }
        c++;
        for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * c] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        d = (d + deg) + 1;
      }
      // compute the tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        x = order + 1;
        if (x > 0) {
          x = 0;
        }
        maxLayers = -degree * 3 + x;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d - 2;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer + 1;
          nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
          balance = nTermsInPrevLayer + counterBottomRow;
          i1 = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= i1; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to w
      offset += us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        V[x] = 0.0;
        V[x + V.size(1)] = 0.0;
        V[x + V.size(1) * 2] = 0.0;
        V[x + V.size(1) * 3] = V[iPnt] * hs_inv_idx_2;
      }
      c = 4;
      d = 3;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (((c - d) - deg) - 1)] * scalew;
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      // compute tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        u0 = order + 1;
        if (u0 > 0) {
          u0 = 0;
        }
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType k{0}; k < deg; k++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          b_degree = p + degree;
          x = ((b_degree << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = nTermsInPrevLayer + counterBottomRow;
          for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
            coder::SizeType partition;
            x = (b_degree - k) - 1;
            if (x < 0) {
              x = -x;
            }
            partition = -degree - x;
            for (coder::SizeType j{0}; j <= partition; j++) {
              scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(iPnt + offset) + V.size(1) * c] =
                    V[iPnt + V.size(1) * (c - balance)] * scalew;
              }
              c++;
            }
          }
        }
      }
    } break;
    case -2: {
      real_T scaleu;
      real_T scalev;
      real_T scalew;
      real_T uu2;
      real_T vv2;
      real_T ww2;
      coder::SizeType balance;
      coder::SizeType offset;
      coder::SizeType partition;
      //  Compute order-1 CVM row blocks from order-0 GVM.
      m2cAssert(degree != 0, "");
      // compute derivatives with respect to u
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        b_degree = stride + iPnt;
        V[b_degree] = 0.0;
        V[b_degree + V.size(1)] = V[iPnt] * hs_inv_idx_0;
        V[b_degree + V.size(1) * 2] = 0.0;
        V[b_degree + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 3;
      u0 = order + 1;
      if (u0 > 0) {
        u0 = 0;
      }
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * scaleu;
        }
        c++;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu -= hs_inv_idx_0;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scaleu;
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] = 0.0;
        }
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = stride + iPnt;
            V[b_degree + V.size(1) * (c + 1)] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      // tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 1;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = stride + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt + 1];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = (nTermsInPrevLayer + counterBottomRow) - 1;
          i1 = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= i1; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = stride + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to v
      offset = us.size(0) + us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        b_degree = offset + iPnt;
        V[b_degree] = 0.0;
        V[b_degree + V.size(1)] = 0.0;
        V[b_degree + V.size(1) * 2] = V[iPnt] * hs_inv_idx_1;
        V[b_degree + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 4;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        scalev = hs_inv_idx_1;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scalev;
          }
          scalev += hs_inv_idx_1;
          c++;
        }
        scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * scalev;
        }
        c++;
        for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * c] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        d = (d + deg) + 1;
      }
      // compute the tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        x = order + 1;
        if (x > 0) {
          x = 0;
        }
        maxLayers = -degree * 3 + x;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d - 2;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer + 1;
          nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
          balance = nTermsInPrevLayer + counterBottomRow;
          i1 = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= i1; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to w
      offset += us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        V[x] = 0.0;
        V[x + V.size(1)] = 0.0;
        V[x + V.size(1) * 2] = 0.0;
        V[x + V.size(1) * 3] = V[iPnt] * hs_inv_idx_2;
      }
      c = 4;
      d = 3;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (((c - d) - deg) - 1)] * scalew;
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      // compute tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        u0 = order + 1;
        if (u0 > 0) {
          u0 = 0;
        }
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType k{0}; k < deg; k++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          b_degree = p + degree;
          x = ((b_degree << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = nTermsInPrevLayer + counterBottomRow;
          for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
            x = (b_degree - k) - 1;
            if (x < 0) {
              x = -x;
            }
            partition = -degree - x;
            for (coder::SizeType j{0}; j <= partition; j++) {
              scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(iPnt + offset) + V.size(1) * c] =
                    V[iPnt + V.size(1) * (c - balance)] * scalew;
              }
              c++;
            }
          }
        }
      }
      //  compute du^2
      offset = us.size(0) << 2;
      uu2 = 2.0 * hs_inv_idx_0 * hs_inv_idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        V[x] = 0.0;
        V[x + V.size(1)] = 0.0;
        V[x + V.size(1) * 2] = 0.0;
        V[x + V.size(1) * 3] = 0.0;
        V[x + V.size(1) * 4] = uu2 * V[iPnt];
        for (i = 0; i < 5; i++) {
          V[x + V.size(1) * (i + 5)] = 0.0;
        }
      }
      c = 10;
      d = 6;
      u0 = order + 2;
      if (u0 > 0) {
        u0 = 0;
      }
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (x < 0) {
        x = 0;
      }
      i1 = i - x;
      for (deg = 3; deg <= i1; deg++) {
        scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
        }
        c++;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu -= hs_inv_idx_0;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * (c + 1)] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      // compute tri degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i1 = 1 - degree;
        for (coder::SizeType p{i1}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 1;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt + 1];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = (nTermsInPrevLayer + counterBottomRow) - 1;
          x = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= x; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      if (order > 0) {
        real_T uv;
        //      compute du*dv
        offset += us.size(0);
        uv = hs_inv_idx_0 * hs_inv_idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = offset + iPnt;
          for (i1 = 0; i1 < 5; i1++) {
            V[x + V.size(1) * i1] = 0.0;
          }
          V[x + V.size(1) * 5] = uv * V[iPnt];
          V[x + V.size(1) * 6] = 0.0;
          V[x + V.size(1) * 7] = 0.0;
          V[x + V.size(1) * 8] = 0.0;
          V[x + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 7;
        for (deg = 3; deg <= i; deg++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = hs_inv_idx_1;
          for (coder::SizeType j{0}; j <= deg - 2; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + stride) + V.size(1) * (c - d)] * scalev;
            }
            scalev += hs_inv_idx_1;
            c++;
          }
          scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] * scalev;
          }
          c++;
          for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * ((c - d) - deg)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i1 = 1 - degree;
          for (coder::SizeType p{i1}; p <= maxLayers; p++) {
            //  implicitly calculating number of elements in corner Pascal
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((stride << 1) + iPnt) +
                      V.size(1) * (c - nTermsInLayer)] *
                    static_cast<real_T>(-degree - kdegree) * hs_inv_idx_0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x = (((p + degree) << 1) - p) - 1;
            if (x < 0) {
              x = 0;
            }
            excess += x;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            x = nTermsInLayer - counterBottomRow;
            for (coder::SizeType j{0}; j <= x; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                b_degree = offset + iPnt;
                V[b_degree + V.size(1) * c] =
                    V[b_degree + V.size(1) * (c - balance)] *
                    us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      }
      //  compute dv^2
      offset += us.size(0);
      vv2 = 2.0 * hs_inv_idx_1 * hs_inv_idx_1;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        for (i1 = 0; i1 < 6; i1++) {
          V[x + V.size(1) * i1] = 0.0;
        }
        V[x + V.size(1) * 6] = vv2 * V[iPnt];
        V[x + V.size(1) * 7] = 0.0;
        V[x + V.size(1) * 8] = 0.0;
        V[x + V.size(1) * 9] = 0.0;
      }
      c = 10;
      d = 7;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i1 = b_degree - x;
      for (deg = 3; deg <= i1; deg++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        scalev = hs_inv_idx_1;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + (stride << 1)) + V.size(1) * (c - d)] * scalev;
          }
          scalev += hs_inv_idx_1;
          c++;
        }
        scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((stride << 1) + iPnt) + V.size(1) * (c - d)] * scalev;
        }
        c++;
        for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * c] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        d = (d + deg) + 1;
      }
      // compute the tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        x = order + 2;
        if (x > 0) {
          x = 0;
        }
        maxLayers = -degree * 3 + x;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d - 2;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i1 = 1 - degree;
        for (coder::SizeType p{i1}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer + 1;
          nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
          balance = nTermsInPrevLayer + counterBottomRow;
          x = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= x; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      if (order > 0) {
        real_T uw;
        real_T vw;
        //      compute du*dw
        offset = (offset + us.size(0)) - 1;
        uw = hs_inv_idx_0 * hs_inv_idx_2;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = (offset + iPnt) + 1;
          for (i1 = 0; i1 < 7; i1++) {
            V[x + V.size(1) * i1] = 0.0;
          }
          V[x + V.size(1) * 7] = uw * V[iPnt];
          V[x + V.size(1) * 8] = 0.0;
          V[x + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        for (deg = 3; deg <= i; deg++) {
          for (coder::SizeType j{0}; j <= deg; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
            }
            c++;
          }
          for (coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] =
                    V[(iPnt + stride) + V.size(1) * (((c - d) - deg) - 1)] *
                    scalew;
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i1 = 1 - degree;
          for (coder::SizeType p{i1}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (coder::SizeType k{0}; k < deg; k++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            b_degree = p + degree;
            x = ((b_degree << 1) - p) - 1;
            if (x < 0) {
              x = 0;
            }
            excess += x;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
              x = (b_degree - k) - 1;
              if (x < 0) {
                x = -x;
              }
              partition = -degree - x;
              for (coder::SizeType j{0}; j <= partition; j++) {
                scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[((iPnt + offset) + V.size(1) * c) + 1] =
                      V[(iPnt + stride) + V.size(1) * (c - balance)] * scalew;
                }
                c++;
              }
            }
          }
        }
        //      compute dv*dw
        offset = (offset + us.size(0)) + 1;
        vw = hs_inv_idx_1 * hs_inv_idx_2;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = offset + iPnt;
          for (i1 = 0; i1 < 8; i1++) {
            V[x + V.size(1) * i1] = 0.0;
          }
          V[x + V.size(1) * 8] = vw * V[iPnt];
          V[x + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        for (deg = 3; deg <= i; deg++) {
          for (coder::SizeType j{0}; j <= deg; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(iPnt + (stride << 1)) +
                      V.size(1) * (((c - d) - deg) - 1)] *
                    scalew;
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (coder::SizeType k{0}; k < deg; k++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            b_degree = p + degree;
            x = ((b_degree << 1) - p) - 1;
            if (x < 0) {
              x = 0;
            }
            excess += x;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
              x = (b_degree - k) - 1;
              if (x < 0) {
                x = -x;
              }
              partition = -degree - x;
              for (coder::SizeType j{0}; j <= partition; j++) {
                scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[(iPnt + (stride << 1)) + V.size(1) * (c - balance)] *
                      scalew;
                }
                c++;
              }
            }
          }
        }
      }
      //  compute dw^2
      offset += us.size(0);
      ww2 = 2.0 * hs_inv_idx_2 * hs_inv_idx_2;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        for (i = 0; i < 9; i++) {
          V[x + V.size(1) * i] = 0.0;
        }
        V[x + V.size(1) * 9] = ww2 * V[iPnt];
      }
      c = 10;
      d = 6;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 3; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + 3 * stride) + V.size(1) * (((c - d) - deg) - 1)] *
                  scalew;
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      // compute tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        u0 = order + 2;
        if (u0 > 0) {
          u0 = 0;
        }
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType k{0}; k < deg; k++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          b_degree = p + degree;
          x = ((b_degree << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = nTermsInPrevLayer + counterBottomRow;
          for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
            x = (b_degree - k) - 1;
            if (x < 0) {
              x = -x;
            }
            partition = -degree - x;
            for (coder::SizeType j{0}; j <= partition; j++) {
              scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(iPnt + offset) + V.size(1) * c] =
                    V[(iPnt + 3 * stride) + V.size(1) * (c - balance)] * scalew;
              }
              c++;
            }
          }
        }
      }
    } break;
    case -4: {
      real_T b_u2v2_tmp;
      real_T scaleu;
      real_T scalev;
      real_T scalew;
      real_T u2v2;
      real_T u2v2_tmp;
      real_T u2w2;
      real_T u2w2_tmp;
      real_T uu2;
      real_T uu4;
      real_T v2w2;
      real_T v4;
      real_T vv2;
      real_T ww2;
      real_T ww4;
      coder::SizeType balance;
      coder::SizeType offset;
      coder::SizeType partition;
      m2cAssert(degree > 0, "Biharnomic is only supported for "
                            "Pascal-tetrahedral monomials in 3D.");
      //  Compute order-1 CVM row blocks from order-0 GVM.
      m2cAssert(degree != 0, "");
      // compute derivatives with respect to u
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        b_degree = stride + iPnt;
        V[b_degree] = 0.0;
        V[b_degree + V.size(1)] = V[iPnt] * hs_inv_idx_0;
        V[b_degree + V.size(1) * 2] = 0.0;
        V[b_degree + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 3;
      u0 = order + 1;
      if (u0 > 0) {
        u0 = 0;
      }
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * scaleu;
        }
        c++;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu -= hs_inv_idx_0;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scaleu;
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] = 0.0;
        }
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = stride + iPnt;
            V[b_degree + V.size(1) * (c + 1)] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      // tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 1;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = stride + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt + 1];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = (nTermsInPrevLayer + counterBottomRow) - 1;
          i1 = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= i1; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = stride + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to v
      offset = us.size(0) + us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        b_degree = offset + iPnt;
        V[b_degree] = 0.0;
        V[b_degree + V.size(1)] = 0.0;
        V[b_degree + V.size(1) * 2] = V[iPnt] * hs_inv_idx_1;
        V[b_degree + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 4;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      u0 = order + 1;
      if (u0 > 0) {
        u0 = 0;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        scalev = hs_inv_idx_1;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scalev;
          }
          scalev += hs_inv_idx_1;
          c++;
        }
        scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * scalev;
        }
        c++;
        for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * c] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        d = (d + deg) + 1;
      }
      // compute the tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        u0 = order + 1;
        if (u0 > 0) {
          u0 = 0;
        }
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d - 2;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer + 1;
          nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
          balance = nTermsInPrevLayer + counterBottomRow;
          i1 = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= i1; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to w
      offset += us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        V[x] = 0.0;
        V[x + V.size(1)] = 0.0;
        V[x + V.size(1) * 2] = 0.0;
        V[x + V.size(1) * 3] = V[iPnt] * hs_inv_idx_2;
      }
      c = 4;
      d = 3;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      u0 = order + 1;
      if (u0 > 0) {
        u0 = 0;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (((c - d) - deg) - 1)] * scalew;
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      // compute tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        u0 = order + 1;
        if (u0 > 0) {
          u0 = 0;
        }
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType k{0}; k < deg; k++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          b_degree = p + degree;
          x = ((b_degree << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = nTermsInPrevLayer + counterBottomRow;
          for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
            x = (b_degree - k) - 1;
            if (x < 0) {
              x = -x;
            }
            partition = -degree - x;
            for (coder::SizeType j{0}; j <= partition; j++) {
              scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(iPnt + offset) + V.size(1) * c] =
                    V[iPnt + V.size(1) * (c - balance)] * scalew;
              }
              c++;
            }
          }
        }
      }
      //  compute du^2
      offset = us.size(0) << 2;
      uu2 = 2.0 * hs_inv_idx_0 * hs_inv_idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        V[x] = 0.0;
        V[x + V.size(1)] = 0.0;
        V[x + V.size(1) * 2] = 0.0;
        V[x + V.size(1) * 3] = 0.0;
        V[x + V.size(1) * 4] = uu2 * V[iPnt];
        for (i = 0; i < 5; i++) {
          V[x + V.size(1) * (i + 5)] = 0.0;
        }
      }
      c = 10;
      d = 6;
      u0 = order + 2;
      if (u0 > 0) {
        u0 = 0;
      }
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (x < 0) {
        x = 0;
      }
      i1 = i - x;
      for (deg = 3; deg <= i1; deg++) {
        scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
        }
        c++;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu -= hs_inv_idx_0;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * (c + 1)] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      // compute tri degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i1 = 1 - degree;
        for (coder::SizeType p{i1}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 1;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt + 1];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = (nTermsInPrevLayer + counterBottomRow) - 1;
          x = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= x; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      if (order > 0) {
        real_T uv;
        //      compute du*dv
        offset += us.size(0);
        uv = hs_inv_idx_0 * hs_inv_idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = offset + iPnt;
          for (i1 = 0; i1 < 5; i1++) {
            V[x + V.size(1) * i1] = 0.0;
          }
          V[x + V.size(1) * 5] = uv * V[iPnt];
          V[x + V.size(1) * 6] = 0.0;
          V[x + V.size(1) * 7] = 0.0;
          V[x + V.size(1) * 8] = 0.0;
          V[x + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 7;
        for (deg = 3; deg <= i; deg++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = hs_inv_idx_1;
          for (coder::SizeType j{0}; j <= deg - 2; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + stride) + V.size(1) * (c - d)] * scalev;
            }
            scalev += hs_inv_idx_1;
            c++;
          }
          scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] * scalev;
          }
          c++;
          for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * ((c - d) - deg)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i1 = 1 - degree;
          for (coder::SizeType p{i1}; p <= maxLayers; p++) {
            //  implicitly calculating number of elements in corner Pascal
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((stride << 1) + iPnt) +
                      V.size(1) * (c - nTermsInLayer)] *
                    static_cast<real_T>(-degree - kdegree) * hs_inv_idx_0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x = (((p + degree) << 1) - p) - 1;
            if (x < 0) {
              x = 0;
            }
            excess += x;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            x = nTermsInLayer - counterBottomRow;
            for (coder::SizeType j{0}; j <= x; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                b_degree = offset + iPnt;
                V[b_degree + V.size(1) * c] =
                    V[b_degree + V.size(1) * (c - balance)] *
                    us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      }
      //  compute dv^2
      offset += us.size(0);
      vv2 = 2.0 * hs_inv_idx_1 * hs_inv_idx_1;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        for (i1 = 0; i1 < 6; i1++) {
          V[x + V.size(1) * i1] = 0.0;
        }
        V[x + V.size(1) * 6] = vv2 * V[iPnt];
        V[x + V.size(1) * 7] = 0.0;
        V[x + V.size(1) * 8] = 0.0;
        V[x + V.size(1) * 9] = 0.0;
      }
      c = 10;
      d = 7;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      u0 = order + 2;
      if (u0 > 0) {
        u0 = 0;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i1 = b_degree - x;
      for (deg = 3; deg <= i1; deg++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        scalev = hs_inv_idx_1;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + (stride << 1)) + V.size(1) * (c - d)] * scalev;
          }
          scalev += hs_inv_idx_1;
          c++;
        }
        scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((stride << 1) + iPnt) + V.size(1) * (c - d)] * scalev;
        }
        c++;
        for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * c] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        d = (d + deg) + 1;
      }
      // compute the tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        u0 = order + 2;
        if (u0 > 0) {
          u0 = 0;
        }
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d - 2;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i1 = 1 - degree;
        for (coder::SizeType p{i1}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer + 1;
          nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
          balance = nTermsInPrevLayer + counterBottomRow;
          x = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= x; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      if (order > 0) {
        real_T uw;
        real_T vw;
        //      compute du*dw
        offset = (offset + us.size(0)) - 1;
        uw = hs_inv_idx_0 * hs_inv_idx_2;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = (offset + iPnt) + 1;
          for (i1 = 0; i1 < 7; i1++) {
            V[x + V.size(1) * i1] = 0.0;
          }
          V[x + V.size(1) * 7] = uw * V[iPnt];
          V[x + V.size(1) * 8] = 0.0;
          V[x + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        for (deg = 3; deg <= i; deg++) {
          for (coder::SizeType j{0}; j <= deg; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
            }
            c++;
          }
          for (coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] =
                    V[(iPnt + stride) + V.size(1) * (((c - d) - deg) - 1)] *
                    scalew;
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i1 = 1 - degree;
          for (coder::SizeType p{i1}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (coder::SizeType k{0}; k < deg; k++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            b_degree = p + degree;
            x = ((b_degree << 1) - p) - 1;
            if (x < 0) {
              x = 0;
            }
            excess += x;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
              x = (b_degree - k) - 1;
              if (x < 0) {
                x = -x;
              }
              partition = -degree - x;
              for (coder::SizeType j{0}; j <= partition; j++) {
                scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[((iPnt + offset) + V.size(1) * c) + 1] =
                      V[(iPnt + stride) + V.size(1) * (c - balance)] * scalew;
                }
                c++;
              }
            }
          }
        }
        //      compute dv*dw
        offset = (offset + us.size(0)) + 1;
        vw = hs_inv_idx_1 * hs_inv_idx_2;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = offset + iPnt;
          for (i1 = 0; i1 < 8; i1++) {
            V[x + V.size(1) * i1] = 0.0;
          }
          V[x + V.size(1) * 8] = vw * V[iPnt];
          V[x + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        for (deg = 3; deg <= i; deg++) {
          for (coder::SizeType j{0}; j <= deg; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(iPnt + (stride << 1)) +
                      V.size(1) * (((c - d) - deg) - 1)] *
                    scalew;
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (coder::SizeType k{0}; k < deg; k++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            b_degree = p + degree;
            x = ((b_degree << 1) - p) - 1;
            if (x < 0) {
              x = 0;
            }
            excess += x;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
              x = (b_degree - k) - 1;
              if (x < 0) {
                x = -x;
              }
              partition = -degree - x;
              for (coder::SizeType j{0}; j <= partition; j++) {
                scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[(iPnt + (stride << 1)) + V.size(1) * (c - balance)] *
                      scalew;
                }
                c++;
              }
            }
          }
        }
      }
      //  compute dw^2
      offset += us.size(0);
      ww2 = 2.0 * hs_inv_idx_2 * hs_inv_idx_2;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        for (i = 0; i < 9; i++) {
          V[x + V.size(1) * i] = 0.0;
        }
        V[x + V.size(1) * 9] = ww2 * V[iPnt];
      }
      c = 10;
      d = 6;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      u0 = order + 2;
      if (u0 > 0) {
        u0 = 0;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 3; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + 3 * stride) + V.size(1) * (((c - d) - deg) - 1)] *
                  scalew;
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      // compute tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        u0 = order + 2;
        if (u0 > 0) {
          u0 = 0;
        }
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType k{0}; k < deg; k++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          b_degree = p + degree;
          x = ((b_degree << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = nTermsInPrevLayer + counterBottomRow;
          for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
            x = (b_degree - k) - 1;
            if (x < 0) {
              x = -x;
            }
            partition = -degree - x;
            for (coder::SizeType j{0}; j <= partition; j++) {
              scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(iPnt + offset) + V.size(1) * c] =
                    V[(iPnt + 3 * stride) + V.size(1) * (c - balance)] * scalew;
              }
              c++;
            }
          }
        }
      }
      //  compute du^4
      offset = us.size(0) * 7;
      uu4 = 24.0 * std::pow(hs_inv_idx_0, 4.0);
      for (coder::SizeType b_i{0}; b_i < 35; b_i++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
        }
      }
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * 20] = uu4 * V[iPnt];
      }
      c = 35;
      d = 15;
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      for (deg = 5; deg <= i; deg++) {
        scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + (stride << 2)) + V.size(1) * ((c - (d << 1)) + deg)] *
              scaleu * (scaleu - hs_inv_idx_0);
        }
        c++;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu -= hs_inv_idx_0;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + (stride << 2)) + V.size(1) * ((c - (d << 1)) + deg)] *
                scaleu * (scaleu - hs_inv_idx_0);
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * (c + 1)] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      //  compute du^2dv^2
      offset = us.size(0) << 3;
      u2v2_tmp = 4.0 * (hs_inv_idx_0 * hs_inv_idx_0);
      b_u2v2_tmp = hs_inv_idx_1 * hs_inv_idx_1;
      u2v2 = u2v2_tmp * b_u2v2_tmp;
      for (coder::SizeType b_i{0}; b_i < 35; b_i++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
        }
      }
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * 22] = u2v2 * V[iPnt];
      }
      c = 35;
      d = 15;
      for (deg = 5; deg <= i; deg++) {
        scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + 5 * stride) + V.size(1) * ((c - (d << 1)) + deg)] *
              scaleu * (scaleu - hs_inv_idx_0);
        }
        c++;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu -= hs_inv_idx_0;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + 5 * stride) + V.size(1) * ((c - (d << 1)) + deg)] *
                scaleu * (scaleu - hs_inv_idx_0);
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * (c + 1)] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      //  compute dv^4
      offset = us.size(0) * 9;
      v4 = 24.0 * std::pow(hs_inv_idx_1, 4.0);
      for (coder::SizeType b_i{0}; b_i < 35; b_i++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
        }
      }
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * 24] = v4 * V[iPnt];
      }
      c = 34;
      d = 15;
      for (deg = 5; deg <= degree; deg++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        scalev = hs_inv_idx_1;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * (c + 2)] =
                V[(iPnt + 5 * stride) + V.size(1) * ((c - (d << 1)) + deg)] *
                scalev * (scalev - hs_inv_idx_1);
          }
          scalev += hs_inv_idx_1;
          c++;
        }
        scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 2)] =
              V[(5 * stride + iPnt) + V.size(1) * ((c - (d << 1)) + deg)] *
              scalev * (scalev - hs_inv_idx_1);
        }
        c += 3;
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * c] =
                V[b_degree + V.size(1) * (((c - d) - deg) - 1)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        d = (d + deg) + 1;
      }
      //  compute du^2*dw^2
      offset += us.size(0);
      u2w2_tmp = hs_inv_idx_2 * hs_inv_idx_2;
      u2w2 = u2v2_tmp * u2w2_tmp;
      for (coder::SizeType b_i{0}; b_i < 35; b_i++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
        }
      }
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * 29] = u2w2 * V[iPnt];
      }
      c = 35;
      d = 15;
      for (deg = 5; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + (stride << 2)) +
                    V.size(1) * (((c - (d << 1)) - deg) - 1)] *
                  scalew * (scalew - hs_inv_idx_2);
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      //  compute dv^2*dw^2
      offset += us.size(0);
      v2w2 = 4.0 * b_u2v2_tmp * u2w2_tmp;
      for (coder::SizeType b_i{0}; b_i < 35; b_i++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
        }
      }
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * 31] = v2w2 * V[iPnt];
      }
      c = 35;
      d = 15;
      for (deg = 5; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + 5 * stride) +
                    V.size(1) * (((c - (d << 1)) - deg) - 1)] *
                  scalew * (scalew - hs_inv_idx_2);
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      //  compute dw^4
      offset += us.size(0);
      ww4 = 24.0 * std::pow(hs_inv_idx_2, 4.0);
      for (coder::SizeType b_i{0}; b_i < 35; b_i++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
        }
      }
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * 34] = ww4 * V[iPnt];
      }
      c = 35;
      d = 15;
      for (deg = 5; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + 6 * stride) +
                    V.size(1) * (((c - (d << 1)) - deg) - 1)] *
                  scalew * (scalew - hs_inv_idx_2);
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
    } break;
    default:
      m2cAssert(false, "Order must be 0, 1, 2, -1, -2, or -4.");
      break;
    }
  }
}

//  gen_vander_3d  Generate generalized/confluent Vandermonde matrix in 3D.
static void gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                          coder::SizeType npoints, coder::SizeType degree,
                          coder::SizeType order,
                          const ::coder::array<real_T, 1U> &weights,
                          ::coder::array<real_T, 2U> &V)
{
  coder::SizeType b_degree;
  coder::SizeType c;
  coder::SizeType cornerTriangle;
  coder::SizeType counterBottomRow;
  coder::SizeType d;
  coder::SizeType deg;
  coder::SizeType excess;
  coder::SizeType i;
  coder::SizeType i1;
  coder::SizeType maxLayers;
  coder::SizeType nTermsInLayer;
  coder::SizeType nTermsInPrevLayer;
  coder::SizeType nrblks;
  coder::SizeType stride;
  coder::SizeType u0;
  coder::SizeType x;
  coder::SizeType x_tmp_tmp;
  if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if ((order < -4) || (order == -3)) {
    m2cErrMsgIdAndTxt("wlslib:WrongOrder",
                      "Order %d must be 0, 1, 2, -1, -2, or -4", (int)order);
  }
  stride = us.size(0);
  nrblks = (order + 1) * (order + 2) * (order + 3) / 6;
  switch (order) {
  case -1:
    nrblks = 4;
    break;
  case -2:
    nrblks = 7;
    break;
  case -4:
    if (degree > 0) {
      nrblks = 13;
    } else {
      nrblks = 19;
    }
    break;
  }
  //  Allocate storage for V
  if (degree >= 0) {
    b_degree = (degree + 1) * (degree + 2) * (degree + 3) / 6;
  } else {
    b_degree = (1 - degree) * (1 - degree) * (1 - degree);
  }
  V.set_size(b_degree, us.size(0) * nrblks);
  //  compute 0th order generalized Vandermonde matrix
  if (weights.size(0) == 0) {
    if (degree != 0) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt] = 1.0;
        V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
        V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
        V[iPnt + V.size(1) * 3] = us[us.size(1) * iPnt + 2];
      }
    } else {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt] = 1.0;
      }
    }
  } else if (degree != 0) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = weights[iPnt];
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt] * weights[iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1] * weights[iPnt];
      V[iPnt + V.size(1) * 3] = us[us.size(1) * iPnt + 2] * weights[iPnt];
    }
  } else {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = weights[iPnt];
    }
  }
  c = 4;
  d = 3;
  u0 = order;
  if (order > 0) {
    u0 = 0;
  }
  x_tmp_tmp = -degree;
  x = -degree;
  if (-degree > 0) {
    x = 1;
  } else if (-degree < 0) {
    x = -1;
  }
  x *= u0;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (x < 0) {
    x = 0;
  }
  i = b_degree - x;
  for (deg = 2; deg <= i; deg++) {
    //  Within each level, use convention of Pascal triangle with x^deg at peak
    for (coder::SizeType j{0}; j < deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * us[us.size(1) * iPnt];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt + V.size(1) * c] =
          V[iPnt + V.size(1) * ((c - d) - 1)] * us[us.size(1) * iPnt + 1];
    }
    c++;
    for (coder::SizeType j{0}; j < d; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] = V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
                                  us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    d = (d + deg) + 1;
  }
  //  Compute the tri-degree terms if degree<0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3 + u0;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      coder::SizeType gap;
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 1;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType k{0}; k < deg; k++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] = V[iPnt + V.size(1) * (c - nTermsInLayer)] *
                                    us[us.size(1) * iPnt + 1];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      x = ((degree + degree) + p) - 1;
      if (x < 0) {
        x = 0;
      }
      excess += x;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      gap = (nTermsInPrevLayer + counterBottomRow) - 1;
      i1 = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= i1; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - gap)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  m2cAssert(order <= 2, "");
  if (order != 0) {
    //      compute higher order confluent Vandermonde matrix blocks
    switch (order) {
    case 1: {
      coder::SizeType balance;
      coder::SizeType offset;
      //  Compute order-1 CVM row blocks from order-0 GVM.
      m2cAssert(degree != 0, "");
      // compute derivatives with respect to u
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[stride + iPnt] = 0.0;
        V[(stride + iPnt) + V.size(1)] = V[iPnt];
        V[(stride + iPnt) + V.size(1) * 2] = 0.0;
        V[(stride + iPnt) + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 3;
      u0 = order + 1;
      if (u0 > 0) {
        u0 = 0;
      }
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        real_T scaleu;
        scaleu = deg;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * static_cast<real_T>(deg);
        }
        c++;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu--;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scaleu;
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] = 0.0;
        }
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c + 1)] =
                V[(stride + iPnt) + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      // tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 1;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * c] =
                  V[(stride + iPnt) + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt + 1];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = (nTermsInPrevLayer + counterBottomRow) - 1;
          i1 = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= i1; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * c] =
                  V[(stride + iPnt) + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to v
      offset = us.size(0) + us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        b_degree = offset + iPnt;
        V[b_degree] = 0.0;
        V[b_degree + V.size(1)] = 0.0;
        V[b_degree + V.size(1) * 2] = V[iPnt];
        V[b_degree + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 4;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        real_T scalev;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        scalev = 1.0;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scalev;
          }
          scalev++;
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * static_cast<real_T>(deg);
        }
        c++;
        for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * c] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        d = (d + deg) + 1;
      }
      // compute the tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        x = order + 1;
        if (x > 0) {
          x = 0;
        }
        maxLayers = -degree * 3 + x;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d - 2;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer + 1;
          nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
          balance = nTermsInPrevLayer + counterBottomRow;
          i1 = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= i1; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to w
      offset += us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        V[x] = 0.0;
        V[x + V.size(1)] = 0.0;
        V[x + V.size(1) * 2] = 0.0;
        V[x + V.size(1) * 3] = V[iPnt];
      }
      c = 4;
      d = 3;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
                  (static_cast<real_T>(k) + 1.0);
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      // compute tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        u0 = order + 1;
        if (u0 > 0) {
          u0 = 0;
        }
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType k{0}; k < deg; k++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          b_degree = p + degree;
          x = ((b_degree << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = nTermsInPrevLayer + counterBottomRow;
          for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
            coder::SizeType partition;
            x = (b_degree - k) - 1;
            if (x < 0) {
              x = -x;
            }
            partition = -degree - x;
            for (coder::SizeType j{0}; j <= partition; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(iPnt + offset) + V.size(1) * c] =
                    V[iPnt + V.size(1) * (c - balance)] *
                    static_cast<real_T>(k + 1);
              }
              c++;
            }
          }
        }
      }
    } break;
    case 2: {
      real_T scaleu;
      real_T scalev;
      coder::SizeType balance;
      coder::SizeType offset;
      coder::SizeType partition;
      //  Compute order-1 CVM row blocks from order-0 GVM.
      m2cAssert(degree != 0, "");
      // compute derivatives with respect to u
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[stride + iPnt] = 0.0;
        V[(stride + iPnt) + V.size(1)] = V[iPnt];
        V[(stride + iPnt) + V.size(1) * 2] = 0.0;
        V[(stride + iPnt) + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 3;
      u0 = order + 1;
      if (u0 > 0) {
        u0 = 0;
      }
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        scaleu = deg;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * static_cast<real_T>(deg);
        }
        c++;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu--;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scaleu;
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] = 0.0;
        }
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c + 1)] =
                V[(stride + iPnt) + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      // tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 1;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * c] =
                  V[(stride + iPnt) + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt + 1];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = (nTermsInPrevLayer + counterBottomRow) - 1;
          i1 = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= i1; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * c] =
                  V[(stride + iPnt) + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to v
      offset = us.size(0) + us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        b_degree = offset + iPnt;
        V[b_degree] = 0.0;
        V[b_degree + V.size(1)] = 0.0;
        V[b_degree + V.size(1) * 2] = V[iPnt];
        V[b_degree + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 4;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        scalev = 1.0;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scalev;
          }
          scalev++;
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * static_cast<real_T>(deg);
        }
        c++;
        for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * c] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        d = (d + deg) + 1;
      }
      // compute the tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        x = order + 1;
        if (x > 0) {
          x = 0;
        }
        maxLayers = -degree * 3 + x;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d - 2;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer + 1;
          nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
          balance = nTermsInPrevLayer + counterBottomRow;
          i1 = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= i1; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to w
      offset += us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        V[x] = 0.0;
        V[x + V.size(1)] = 0.0;
        V[x + V.size(1) * 2] = 0.0;
        V[x + V.size(1) * 3] = V[iPnt];
      }
      c = 4;
      d = 3;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
                  (static_cast<real_T>(k) + 1.0);
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      // compute tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        u0 = order + 1;
        if (u0 > 0) {
          u0 = 0;
        }
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType k{0}; k < deg; k++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          b_degree = p + degree;
          x = ((b_degree << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = nTermsInPrevLayer + counterBottomRow;
          for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
            x = (b_degree - k) - 1;
            if (x < 0) {
              x = -x;
            }
            partition = -degree - x;
            for (coder::SizeType j{0}; j <= partition; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(iPnt + offset) + V.size(1) * c] =
                    V[iPnt + V.size(1) * (c - balance)] *
                    static_cast<real_T>(k + 1);
              }
              c++;
            }
          }
        }
      }
      //  compute du^2
      offset = us.size(0) << 2;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        V[x] = 0.0;
        V[x + V.size(1)] = 0.0;
        V[x + V.size(1) * 2] = 0.0;
        V[x + V.size(1) * 3] = 0.0;
        V[x + V.size(1) * 4] = 2.0 * V[iPnt];
        for (i = 0; i < 5; i++) {
          V[x + V.size(1) * (i + 5)] = 0.0;
        }
      }
      c = 10;
      d = 6;
      u0 = order + 2;
      if (u0 > 0) {
        u0 = 0;
      }
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (x < 0) {
        x = 0;
      }
      i1 = i - x;
      for (deg = 3; deg <= i1; deg++) {
        scaleu = deg;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + stride) + V.size(1) * (c - d)] *
              static_cast<real_T>(deg);
        }
        c++;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu--;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * (c + 1)] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      // compute tri degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i1 = 1 - degree;
        for (coder::SizeType p{i1}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 1;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt + 1];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = (nTermsInPrevLayer + counterBottomRow) - 1;
          x = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= x; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      if (order > 0) {
        //      compute du*dv
        offset += us.size(0);
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = offset + iPnt;
          for (i1 = 0; i1 < 5; i1++) {
            V[x + V.size(1) * i1] = 0.0;
          }
          V[x + V.size(1) * 5] = V[iPnt];
          V[x + V.size(1) * 6] = 0.0;
          V[x + V.size(1) * 7] = 0.0;
          V[x + V.size(1) * 8] = 0.0;
          V[x + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 7;
        for (deg = 3; deg <= i; deg++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = 1.0;
          for (coder::SizeType j{0}; j <= deg - 2; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + stride) + V.size(1) * (c - d)] * scalev;
            }
            scalev++;
            c++;
          }
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] *
                static_cast<real_T>(deg);
          }
          c++;
          for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * ((c - d) - deg)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i1 = 1 - degree;
          for (coder::SizeType p{i1}; p <= maxLayers; p++) {
            //  implicitly calculating number of elements in corner Pascal
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((stride << 1) + iPnt) +
                      V.size(1) * (c - nTermsInLayer)] *
                    static_cast<real_T>(-degree - kdegree);
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x = (((p + degree) << 1) - p) - 1;
            if (x < 0) {
              x = 0;
            }
            excess += x;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            x = nTermsInLayer - counterBottomRow;
            for (coder::SizeType j{0}; j <= x; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                b_degree = offset + iPnt;
                V[b_degree + V.size(1) * c] =
                    V[b_degree + V.size(1) * (c - balance)] *
                    us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      }
      //  compute dv^2
      offset += us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        for (i1 = 0; i1 < 6; i1++) {
          V[x + V.size(1) * i1] = 0.0;
        }
        V[x + V.size(1) * 6] = 2.0 * V[iPnt];
        V[x + V.size(1) * 7] = 0.0;
        V[x + V.size(1) * 8] = 0.0;
        V[x + V.size(1) * 9] = 0.0;
      }
      c = 10;
      d = 7;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i1 = b_degree - x;
      for (deg = 3; deg <= i1; deg++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        scalev = 1.0;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + (stride << 1)) + V.size(1) * (c - d)] * scalev;
          }
          scalev++;
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((stride << 1) + iPnt) + V.size(1) * (c - d)] *
              static_cast<real_T>(deg);
        }
        c++;
        for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * c] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        d = (d + deg) + 1;
      }
      // compute the tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        x = order + 2;
        if (x > 0) {
          x = 0;
        }
        maxLayers = -degree * 3 + x;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d - 2;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i1 = 1 - degree;
        for (coder::SizeType p{i1}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer + 1;
          nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
          balance = nTermsInPrevLayer + counterBottomRow;
          x = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= x; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      if (order > 0) {
        //      compute du*dw
        offset = (offset + us.size(0)) - 1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = (offset + iPnt) + 1;
          for (i1 = 0; i1 < 7; i1++) {
            V[x + V.size(1) * i1] = 0.0;
          }
          V[x + V.size(1) * 7] = V[iPnt];
          V[x + V.size(1) * 8] = 0.0;
          V[x + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        for (deg = 3; deg <= i; deg++) {
          for (coder::SizeType j{0}; j <= deg; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
            }
            c++;
          }
          for (coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] =
                    V[(iPnt + stride) + V.size(1) * (((c - d) - deg) - 1)] *
                    (static_cast<real_T>(k) + 1.0);
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i1 = 1 - degree;
          for (coder::SizeType p{i1}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (coder::SizeType k{0}; k < deg; k++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            b_degree = p + degree;
            x = ((b_degree << 1) - p) - 1;
            if (x < 0) {
              x = 0;
            }
            excess += x;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
              x = (b_degree - k) - 1;
              if (x < 0) {
                x = -x;
              }
              partition = -degree - x;
              for (coder::SizeType j{0}; j <= partition; j++) {
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[((iPnt + offset) + V.size(1) * c) + 1] =
                      V[(iPnt + stride) + V.size(1) * (c - balance)] *
                      static_cast<real_T>(k + 1);
                }
                c++;
              }
            }
          }
        }
        //      compute dv*dw
        offset = (offset + us.size(0)) + 1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = offset + iPnt;
          for (i1 = 0; i1 < 8; i1++) {
            V[x + V.size(1) * i1] = 0.0;
          }
          V[x + V.size(1) * 8] = V[iPnt];
          V[x + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        for (deg = 3; deg <= i; deg++) {
          for (coder::SizeType j{0}; j <= deg; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(iPnt + (stride << 1)) +
                      V.size(1) * (((c - d) - deg) - 1)] *
                    (static_cast<real_T>(k) + 1.0);
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (coder::SizeType k{0}; k < deg; k++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            b_degree = p + degree;
            x = ((b_degree << 1) - p) - 1;
            if (x < 0) {
              x = 0;
            }
            excess += x;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
              x = (b_degree - k) - 1;
              if (x < 0) {
                x = -x;
              }
              partition = -degree - x;
              for (coder::SizeType j{0}; j <= partition; j++) {
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[(iPnt + (stride << 1)) + V.size(1) * (c - balance)] *
                      static_cast<real_T>(k + 1);
                }
                c++;
              }
            }
          }
        }
      }
      //  compute dw^2
      offset += us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        for (i = 0; i < 9; i++) {
          V[x + V.size(1) * i] = 0.0;
        }
        V[x + V.size(1) * 9] = 2.0 * V[iPnt];
      }
      c = 10;
      d = 6;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 3; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + 3 * stride) + V.size(1) * (((c - d) - deg) - 1)] *
                  (static_cast<real_T>(k) + 1.0);
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      // compute tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        u0 = order + 2;
        if (u0 > 0) {
          u0 = 0;
        }
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType k{0}; k < deg; k++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          b_degree = p + degree;
          x = ((b_degree << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = nTermsInPrevLayer + counterBottomRow;
          for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
            x = (b_degree - k) - 1;
            if (x < 0) {
              x = -x;
            }
            partition = -degree - x;
            for (coder::SizeType j{0}; j <= partition; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(iPnt + offset) + V.size(1) * c] =
                    V[(iPnt + 3 * stride) + V.size(1) * (c - balance)] *
                    static_cast<real_T>(k + 1);
              }
              c++;
            }
          }
        }
      }
    } break;
    case -1: {
      coder::SizeType balance;
      coder::SizeType offset;
      //  Compute order-1 CVM row blocks from order-0 GVM.
      m2cAssert(degree != 0, "");
      // compute derivatives with respect to u
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[stride + iPnt] = 0.0;
        V[(stride + iPnt) + V.size(1)] = V[iPnt];
        V[(stride + iPnt) + V.size(1) * 2] = 0.0;
        V[(stride + iPnt) + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 3;
      u0 = order + 1;
      if (u0 > 0) {
        u0 = 0;
      }
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        real_T scaleu;
        scaleu = deg;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * static_cast<real_T>(deg);
        }
        c++;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu--;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scaleu;
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] = 0.0;
        }
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c + 1)] =
                V[(stride + iPnt) + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      // tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 1;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * c] =
                  V[(stride + iPnt) + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt + 1];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = (nTermsInPrevLayer + counterBottomRow) - 1;
          i1 = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= i1; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * c] =
                  V[(stride + iPnt) + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to v
      offset = us.size(0) + us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        b_degree = offset + iPnt;
        V[b_degree] = 0.0;
        V[b_degree + V.size(1)] = 0.0;
        V[b_degree + V.size(1) * 2] = V[iPnt];
        V[b_degree + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 4;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        real_T scalev;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        scalev = 1.0;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scalev;
          }
          scalev++;
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * static_cast<real_T>(deg);
        }
        c++;
        for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * c] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        d = (d + deg) + 1;
      }
      // compute the tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        x = order + 1;
        if (x > 0) {
          x = 0;
        }
        maxLayers = -degree * 3 + x;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d - 2;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer + 1;
          nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
          balance = nTermsInPrevLayer + counterBottomRow;
          i1 = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= i1; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to w
      offset += us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        V[x] = 0.0;
        V[x + V.size(1)] = 0.0;
        V[x + V.size(1) * 2] = 0.0;
        V[x + V.size(1) * 3] = V[iPnt];
      }
      c = 4;
      d = 3;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
                  (static_cast<real_T>(k) + 1.0);
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      // compute tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        u0 = order + 1;
        if (u0 > 0) {
          u0 = 0;
        }
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType k{0}; k < deg; k++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          b_degree = p + degree;
          x = ((b_degree << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = nTermsInPrevLayer + counterBottomRow;
          for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
            coder::SizeType partition;
            x = (b_degree - k) - 1;
            if (x < 0) {
              x = -x;
            }
            partition = -degree - x;
            for (coder::SizeType j{0}; j <= partition; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(iPnt + offset) + V.size(1) * c] =
                    V[iPnt + V.size(1) * (c - balance)] *
                    static_cast<real_T>(k + 1);
              }
              c++;
            }
          }
        }
      }
    } break;
    case -2: {
      real_T scaleu;
      real_T scalev;
      coder::SizeType balance;
      coder::SizeType offset;
      coder::SizeType partition;
      //  Compute order-1 CVM row blocks from order-0 GVM.
      m2cAssert(degree != 0, "");
      // compute derivatives with respect to u
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[stride + iPnt] = 0.0;
        V[(stride + iPnt) + V.size(1)] = V[iPnt];
        V[(stride + iPnt) + V.size(1) * 2] = 0.0;
        V[(stride + iPnt) + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 3;
      u0 = order + 1;
      if (u0 > 0) {
        u0 = 0;
      }
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        scaleu = deg;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * static_cast<real_T>(deg);
        }
        c++;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu--;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scaleu;
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] = 0.0;
        }
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c + 1)] =
                V[(stride + iPnt) + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      // tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 1;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * c] =
                  V[(stride + iPnt) + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt + 1];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = (nTermsInPrevLayer + counterBottomRow) - 1;
          i1 = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= i1; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * c] =
                  V[(stride + iPnt) + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to v
      offset = us.size(0) + us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        b_degree = offset + iPnt;
        V[b_degree] = 0.0;
        V[b_degree + V.size(1)] = 0.0;
        V[b_degree + V.size(1) * 2] = V[iPnt];
        V[b_degree + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 4;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        scalev = 1.0;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scalev;
          }
          scalev++;
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * static_cast<real_T>(deg);
        }
        c++;
        for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * c] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        d = (d + deg) + 1;
      }
      // compute the tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        x = order + 1;
        if (x > 0) {
          x = 0;
        }
        maxLayers = -degree * 3 + x;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d - 2;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer + 1;
          nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
          balance = nTermsInPrevLayer + counterBottomRow;
          i1 = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= i1; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to w
      offset += us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        V[x] = 0.0;
        V[x + V.size(1)] = 0.0;
        V[x + V.size(1) * 2] = 0.0;
        V[x + V.size(1) * 3] = V[iPnt];
      }
      c = 4;
      d = 3;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
                  (static_cast<real_T>(k) + 1.0);
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      // compute tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        u0 = order + 1;
        if (u0 > 0) {
          u0 = 0;
        }
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType k{0}; k < deg; k++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          b_degree = p + degree;
          x = ((b_degree << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = nTermsInPrevLayer + counterBottomRow;
          for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
            x = (b_degree - k) - 1;
            if (x < 0) {
              x = -x;
            }
            partition = -degree - x;
            for (coder::SizeType j{0}; j <= partition; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(iPnt + offset) + V.size(1) * c] =
                    V[iPnt + V.size(1) * (c - balance)] *
                    static_cast<real_T>(k + 1);
              }
              c++;
            }
          }
        }
      }
      //  compute du^2
      offset = us.size(0) << 2;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        V[x] = 0.0;
        V[x + V.size(1)] = 0.0;
        V[x + V.size(1) * 2] = 0.0;
        V[x + V.size(1) * 3] = 0.0;
        V[x + V.size(1) * 4] = 2.0 * V[iPnt];
        for (i = 0; i < 5; i++) {
          V[x + V.size(1) * (i + 5)] = 0.0;
        }
      }
      c = 10;
      d = 6;
      u0 = order + 2;
      if (u0 > 0) {
        u0 = 0;
      }
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (x < 0) {
        x = 0;
      }
      i1 = i - x;
      for (deg = 3; deg <= i1; deg++) {
        scaleu = deg;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + stride) + V.size(1) * (c - d)] *
              static_cast<real_T>(deg);
        }
        c++;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu--;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * (c + 1)] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      // compute tri degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i1 = 1 - degree;
        for (coder::SizeType p{i1}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 1;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt + 1];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = (nTermsInPrevLayer + counterBottomRow) - 1;
          x = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= x; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      if (order > 0) {
        //      compute du*dv
        offset += us.size(0);
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = offset + iPnt;
          for (i1 = 0; i1 < 5; i1++) {
            V[x + V.size(1) * i1] = 0.0;
          }
          V[x + V.size(1) * 5] = V[iPnt];
          V[x + V.size(1) * 6] = 0.0;
          V[x + V.size(1) * 7] = 0.0;
          V[x + V.size(1) * 8] = 0.0;
          V[x + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 7;
        for (deg = 3; deg <= i; deg++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = 1.0;
          for (coder::SizeType j{0}; j <= deg - 2; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + stride) + V.size(1) * (c - d)] * scalev;
            }
            scalev++;
            c++;
          }
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] *
                static_cast<real_T>(deg);
          }
          c++;
          for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * ((c - d) - deg)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i1 = 1 - degree;
          for (coder::SizeType p{i1}; p <= maxLayers; p++) {
            //  implicitly calculating number of elements in corner Pascal
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((stride << 1) + iPnt) +
                      V.size(1) * (c - nTermsInLayer)] *
                    static_cast<real_T>(-degree - kdegree);
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x = (((p + degree) << 1) - p) - 1;
            if (x < 0) {
              x = 0;
            }
            excess += x;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            x = nTermsInLayer - counterBottomRow;
            for (coder::SizeType j{0}; j <= x; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                b_degree = offset + iPnt;
                V[b_degree + V.size(1) * c] =
                    V[b_degree + V.size(1) * (c - balance)] *
                    us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      }
      //  compute dv^2
      offset += us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        for (i1 = 0; i1 < 6; i1++) {
          V[x + V.size(1) * i1] = 0.0;
        }
        V[x + V.size(1) * 6] = 2.0 * V[iPnt];
        V[x + V.size(1) * 7] = 0.0;
        V[x + V.size(1) * 8] = 0.0;
        V[x + V.size(1) * 9] = 0.0;
      }
      c = 10;
      d = 7;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i1 = b_degree - x;
      for (deg = 3; deg <= i1; deg++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        scalev = 1.0;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + (stride << 1)) + V.size(1) * (c - d)] * scalev;
          }
          scalev++;
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((stride << 1) + iPnt) + V.size(1) * (c - d)] *
              static_cast<real_T>(deg);
        }
        c++;
        for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * c] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        d = (d + deg) + 1;
      }
      // compute the tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        x = order + 2;
        if (x > 0) {
          x = 0;
        }
        maxLayers = -degree * 3 + x;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d - 2;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i1 = 1 - degree;
        for (coder::SizeType p{i1}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer + 1;
          nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
          balance = nTermsInPrevLayer + counterBottomRow;
          x = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= x; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      if (order > 0) {
        //      compute du*dw
        offset = (offset + us.size(0)) - 1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = (offset + iPnt) + 1;
          for (i1 = 0; i1 < 7; i1++) {
            V[x + V.size(1) * i1] = 0.0;
          }
          V[x + V.size(1) * 7] = V[iPnt];
          V[x + V.size(1) * 8] = 0.0;
          V[x + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        for (deg = 3; deg <= i; deg++) {
          for (coder::SizeType j{0}; j <= deg; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
            }
            c++;
          }
          for (coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] =
                    V[(iPnt + stride) + V.size(1) * (((c - d) - deg) - 1)] *
                    (static_cast<real_T>(k) + 1.0);
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i1 = 1 - degree;
          for (coder::SizeType p{i1}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (coder::SizeType k{0}; k < deg; k++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            b_degree = p + degree;
            x = ((b_degree << 1) - p) - 1;
            if (x < 0) {
              x = 0;
            }
            excess += x;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
              x = (b_degree - k) - 1;
              if (x < 0) {
                x = -x;
              }
              partition = -degree - x;
              for (coder::SizeType j{0}; j <= partition; j++) {
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[((iPnt + offset) + V.size(1) * c) + 1] =
                      V[(iPnt + stride) + V.size(1) * (c - balance)] *
                      static_cast<real_T>(k + 1);
                }
                c++;
              }
            }
          }
        }
        //      compute dv*dw
        offset = (offset + us.size(0)) + 1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = offset + iPnt;
          for (i1 = 0; i1 < 8; i1++) {
            V[x + V.size(1) * i1] = 0.0;
          }
          V[x + V.size(1) * 8] = V[iPnt];
          V[x + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        for (deg = 3; deg <= i; deg++) {
          for (coder::SizeType j{0}; j <= deg; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(iPnt + (stride << 1)) +
                      V.size(1) * (((c - d) - deg) - 1)] *
                    (static_cast<real_T>(k) + 1.0);
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (coder::SizeType k{0}; k < deg; k++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            b_degree = p + degree;
            x = ((b_degree << 1) - p) - 1;
            if (x < 0) {
              x = 0;
            }
            excess += x;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
              x = (b_degree - k) - 1;
              if (x < 0) {
                x = -x;
              }
              partition = -degree - x;
              for (coder::SizeType j{0}; j <= partition; j++) {
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[(iPnt + (stride << 1)) + V.size(1) * (c - balance)] *
                      static_cast<real_T>(k + 1);
                }
                c++;
              }
            }
          }
        }
      }
      //  compute dw^2
      offset += us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        for (i = 0; i < 9; i++) {
          V[x + V.size(1) * i] = 0.0;
        }
        V[x + V.size(1) * 9] = 2.0 * V[iPnt];
      }
      c = 10;
      d = 6;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 3; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + 3 * stride) + V.size(1) * (((c - d) - deg) - 1)] *
                  (static_cast<real_T>(k) + 1.0);
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      // compute tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        u0 = order + 2;
        if (u0 > 0) {
          u0 = 0;
        }
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType k{0}; k < deg; k++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          b_degree = p + degree;
          x = ((b_degree << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = nTermsInPrevLayer + counterBottomRow;
          for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
            x = (b_degree - k) - 1;
            if (x < 0) {
              x = -x;
            }
            partition = -degree - x;
            for (coder::SizeType j{0}; j <= partition; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(iPnt + offset) + V.size(1) * c] =
                    V[(iPnt + 3 * stride) + V.size(1) * (c - balance)] *
                    static_cast<real_T>(k + 1);
              }
              c++;
            }
          }
        }
      }
    } break;
    case -4: {
      real_T scaleu;
      real_T scalev;
      real_T uu4_tmp;
      coder::SizeType balance;
      coder::SizeType offset;
      coder::SizeType partition;
      m2cAssert(degree > 0, "Biharnomic is only supported for "
                            "Pascal-tetrahedral monomials in 3D.");
      //  Compute order-1 CVM row blocks from order-0 GVM.
      m2cAssert(degree != 0, "");
      // compute derivatives with respect to u
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[stride + iPnt] = 0.0;
        V[(stride + iPnt) + V.size(1)] = V[iPnt];
        V[(stride + iPnt) + V.size(1) * 2] = 0.0;
        V[(stride + iPnt) + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 3;
      u0 = order + 1;
      if (u0 > 0) {
        u0 = 0;
      }
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        scaleu = deg;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * static_cast<real_T>(deg);
        }
        c++;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu--;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scaleu;
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * c] = 0.0;
        }
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(stride + iPnt) + V.size(1) * (c + 1)] =
                V[(stride + iPnt) + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      // tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 1;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * c] =
                  V[(stride + iPnt) + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt + 1];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = (nTermsInPrevLayer + counterBottomRow) - 1;
          i1 = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= i1; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(stride + iPnt) + V.size(1) * c] =
                  V[(stride + iPnt) + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to v
      offset = us.size(0) + us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        b_degree = offset + iPnt;
        V[b_degree] = 0.0;
        V[b_degree + V.size(1)] = 0.0;
        V[b_degree + V.size(1) * 2] = V[iPnt];
        V[b_degree + V.size(1) * 3] = 0.0;
      }
      c = 4;
      d = 4;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      u0 = order + 1;
      if (u0 > 0) {
        u0 = 0;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        scalev = 1.0;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - d)] * scalev;
          }
          scalev++;
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - d)] * static_cast<real_T>(deg);
        }
        c++;
        for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * c] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        d = (d + deg) + 1;
      }
      // compute the tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        u0 = order + 1;
        if (u0 > 0) {
          u0 = 0;
        }
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d - 2;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer + 1;
          nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
          balance = nTermsInPrevLayer + counterBottomRow;
          i1 = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= i1; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      // compute derivatives with respect to w
      offset += us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        V[x] = 0.0;
        V[x + V.size(1)] = 0.0;
        V[x + V.size(1) * 2] = 0.0;
        V[x + V.size(1) * 3] = V[iPnt];
      }
      c = 4;
      d = 3;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      u0 = order + 1;
      if (u0 > 0) {
        u0 = 0;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 2; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
                  (static_cast<real_T>(k) + 1.0);
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      // compute tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        u0 = order + 1;
        if (u0 > 0) {
          u0 = 0;
        }
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType k{0}; k < deg; k++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          b_degree = p + degree;
          x = ((b_degree << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = nTermsInPrevLayer + counterBottomRow;
          for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
            x = (b_degree - k) - 1;
            if (x < 0) {
              x = -x;
            }
            partition = -degree - x;
            for (coder::SizeType j{0}; j <= partition; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(iPnt + offset) + V.size(1) * c] =
                    V[iPnt + V.size(1) * (c - balance)] *
                    static_cast<real_T>(k + 1);
              }
              c++;
            }
          }
        }
      }
      //  compute du^2
      offset = us.size(0) << 2;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        V[x] = 0.0;
        V[x + V.size(1)] = 0.0;
        V[x + V.size(1) * 2] = 0.0;
        V[x + V.size(1) * 3] = 0.0;
        V[x + V.size(1) * 4] = 2.0 * V[iPnt];
        for (i = 0; i < 5; i++) {
          V[x + V.size(1) * (i + 5)] = 0.0;
        }
      }
      c = 10;
      d = 6;
      u0 = order + 2;
      if (u0 > 0) {
        u0 = 0;
      }
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      x *= u0;
      if (x < 0) {
        x = 0;
      }
      i1 = i - x;
      for (deg = 3; deg <= i1; deg++) {
        scaleu = deg;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + stride) + V.size(1) * (c - d)] *
              static_cast<real_T>(deg);
        }
        c++;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu--;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * (c + 1)] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      // compute tri degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i1 = 1 - degree;
        for (coder::SizeType p{i1}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 1;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt + 1];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = (nTermsInPrevLayer + counterBottomRow) - 1;
          x = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= x; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      if (order > 0) {
        //      compute du*dv
        offset += us.size(0);
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = offset + iPnt;
          for (i1 = 0; i1 < 5; i1++) {
            V[x + V.size(1) * i1] = 0.0;
          }
          V[x + V.size(1) * 5] = V[iPnt];
          V[x + V.size(1) * 6] = 0.0;
          V[x + V.size(1) * 7] = 0.0;
          V[x + V.size(1) * 8] = 0.0;
          V[x + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 7;
        for (deg = 3; deg <= i; deg++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          scalev = 1.0;
          for (coder::SizeType j{0}; j <= deg - 2; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + stride) + V.size(1) * (c - d)] * scalev;
            }
            scalev++;
            c++;
          }
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + stride) + V.size(1) * (c - d)] *
                static_cast<real_T>(deg);
          }
          c++;
          for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * ((c - d) - deg)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
          d = (d + deg) + 1;
        }
        // compute the tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d - 2;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i1 = 1 - degree;
          for (coder::SizeType p{i1}; p <= maxLayers; p++) {
            //  implicitly calculating number of elements in corner Pascal
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[((stride << 1) + iPnt) +
                      V.size(1) * (c - nTermsInLayer)] *
                    static_cast<real_T>(-degree - kdegree);
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            x = (((p + degree) << 1) - p) - 1;
            if (x < 0) {
              x = 0;
            }
            excess += x;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer + 1;
            nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
            balance = nTermsInPrevLayer + counterBottomRow;
            x = nTermsInLayer - counterBottomRow;
            for (coder::SizeType j{0}; j <= x; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                b_degree = offset + iPnt;
                V[b_degree + V.size(1) * c] =
                    V[b_degree + V.size(1) * (c - balance)] *
                    us[us.size(1) * iPnt + 2];
              }
              c++;
            }
          }
        }
      }
      //  compute dv^2
      offset += us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        for (i1 = 0; i1 < 6; i1++) {
          V[x + V.size(1) * i1] = 0.0;
        }
        V[x + V.size(1) * 6] = 2.0 * V[iPnt];
        V[x + V.size(1) * 7] = 0.0;
        V[x + V.size(1) * 8] = 0.0;
        V[x + V.size(1) * 9] = 0.0;
      }
      c = 10;
      d = 7;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      u0 = order + 2;
      if (u0 > 0) {
        u0 = 0;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i1 = b_degree - x;
      for (deg = 3; deg <= i1; deg++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        scalev = 1.0;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + (stride << 1)) + V.size(1) * (c - d)] * scalev;
          }
          scalev++;
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[((stride << 1) + iPnt) + V.size(1) * (c - d)] *
              static_cast<real_T>(deg);
        }
        c++;
        for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * c] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        d = (d + deg) + 1;
      }
      // compute the tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        u0 = order + 2;
        if (u0 > 0) {
          u0 = 0;
        }
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d - 2;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i1 = 1 - degree;
        for (coder::SizeType p{i1}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - nTermsInLayer)] *
                  us[us.size(1) * iPnt];
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          x = (((p + degree) << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer + 1;
          nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
          balance = nTermsInPrevLayer + counterBottomRow;
          x = nTermsInLayer - counterBottomRow;
          for (coder::SizeType j{0}; j <= x; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              b_degree = offset + iPnt;
              V[b_degree + V.size(1) * c] =
                  V[b_degree + V.size(1) * (c - balance)] *
                  us[us.size(1) * iPnt + 2];
            }
            c++;
          }
        }
      }
      if (order > 0) {
        //      compute du*dw
        offset = (offset + us.size(0)) - 1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = (offset + iPnt) + 1;
          for (i1 = 0; i1 < 7; i1++) {
            V[x + V.size(1) * i1] = 0.0;
          }
          V[x + V.size(1) * 7] = V[iPnt];
          V[x + V.size(1) * 8] = 0.0;
          V[x + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        for (deg = 3; deg <= i; deg++) {
          for (coder::SizeType j{0}; j <= deg; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
            }
            c++;
          }
          for (coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] =
                    V[(iPnt + stride) + V.size(1) * (((c - d) - deg) - 1)] *
                    (static_cast<real_T>(k) + 1.0);
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i1 = 1 - degree;
          for (coder::SizeType p{i1}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (coder::SizeType k{0}; k < deg; k++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[((offset + iPnt) + V.size(1) * c) + 1] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            b_degree = p + degree;
            x = ((b_degree << 1) - p) - 1;
            if (x < 0) {
              x = 0;
            }
            excess += x;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
              x = (b_degree - k) - 1;
              if (x < 0) {
                x = -x;
              }
              partition = -degree - x;
              for (coder::SizeType j{0}; j <= partition; j++) {
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[((iPnt + offset) + V.size(1) * c) + 1] =
                      V[(iPnt + stride) + V.size(1) * (c - balance)] *
                      static_cast<real_T>(k + 1);
                }
                c++;
              }
            }
          }
        }
        //      compute dv*dw
        offset = (offset + us.size(0)) + 1;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          x = offset + iPnt;
          for (i1 = 0; i1 < 8; i1++) {
            V[x + V.size(1) * i1] = 0.0;
          }
          V[x + V.size(1) * 8] = V[iPnt];
          V[x + V.size(1) * 9] = 0.0;
        }
        c = 10;
        d = 6;
        for (deg = 3; deg <= i; deg++) {
          for (coder::SizeType j{0}; j <= deg; j++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
          }
          for (coder::SizeType k{0}; k < deg; k++) {
            i1 = (deg - k) - 1;
            for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] =
                    V[(iPnt + (stride << 1)) +
                      V.size(1) * (((c - d) - deg) - 1)] *
                    (static_cast<real_T>(k) + 1.0);
              }
              c++;
            }
          }
          d = (d + deg) + 1;
        }
        // compute tri-degree terms if degree < 0
        if (degree < 0) {
          deg = -degree;
          maxLayers = -degree * 3 + 1;
          // max number of layers needed in the Pascal tetrahedron
          cornerTriangle = 0;
          // number of elements subtracted in each corner Pascal triangle
          nTermsInLayer = d;
          // initializing number of elements in layer
          excess = 0;
          // excess based on overlapping of growing Pascal triangles
          i = 1 - degree;
          for (coder::SizeType p{i}; p <= maxLayers; p++) {
            //  Within each level, x^deg is at the peak of Pascal triangle
            cornerTriangle = (cornerTriangle + p) + degree;
            counterBottomRow = 0;
            // counter for the bottom row to be subtracted later
            for (coder::SizeType k{0}; k < deg; k++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(offset + iPnt) + V.size(1) * c] = 0.0;
              }
              c++;
              counterBottomRow++;
            }
            deg--;
            b_degree = p + degree;
            x = ((b_degree << 1) - p) - 1;
            if (x < 0) {
              x = 0;
            }
            excess += x;
            d = (d + p) + 1;
            // number of terms in Pascal tetrahedron
            nTermsInPrevLayer = nTermsInLayer;
            nTermsInLayer = d + 3 * (excess - cornerTriangle);
            balance = nTermsInPrevLayer + counterBottomRow;
            for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
              x = (b_degree - k) - 1;
              if (x < 0) {
                x = -x;
              }
              partition = -degree - x;
              for (coder::SizeType j{0}; j <= partition; j++) {
                for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                  V[(iPnt + offset) + V.size(1) * c] =
                      V[(iPnt + (stride << 1)) + V.size(1) * (c - balance)] *
                      static_cast<real_T>(k + 1);
                }
                c++;
              }
            }
          }
        }
      }
      //  compute dw^2
      offset += us.size(0);
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        x = offset + iPnt;
        for (i = 0; i < 9; i++) {
          V[x + V.size(1) * i] = 0.0;
        }
        V[x + V.size(1) * 9] = 2.0 * V[iPnt];
      }
      c = 10;
      d = 6;
      x = -degree;
      if (-degree > 0) {
        x = 1;
      } else if (-degree < 0) {
        x = -1;
      }
      u0 = order + 2;
      if (u0 > 0) {
        u0 = 0;
      }
      x *= u0;
      if (degree < 0) {
        b_degree = -degree;
      } else {
        b_degree = degree;
      }
      if (x < 0) {
        x = 0;
      }
      i = b_degree - x;
      for (deg = 3; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + 3 * stride) + V.size(1) * (((c - d) - deg) - 1)] *
                  (static_cast<real_T>(k) + 1.0);
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      // compute tri-degree terms if degree < 0
      if (degree < 0) {
        deg = -degree;
        u0 = order + 2;
        if (u0 > 0) {
          u0 = 0;
        }
        maxLayers = -degree * 3 + u0;
        // max number of layers needed in the Pascal tetrahedron
        cornerTriangle = 0;
        // number of elements subtracted in each corner Pascal triangle
        nTermsInLayer = d;
        // initializing number of elements in layer
        excess = 0;
        // excess based on overlapping of growing Pascal triangles
        i = 1 - degree;
        for (coder::SizeType p{i}; p <= maxLayers; p++) {
          //  Within each level, x^deg is at the peak of Pascal triangle
          cornerTriangle = (cornerTriangle + p) + degree;
          counterBottomRow = 0;
          // counter for the bottom row to be subtracted later
          for (coder::SizeType k{0}; k < deg; k++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] = 0.0;
            }
            c++;
            counterBottomRow++;
          }
          deg--;
          b_degree = p + degree;
          x = ((b_degree << 1) - p) - 1;
          if (x < 0) {
            x = 0;
          }
          excess += x;
          d = (d + p) + 1;
          // number of terms in Pascal tetrahedron
          nTermsInPrevLayer = nTermsInLayer;
          nTermsInLayer = d + 3 * (excess - cornerTriangle);
          balance = nTermsInPrevLayer + counterBottomRow;
          for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
            x = (b_degree - k) - 1;
            if (x < 0) {
              x = -x;
            }
            partition = -degree - x;
            for (coder::SizeType j{0}; j <= partition; j++) {
              for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
                V[(iPnt + offset) + V.size(1) * c] =
                    V[(iPnt + 3 * stride) + V.size(1) * (c - balance)] *
                    static_cast<real_T>(k + 1);
              }
              c++;
            }
          }
        }
      }
      //  compute du^4
      offset = us.size(0) * 7;
      uu4_tmp = 24.0 * std::pow(1.0, 4.0);
      for (coder::SizeType b_i{0}; b_i < 35; b_i++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
        }
      }
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * 20] = uu4_tmp * V[iPnt];
      }
      c = 35;
      d = 15;
      if (degree < 0) {
        i = -degree;
      } else {
        i = degree;
      }
      for (deg = 5; deg <= i; deg++) {
        scaleu = deg;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + (stride << 2)) + V.size(1) * ((c - (d << 1)) + deg)] *
              static_cast<real_T>(deg) * (static_cast<real_T>(deg) - 1.0);
        }
        c++;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu--;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + (stride << 2)) + V.size(1) * ((c - (d << 1)) + deg)] *
                scaleu * (scaleu - 1.0);
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * (c + 1)] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      //  compute du^2dv^2
      offset = us.size(0) << 3;
      for (coder::SizeType b_i{0}; b_i < 35; b_i++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
        }
      }
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * 22] = 4.0 * V[iPnt];
      }
      c = 35;
      d = 15;
      for (deg = 5; deg <= i; deg++) {
        scaleu = deg;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + 5 * stride) + V.size(1) * ((c - (d << 1)) + deg)] *
              static_cast<real_T>(deg) * (static_cast<real_T>(deg) - 1.0);
        }
        c++;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          scaleu--;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] =
                V[(iPnt + 5 * stride) + V.size(1) * ((c - (d << 1)) + deg)] *
                scaleu * (scaleu - 1.0);
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * (c + 1)] =
                V[b_degree + V.size(1) * ((c - d) - deg)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        c += 2;
        d = (d + deg) + 1;
      }
      //  compute dv^4
      offset = us.size(0) * 9;
      for (coder::SizeType b_i{0}; b_i < 35; b_i++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
        }
      }
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * 24] = uu4_tmp * V[iPnt];
      }
      c = 34;
      d = 15;
      for (deg = 5; deg <= degree; deg++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
        }
        scalev = 1.0;
        for (coder::SizeType j{0}; j <= deg - 2; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * (c + 2)] =
                V[(iPnt + 5 * stride) + V.size(1) * ((c - (d << 1)) + deg)] *
                scalev * (scalev - 1.0);
          }
          scalev++;
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * (c + 2)] =
              V[(5 * stride + iPnt) + V.size(1) * ((c - (d << 1)) + deg)] *
              static_cast<real_T>(deg) * (static_cast<real_T>(deg) - 1.0);
        }
        c += 3;
        for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            b_degree = offset + iPnt;
            V[b_degree + V.size(1) * c] =
                V[b_degree + V.size(1) * (((c - d) - deg) - 1)] *
                us[us.size(1) * iPnt + 2];
          }
          c++;
        }
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        d = (d + deg) + 1;
      }
      //  compute du^2*dw^2
      offset += us.size(0);
      for (coder::SizeType b_i{0}; b_i < 35; b_i++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
        }
      }
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * 29] = 4.0 * V[iPnt];
      }
      c = 35;
      d = 15;
      for (deg = 5; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + (stride << 2)) +
                    V.size(1) * (((c - (d << 1)) - deg) - 1)] *
                  (static_cast<real_T>(k) + 1.0) *
                  ((static_cast<real_T>(k) + 1.0) - 1.0);
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      //  compute dv^2*dw^2
      offset += us.size(0);
      for (coder::SizeType b_i{0}; b_i < 35; b_i++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
        }
      }
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * 31] = 4.0 * V[iPnt];
      }
      c = 35;
      d = 15;
      for (deg = 5; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + 5 * stride) +
                    V.size(1) * (((c - (d << 1)) - deg) - 1)] *
                  (static_cast<real_T>(k) + 1.0) *
                  ((static_cast<real_T>(k) + 1.0) - 1.0);
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
      //  compute dw^4
      offset += us.size(0);
      for (coder::SizeType b_i{0}; b_i < 35; b_i++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
        }
      }
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * 34] = uu4_tmp * V[iPnt];
      }
      c = 35;
      d = 15;
      for (deg = 5; deg <= i; deg++) {
        for (coder::SizeType j{0}; j <= deg; j++) {
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(offset + iPnt) + V.size(1) * c] = 0.0;
          }
          c++;
        }
        for (coder::SizeType k{0}; k < deg; k++) {
          i1 = (deg - k) - 1;
          for (coder::SizeType b_i{0}; b_i <= i1; b_i++) {
            for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
              V[(offset + iPnt) + V.size(1) * c] =
                  V[(iPnt + 6 * stride) +
                    V.size(1) * (((c - (d << 1)) - deg) - 1)] *
                  (static_cast<real_T>(k) + 1.0) *
                  ((static_cast<real_T>(k) + 1.0) - 1.0);
            }
            c++;
          }
        }
        d = (d + deg) + 1;
      }
    } break;
    default:
      m2cAssert(false, "Order must be 0, 1, 2, -1, -2, or -4.");
      break;
    }
  }
}

//  gen_vander_3d  Generate generalized/confluent Vandermonde matrix in 3D.
static void gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                          coder::SizeType npoints, coder::SizeType degree,
                          const real_T hs_inv_data[],
                          const coder::SizeType hs_inv_size[2],
                          ::coder::array<real_T, 2U> &V)
{
  real_T b_u2v2_tmp;
  real_T hs_inv_idx_0;
  real_T hs_inv_idx_1;
  real_T hs_inv_idx_2;
  real_T scaleu;
  real_T scalev;
  real_T scalew;
  real_T u2v2;
  real_T u2v2_tmp;
  real_T u2w2;
  real_T u2w2_tmp;
  real_T uu2;
  real_T uu4;
  real_T v2w2;
  real_T v4;
  real_T vv2;
  real_T ww2;
  real_T ww4;
  coder::SizeType b_degree;
  coder::SizeType balance;
  coder::SizeType c;
  coder::SizeType c_degree;
  coder::SizeType cornerTriangle;
  coder::SizeType counterBottomRow;
  coder::SizeType d;
  coder::SizeType deg;
  coder::SizeType excess;
  coder::SizeType i;
  coder::SizeType maxLayers;
  coder::SizeType nTermsInLayer;
  coder::SizeType nTermsInPrevLayer;
  coder::SizeType offset;
  coder::SizeType partition;
  coder::SizeType stride;
  coder::SizeType x_tmp_tmp;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  if (hs_inv_size[1] == 0) {
    hs_inv_idx_0 = 1.0;
    hs_inv_idx_1 = 1.0;
    hs_inv_idx_2 = 1.0;
  } else {
    hs_inv_idx_0 = hs_inv_data[0];
    hs_inv_idx_1 = hs_inv_data[1];
    hs_inv_idx_2 = hs_inv_data[2];
  }
  stride = us.size(0);
  //  Allocate storage for V
  if (degree >= 0) {
    b_degree = (degree + 1) * (degree + 2) * (degree + 3) / 6;
  } else {
    b_degree = (1 - degree) * (1 - degree) * (1 - degree);
  }
  if (degree > 0) {
    c_degree = 13;
  } else {
    c_degree = 19;
  }
  V.set_size(b_degree, us.size(0) * c_degree);
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
      V[iPnt + V.size(1) * 3] = us[us.size(1) * iPnt + 2];
    }
  } else {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 4;
  d = 3;
  x_tmp_tmp = -degree;
  c_degree = -degree;
  if (-degree > 0) {
    c_degree = 1;
  } else if (-degree < 0) {
    c_degree = -1;
  }
  c_degree *= -4;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (c_degree < 0) {
    c_degree = 0;
  }
  i = b_degree - c_degree;
  for (deg = 2; deg <= i; deg++) {
    //  Within each level, use convention of Pascal triangle with x^deg at peak
    for (coder::SizeType j{0}; j < deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * us[us.size(1) * iPnt];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt + V.size(1) * c] =
          V[iPnt + V.size(1) * ((c - d) - 1)] * us[us.size(1) * iPnt + 1];
    }
    c++;
    for (coder::SizeType j{0}; j < d; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] = V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
                                  us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    d = (d + deg) + 1;
  }
  //  Compute the tri-degree terms if degree<0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3 - 4;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      coder::SizeType gap;
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 1;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType k{0}; k < deg; k++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] = V[iPnt + V.size(1) * (c - nTermsInLayer)] *
                                    us[us.size(1) * iPnt + 1];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      c_degree = ((degree + degree) + p) - 1;
      if (c_degree < 0) {
        c_degree = 0;
      }
      excess += c_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      gap = (nTermsInPrevLayer + counterBottomRow) - 1;
      b_degree = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= b_degree; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - gap)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  m2cAssert(true, "");
  //      compute higher order confluent Vandermonde matrix blocks
  m2cAssert(
      degree > 0,
      "Biharnomic is only supported for Pascal-tetrahedral monomials in 3D.");
  //  Compute order-1 CVM row blocks from order-0 GVM.
  m2cAssert(degree != 0, "");
  // compute derivatives with respect to u
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    c_degree = stride + iPnt;
    V[c_degree] = 0.0;
    V[c_degree + V.size(1)] = V[iPnt] * hs_inv_idx_0;
    V[c_degree + V.size(1) * 2] = 0.0;
    V[c_degree + V.size(1) * 3] = 0.0;
  }
  c = 4;
  d = 3;
  c_degree = -degree;
  if (-degree > 0) {
    c_degree = 1;
  } else if (-degree < 0) {
    c_degree = -1;
  }
  c_degree *= -3;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (c_degree < 0) {
    c_degree = 0;
  }
  i = b_degree - c_degree;
  for (deg = 2; deg <= i; deg++) {
    scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] =
          V[iPnt + V.size(1) * (c - d)] * scaleu;
    }
    c++;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      scaleu -= hs_inv_idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(stride + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * scaleu;
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * c] = 0.0;
    }
    for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        c_degree = stride + iPnt;
        V[c_degree + V.size(1) * (c + 1)] =
            V[c_degree + V.size(1) * ((c - d) - deg)] *
            us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(stride + iPnt) + V.size(1) * (c + 1)] = 0.0;
    }
    c += 2;
    d = (d + deg) + 1;
  }
  // tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3 - 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 1;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          c_degree = stride + iPnt;
          V[c_degree + V.size(1) * c] =
              V[c_degree + V.size(1) * (c - nTermsInLayer)] *
              us[us.size(1) * iPnt + 1];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      c_degree = (((p + degree) << 1) - p) - 1;
      if (c_degree < 0) {
        c_degree = 0;
      }
      excess += c_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = (nTermsInPrevLayer + counterBottomRow) - 1;
      b_degree = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= b_degree; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          c_degree = stride + iPnt;
          V[c_degree + V.size(1) * c] =
              V[c_degree + V.size(1) * (c - balance)] *
              us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  // compute derivatives with respect to v
  offset = us.size(0) + us.size(0);
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    c_degree = offset + iPnt;
    V[c_degree] = 0.0;
    V[c_degree + V.size(1)] = 0.0;
    V[c_degree + V.size(1) * 2] = V[iPnt] * hs_inv_idx_1;
    V[c_degree + V.size(1) * 3] = 0.0;
  }
  c = 4;
  d = 4;
  c_degree = -degree;
  if (-degree > 0) {
    c_degree = 1;
  } else if (-degree < 0) {
    c_degree = -1;
  }
  c_degree *= -3;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (c_degree < 0) {
    c_degree = 0;
  }
  i = b_degree - c_degree;
  for (deg = 2; deg <= i; deg++) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    scalev = hs_inv_idx_1;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * scalev;
      }
      scalev += hs_inv_idx_1;
      c++;
    }
    scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] =
          V[iPnt + V.size(1) * (c - d)] * scalev;
    }
    c++;
    for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        c_degree = offset + iPnt;
        V[c_degree + V.size(1) * c] =
            V[c_degree + V.size(1) * ((c - d) - deg)] *
            us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    d = (d + deg) + 1;
  }
  // compute the tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3 - 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d - 2;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          c_degree = offset + iPnt;
          V[c_degree + V.size(1) * c] =
              V[c_degree + V.size(1) * (c - nTermsInLayer)] *
              us[us.size(1) * iPnt];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      c_degree = (((p + degree) << 1) - p) - 1;
      if (c_degree < 0) {
        c_degree = 0;
      }
      excess += c_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer + 1;
      nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
      balance = nTermsInPrevLayer + counterBottomRow;
      b_degree = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= b_degree; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          c_degree = offset + iPnt;
          V[c_degree + V.size(1) * c] =
              V[c_degree + V.size(1) * (c - balance)] *
              us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  // compute derivatives with respect to w
  offset += us.size(0);
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    c_degree = offset + iPnt;
    V[c_degree] = 0.0;
    V[c_degree + V.size(1)] = 0.0;
    V[c_degree + V.size(1) * 2] = 0.0;
    V[c_degree + V.size(1) * 3] = V[iPnt] * hs_inv_idx_2;
  }
  c = 4;
  d = 3;
  c_degree = -degree;
  if (-degree > 0) {
    c_degree = 1;
  } else if (-degree < 0) {
    c_degree = -1;
  }
  c_degree *= -3;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (c_degree < 0) {
    c_degree = 0;
  }
  i = b_degree - c_degree;
  for (deg = 2; deg <= i; deg++) {
    for (coder::SizeType j{0}; j <= deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    for (coder::SizeType k{0}; k < deg; k++) {
      b_degree = (deg - k) - 1;
      for (coder::SizeType b_i{0}; b_i <= b_degree; b_i++) {
        scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[iPnt + V.size(1) * (((c - d) - deg) - 1)] * scalew;
        }
        c++;
      }
    }
    d = (d + deg) + 1;
  }
  // compute tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3 - 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType k{0}; k < deg; k++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      b_degree = p + degree;
      c_degree = ((b_degree << 1) - p) - 1;
      if (c_degree < 0) {
        c_degree = 0;
      }
      excess += c_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = nTermsInPrevLayer + counterBottomRow;
      for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
        c_degree = (b_degree - k) - 1;
        if (c_degree < 0) {
          c_degree = -c_degree;
        }
        partition = -degree - c_degree;
        for (coder::SizeType j{0}; j <= partition; j++) {
          scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(iPnt + offset) + V.size(1) * c] =
                V[iPnt + V.size(1) * (c - balance)] * scalew;
          }
          c++;
        }
      }
    }
  }
  //  compute du^2
  offset = us.size(0) << 2;
  uu2 = 2.0 * hs_inv_idx_0 * hs_inv_idx_0;
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    c_degree = offset + iPnt;
    V[c_degree] = 0.0;
    V[c_degree + V.size(1)] = 0.0;
    V[c_degree + V.size(1) * 2] = 0.0;
    V[c_degree + V.size(1) * 3] = 0.0;
    V[c_degree + V.size(1) * 4] = uu2 * V[iPnt];
    for (i = 0; i < 5; i++) {
      V[c_degree + V.size(1) * (i + 5)] = 0.0;
    }
  }
  c = 10;
  d = 6;
  c_degree = -degree;
  if (-degree > 0) {
    c_degree = 1;
  } else if (-degree < 0) {
    c_degree = -1;
  }
  c_degree *= -2;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (c_degree < 0) {
    c_degree = 0;
  }
  i = b_degree - c_degree;
  for (deg = 3; deg <= i; deg++) {
    scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] =
          V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
    }
    c++;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      scaleu -= hs_inv_idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[(iPnt + stride) + V.size(1) * (c - d)] * scaleu;
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        c_degree = offset + iPnt;
        V[c_degree + V.size(1) * (c + 1)] =
            V[c_degree + V.size(1) * ((c - d) - deg)] *
            us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
    }
    c += 2;
    d = (d + deg) + 1;
  }
  // compute tri degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3 - 2;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 1;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          c_degree = offset + iPnt;
          V[c_degree + V.size(1) * c] =
              V[c_degree + V.size(1) * (c - nTermsInLayer)] *
              us[us.size(1) * iPnt + 1];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      c_degree = (((p + degree) << 1) - p) - 1;
      if (c_degree < 0) {
        c_degree = 0;
      }
      excess += c_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = (nTermsInPrevLayer + counterBottomRow) - 1;
      b_degree = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= b_degree; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          c_degree = offset + iPnt;
          V[c_degree + V.size(1) * c] =
              V[c_degree + V.size(1) * (c - balance)] *
              us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  //  compute dv^2
  offset += us.size(0);
  vv2 = 2.0 * hs_inv_idx_1 * hs_inv_idx_1;
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    c_degree = offset + iPnt;
    for (i = 0; i < 6; i++) {
      V[c_degree + V.size(1) * i] = 0.0;
    }
    V[c_degree + V.size(1) * 6] = vv2 * V[iPnt];
    V[c_degree + V.size(1) * 7] = 0.0;
    V[c_degree + V.size(1) * 8] = 0.0;
    V[c_degree + V.size(1) * 9] = 0.0;
  }
  c = 10;
  d = 7;
  c_degree = -degree;
  if (-degree > 0) {
    c_degree = 1;
  } else if (-degree < 0) {
    c_degree = -1;
  }
  c_degree *= -2;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (c_degree < 0) {
    c_degree = 0;
  }
  i = b_degree - c_degree;
  for (deg = 3; deg <= i; deg++) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    scalev = hs_inv_idx_1;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[(iPnt + (stride << 1)) + V.size(1) * (c - d)] * scalev;
      }
      scalev += hs_inv_idx_1;
      c++;
    }
    scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] =
          V[((stride << 1) + iPnt) + V.size(1) * (c - d)] * scalev;
    }
    c++;
    for (coder::SizeType kdegree{0}; kdegree <= d - 3; kdegree++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        c_degree = offset + iPnt;
        V[c_degree + V.size(1) * c] =
            V[c_degree + V.size(1) * ((c - d) - deg)] *
            us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    c++;
    d = (d + deg) + 1;
  }
  // compute the tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3 - 2;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d - 2;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType kdegree{0}; kdegree < deg; kdegree++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          c_degree = offset + iPnt;
          V[c_degree + V.size(1) * c] =
              V[c_degree + V.size(1) * (c - nTermsInLayer)] *
              us[us.size(1) * iPnt];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      c_degree = (((p + degree) << 1) - p) - 1;
      if (c_degree < 0) {
        c_degree = 0;
      }
      excess += c_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer + 1;
      nTermsInLayer = (d + 3 * (excess - cornerTriangle)) - 2;
      balance = nTermsInPrevLayer + counterBottomRow;
      b_degree = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= b_degree; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          c_degree = offset + iPnt;
          V[c_degree + V.size(1) * c] =
              V[c_degree + V.size(1) * (c - balance)] *
              us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  //  compute dw^2
  offset += us.size(0);
  ww2 = 2.0 * hs_inv_idx_2 * hs_inv_idx_2;
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    c_degree = offset + iPnt;
    for (i = 0; i < 9; i++) {
      V[c_degree + V.size(1) * i] = 0.0;
    }
    V[c_degree + V.size(1) * 9] = ww2 * V[iPnt];
  }
  c = 10;
  d = 6;
  c_degree = -degree;
  if (-degree > 0) {
    c_degree = 1;
  } else if (-degree < 0) {
    c_degree = -1;
  }
  c_degree *= -2;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  if (c_degree < 0) {
    c_degree = 0;
  }
  i = b_degree - c_degree;
  for (deg = 3; deg <= i; deg++) {
    for (coder::SizeType j{0}; j <= deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    for (coder::SizeType k{0}; k < deg; k++) {
      b_degree = (deg - k) - 1;
      for (coder::SizeType b_i{0}; b_i <= b_degree; b_i++) {
        scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + 3 * stride) + V.size(1) * (((c - d) - deg) - 1)] *
              scalew;
        }
        c++;
      }
    }
    d = (d + deg) + 1;
  }
  // compute tri-degree terms if degree < 0
  if (degree < 0) {
    deg = -degree;
    maxLayers = -degree * 3 - 2;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 0;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType k{0}; k < deg; k++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] = 0.0;
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      b_degree = p + degree;
      c_degree = ((b_degree << 1) - p) - 1;
      if (c_degree < 0) {
        c_degree = 0;
      }
      excess += c_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      balance = nTermsInPrevLayer + counterBottomRow;
      for (coder::SizeType k{0}; k < x_tmp_tmp; k++) {
        c_degree = (b_degree - k) - 1;
        if (c_degree < 0) {
          c_degree = -c_degree;
        }
        partition = -degree - c_degree;
        for (coder::SizeType j{0}; j <= partition; j++) {
          scalew = static_cast<real_T>(k + 1) * hs_inv_idx_2;
          for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
            V[(iPnt + offset) + V.size(1) * c] =
                V[(iPnt + 3 * stride) + V.size(1) * (c - balance)] * scalew;
          }
          c++;
        }
      }
    }
  }
  //  compute du^4
  offset = us.size(0) * 7;
  uu4 = 24.0 * std::pow(hs_inv_idx_0, 4.0);
  for (coder::SizeType b_i{0}; b_i < 35; b_i++) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
    }
  }
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    V[(offset + iPnt) + V.size(1) * 20] = uu4 * V[iPnt];
  }
  c = 35;
  d = 15;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 5; deg <= i; deg++) {
    scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] =
          V[(iPnt + (stride << 2)) + V.size(1) * ((c - (d << 1)) + deg)] *
          scaleu * (scaleu - hs_inv_idx_0);
    }
    c++;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      scaleu -= hs_inv_idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[(iPnt + (stride << 2)) + V.size(1) * ((c - (d << 1)) + deg)] *
            scaleu * (scaleu - hs_inv_idx_0);
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        c_degree = offset + iPnt;
        V[c_degree + V.size(1) * (c + 1)] =
            V[c_degree + V.size(1) * ((c - d) - deg)] *
            us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
    }
    c += 2;
    d = (d + deg) + 1;
  }
  //  compute du^2dv^2
  offset = us.size(0) << 3;
  u2v2_tmp = 4.0 * (hs_inv_idx_0 * hs_inv_idx_0);
  b_u2v2_tmp = hs_inv_idx_1 * hs_inv_idx_1;
  u2v2 = u2v2_tmp * b_u2v2_tmp;
  for (coder::SizeType b_i{0}; b_i < 35; b_i++) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
    }
  }
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    V[(offset + iPnt) + V.size(1) * 22] = u2v2 * V[iPnt];
  }
  c = 35;
  d = 15;
  for (deg = 5; deg <= i; deg++) {
    scaleu = static_cast<real_T>(deg) * hs_inv_idx_0;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] =
          V[(iPnt + 5 * stride) + V.size(1) * ((c - (d << 1)) + deg)] * scaleu *
          (scaleu - hs_inv_idx_0);
    }
    c++;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      scaleu -= hs_inv_idx_0;
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] =
            V[(iPnt + 5 * stride) + V.size(1) * ((c - (d << 1)) + deg)] *
            scaleu * (scaleu - hs_inv_idx_0);
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        c_degree = offset + iPnt;
        V[c_degree + V.size(1) * (c + 1)] =
            V[c_degree + V.size(1) * ((c - d) - deg)] *
            us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
    }
    c += 2;
    d = (d + deg) + 1;
  }
  //  compute dv^4
  offset = us.size(0) * 9;
  v4 = 24.0 * std::pow(hs_inv_idx_1, 4.0);
  for (coder::SizeType b_i{0}; b_i < 35; b_i++) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
    }
  }
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    V[(offset + iPnt) + V.size(1) * 24] = v4 * V[iPnt];
  }
  c = 34;
  d = 15;
  for (deg = 5; deg <= degree; deg++) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * (c + 1)] = 0.0;
    }
    scalev = hs_inv_idx_1;
    for (coder::SizeType j{0}; j <= deg - 2; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * (c + 2)] =
            V[(iPnt + 5 * stride) + V.size(1) * ((c - (d << 1)) + deg)] *
            scalev * (scalev - hs_inv_idx_1);
      }
      scalev += hs_inv_idx_1;
      c++;
    }
    scalev = static_cast<real_T>(deg) * hs_inv_idx_1;
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * (c + 2)] =
          V[(5 * stride + iPnt) + V.size(1) * ((c - (d << 1)) + deg)] * scalev *
          (scalev - hs_inv_idx_1);
    }
    c += 3;
    for (coder::SizeType kdegree{0}; kdegree <= d - 2; kdegree++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        c_degree = offset + iPnt;
        V[c_degree + V.size(1) * c] =
            V[c_degree + V.size(1) * (((c - d) - deg) - 1)] *
            us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * c] = 0.0;
    }
    d = (d + deg) + 1;
  }
  //  compute du^2*dw^2
  offset += us.size(0);
  u2w2_tmp = hs_inv_idx_2 * hs_inv_idx_2;
  u2w2 = u2v2_tmp * u2w2_tmp;
  for (coder::SizeType b_i{0}; b_i < 35; b_i++) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
    }
  }
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    V[(offset + iPnt) + V.size(1) * 29] = u2w2 * V[iPnt];
  }
  c = 35;
  d = 15;
  for (deg = 5; deg <= i; deg++) {
    for (coder::SizeType j{0}; j <= deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    for (coder::SizeType k{0}; k < deg; k++) {
      b_degree = (deg - k) - 1;
      for (coder::SizeType b_i{0}; b_i <= b_degree; b_i++) {
        scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + (stride << 2)) +
                V.size(1) * (((c - (d << 1)) - deg) - 1)] *
              scalew * (scalew - hs_inv_idx_2);
        }
        c++;
      }
    }
    d = (d + deg) + 1;
  }
  //  compute dv^2*dw^2
  offset += us.size(0);
  v2w2 = 4.0 * b_u2v2_tmp * u2w2_tmp;
  for (coder::SizeType b_i{0}; b_i < 35; b_i++) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
    }
  }
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    V[(offset + iPnt) + V.size(1) * 31] = v2w2 * V[iPnt];
  }
  c = 35;
  d = 15;
  for (deg = 5; deg <= i; deg++) {
    for (coder::SizeType j{0}; j <= deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    for (coder::SizeType k{0}; k < deg; k++) {
      b_degree = (deg - k) - 1;
      for (coder::SizeType b_i{0}; b_i <= b_degree; b_i++) {
        scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + 5 * stride) +
                V.size(1) * (((c - (d << 1)) - deg) - 1)] *
              scalew * (scalew - hs_inv_idx_2);
        }
        c++;
      }
    }
    d = (d + deg) + 1;
  }
  //  compute dw^4
  offset += us.size(0);
  ww4 = 24.0 * std::pow(hs_inv_idx_2, 4.0);
  for (coder::SizeType b_i{0}; b_i < 35; b_i++) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[(offset + iPnt) + V.size(1) * b_i] = 0.0;
    }
  }
  for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
    V[(offset + iPnt) + V.size(1) * 34] = ww4 * V[iPnt];
  }
  c = 35;
  d = 15;
  for (deg = 5; deg <= i; deg++) {
    for (coder::SizeType j{0}; j <= deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[(offset + iPnt) + V.size(1) * c] = 0.0;
      }
      c++;
    }
    for (coder::SizeType k{0}; k < deg; k++) {
      b_degree = (deg - k) - 1;
      for (coder::SizeType b_i{0}; b_i <= b_degree; b_i++) {
        scalew = (static_cast<real_T>(k) + 1.0) * hs_inv_idx_2;
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[(offset + iPnt) + V.size(1) * c] =
              V[(iPnt + 6 * stride) +
                V.size(1) * (((c - (d << 1)) - deg) - 1)] *
              scalew * (scalew - hs_inv_idx_2);
        }
        c++;
      }
    }
    d = (d + deg) + 1;
  }
}

//  gen_vander_3d  Generate generalized/confluent Vandermonde matrix in 3D.
static void gen_vander_3d(const real_T us_data[], coder::SizeType degree,
                          ::coder::array<real_T, 2U> &V)
{
  coder::SizeType c;
  coder::SizeType d;
  coder::SizeType i;
  V.set_size((degree + 1) * (degree + 2) * (degree + 3) / 6, 1);
  //  compute 0th order generalized Vandermonde matrix
  V[V.size(1) * 3] = us_data[2];
  V[V.size(1) * 2] = us_data[1];
  V[V.size(1)] = us_data[0];
  V[0] = 1.0;
  c = 4;
  d = 4;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (coder::SizeType deg{2}; deg <= i; deg++) {
    //  Within each level, use convention of Pascal triangle with x^deg at peak
    for (coder::SizeType j{0}; j < deg; j++) {
      V[V.size(1) * c] = V[V.size(1) * ((c - d) + 1)] * us_data[0];
      c++;
    }
    V[V.size(1) * c] = V[V.size(1) * (c - d)] * us_data[1];
    c++;
    for (coder::SizeType j{0}; j <= d - 2; j++) {
      V[V.size(1) * c] = V[V.size(1) * ((c - d) - deg)] * us_data[2];
      c++;
    }
    d = (d + deg) + 1;
  }
  //  Compute the tri-degree terms if degree<0
  m2cAssert(true, "");
}

//  gen_vander_3d  Generate generalized/confluent Vandermonde matrix in 3D.
static void gen_vander_3d(const ::coder::array<real_T, 2U> &us,
                          coder::SizeType npoints, coder::SizeType degree,
                          ::coder::array<real_T, 2U> &V)
{
  coder::SizeType b_degree;
  coder::SizeType c;
  coder::SizeType d;
  coder::SizeType deg;
  coder::SizeType i;
  if (npoints == 0) {
    npoints = us.size(0);
  } else if (npoints > us.size(0)) {
    m2cErrMsgIdAndTxt("wlslib:BufferTooSmall", "Input us is too small.");
  }
  //  Allocate storage for V
  if (degree >= 0) {
    b_degree = (degree + 1) * (degree + 2) * (degree + 3) / 6;
  } else {
    b_degree = (1 - degree) * (1 - degree) * (1 - degree);
  }
  V.set_size(b_degree, us.size(0));
  //  compute 0th order generalized Vandermonde matrix
  if (degree != 0) {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
      V[iPnt + V.size(1)] = us[us.size(1) * iPnt];
      V[iPnt + V.size(1) * 2] = us[us.size(1) * iPnt + 1];
      V[iPnt + V.size(1) * 3] = us[us.size(1) * iPnt + 2];
    }
  } else {
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt] = 1.0;
    }
  }
  c = 4;
  d = 3;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (deg = 2; deg <= i; deg++) {
    //  Within each level, use convention of Pascal triangle with x^deg at peak
    for (coder::SizeType j{0}; j < deg; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] =
            V[iPnt + V.size(1) * (c - d)] * us[us.size(1) * iPnt];
      }
      c++;
    }
    for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
      V[iPnt + V.size(1) * c] =
          V[iPnt + V.size(1) * ((c - d) - 1)] * us[us.size(1) * iPnt + 1];
    }
    c++;
    for (coder::SizeType j{0}; j < d; j++) {
      for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
        V[iPnt + V.size(1) * c] = V[iPnt + V.size(1) * (((c - d) - deg) - 1)] *
                                  us[us.size(1) * iPnt + 2];
      }
      c++;
    }
    d = (d + deg) + 1;
  }
  //  Compute the tri-degree terms if degree<0
  if (degree < 0) {
    coder::SizeType cornerTriangle;
    coder::SizeType excess;
    coder::SizeType maxLayers;
    coder::SizeType nTermsInLayer;
    deg = -degree;
    maxLayers = -degree * 3;
    // max number of layers needed in the Pascal tetrahedron
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    nTermsInLayer = d;
    // initializing number of elements in layer
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    i = 1 - degree;
    for (coder::SizeType p{i}; p <= maxLayers; p++) {
      coder::SizeType counterBottomRow;
      coder::SizeType gap;
      coder::SizeType nTermsInPrevLayer;
      //  Within each level, x^deg is at the peak of Pascal triangle
      cornerTriangle = (cornerTriangle + p) + degree;
      counterBottomRow = 1;
      // counter for the bottom row to be subtracted later
      for (coder::SizeType k{0}; k < deg; k++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] = V[iPnt + V.size(1) * (c - nTermsInLayer)] *
                                    us[us.size(1) * iPnt + 1];
        }
        c++;
        counterBottomRow++;
      }
      deg--;
      b_degree = ((degree + degree) + p) - 1;
      if (b_degree < 0) {
        b_degree = 0;
      }
      excess += b_degree;
      d = (d + p) + 1;
      // number of terms in Pascal tetrahedron
      nTermsInPrevLayer = nTermsInLayer;
      nTermsInLayer = d + 3 * (excess - cornerTriangle);
      gap = (nTermsInPrevLayer + counterBottomRow) - 1;
      b_degree = nTermsInLayer - counterBottomRow;
      for (coder::SizeType j{0}; j <= b_degree; j++) {
        for (coder::SizeType iPnt{0}; iPnt < npoints; iPnt++) {
          V[iPnt + V.size(1) * c] =
              V[iPnt + V.size(1) * (c - gap)] * us[us.size(1) * iPnt + 2];
        }
        c++;
      }
    }
  }
  m2cAssert(true, "");
}

//  gen_vander_3d_dag  Build a DAG for Vandermonde matrix in 3D.
static void gen_vander_3d_dag(coder::SizeType degree,
                              ::coder::array<uint8_T, 2U> &dag)
{
  coder::SizeType b_degree;
  coder::SizeType c;
  coder::SizeType d;
  coder::SizeType i;
  coder::SizeType maxterms;
  if (degree >= 0) {
    b_degree = (degree + 1) * (degree + 2) * (degree + 3) / 6;
  } else {
    b_degree = (1 - degree) * (1 - degree) * (1 - degree);
  }
  dag.set_size(b_degree + 1, 3);
  if (degree != 0) {
    dag[0] = 1U;
    //  x-child
    dag[1] = 2U;
    //  y-child
    dag[2] = 3U;
    //  z-child
  } else {
    dag[0] = 0U;
    dag[1] = 0U;
    dag[2] = 0U;
    //  No children
  }
  c = 1;
  d = 3;
  if (degree < 0) {
    i = -degree;
  } else {
    i = degree;
  }
  for (coder::SizeType deg{2}; deg <= i; deg++) {
    maxterms = (d + deg) + 1;
    for (coder::SizeType j{deg}; j >= 1; j--) {
      for (coder::SizeType b_i{0}; b_i < j; b_i++) {
        b_degree = c + b_i;
        dag[3 * b_degree] = static_cast<uint8_T>(d);
        dag[3 * b_degree + 1] = static_cast<uint8_T>(d + 1);
        dag[3 * b_degree + 2] = static_cast<uint8_T>(maxterms);
      }
      c += j;
      d++;
    }
    d = maxterms;
  }
  if (degree > 0) {
    i = dag.size(0);
    for (coder::SizeType b_i{c + 1}; b_i <= i; b_i++) {
      dag[3 * (b_i - 1)] = 0U;
      dag[3 * (b_i - 1) + 1] = 0U;
      dag[3 * (b_i - 1) + 2] = 0U;
    }
  } else if (degree < 0) {
    coder::SizeType cornerTriangle;
    coder::SizeType excess;
    coder::SizeType maxlayers;
    coder::SizeType num_elem_group;
    maxlayers = -3 * degree + 1;
    cornerTriangle = 0;
    // number of elements subtracted in each corner Pascal triangle
    excess = 0;
    // excess based on overlapping of growing Pascal triangles
    num_elem_group = -1;
    i = -degree;
    for (coder::SizeType p{i}; p <= maxlayers; p++) {
      coder::SizeType ntermsinlayer;
      coder::SizeType x_tmp;
      coder::SizeType y;
      cornerTriangle = (cornerTriangle + p) + degree;
      y = excess << 1;
      x_tmp = p + degree;
      b_degree = (x_tmp << 1) - p;
      if (b_degree < 0) {
        b_degree = 0;
      }
      excess += b_degree;
      maxterms =
          ((((d + (-degree << 1)) - 3 * cornerTriangle) - p) + y) + excess;
      ntermsinlayer = d + 3 * (excess - cornerTriangle);
      for (coder::SizeType group{0}; group <= i; group++) {
        y = x_tmp - group;
        if (y < 0) {
          b_degree = -y;
        } else {
          b_degree = y;
        }
        num_elem_group = -degree - b_degree;
        if (num_elem_group + 1 < 1) {
          ntermsinlayer -= 3;
        } else if (((-degree - p) + group) - 1 < 0) {
          dag[3 * c] = 0U;
          for (coder::SizeType b_i{0}; b_i < num_elem_group; b_i++) {
            b_degree = c + b_i;
            dag[3 * (b_degree + 1)] = static_cast<uint8_T>(ntermsinlayer - 1);
            dag[3 * b_degree + 1] = static_cast<uint8_T>(ntermsinlayer);
            dag[3 * b_degree + 2] = static_cast<uint8_T>(maxterms);
          }
          c += num_elem_group;
          dag[3 * c + 1] = 0U;
          dag[3 * c + 2] = static_cast<uint8_T>(maxterms);
          c++;
          if (y > 1) {
            y = 1;
          }
          ntermsinlayer -= y;
        } else {
          for (coder::SizeType b_i{0}; b_i <= num_elem_group; b_i++) {
            b_degree = c + b_i;
            dag[3 * b_degree] = static_cast<uint8_T>(ntermsinlayer - 1);
            dag[3 * b_degree + 1] = static_cast<uint8_T>(ntermsinlayer);
            dag[3 * b_degree + 2] = static_cast<uint8_T>(maxterms);
          }
          c = (c + num_elem_group) + 1;
          ntermsinlayer++;
        }
      }
      for (coder::SizeType j{0}; j <= num_elem_group; j++) {
        dag[3 * (((c + j) - num_elem_group) - 1) + 2] = 0U;
      }
      d = (d + p) + 2;
    }
  }
  //  Use last entry as signature
  i = dag.size(0) * 3 - 1;
  dag[i % dag.size(0) * 3 + i / dag.size(0)] =
      static_cast<uint8_T>(degree + 127);
}

//  rrqr_factor  Compute rank-revealing QR with column pivoting
static void rrqr_factor(const ::coder::array<real_T, 2U> &A, real_T thres,
                        coder::SizeType rowoffset, coder::SizeType coloffset,
                        coder::SizeType m, coder::SizeType n,
                        ::coder::array<real_T, 2U> &QR,
                        ::coder::array<int32_T, 1U> &p, int32_T *rank,
                        ::coder::array<real_T, 1U> &work)
{
  coder::SizeType wsize;
  if (m == 0) {
    m = A.size(1) - rowoffset;
  } else {
    m2cAssert(m + rowoffset <= A.size(1),
              "Number of rows cannot exceed nrows(A).");
  }
  if (n == 0) {
    n = A.size(0) - coloffset;
  } else {
    m2cAssert(n + coloffset <= A.size(0),
              "Number of ncolumns cannot exceed ncols(A).");
  }
  //  Preallocate output arguments
  m2cAssert(QR.size(1) == A.size(1),
            "The number of rows in QR must be equal to that of A.");
  m2cAssert(QR.size(0) >= n + 1,
            "The number of columns in QR must be greater than that of A.");
  m2cAssert(p.size(0) >= n, "Length of permutation vector must be no smaller "
                            "than the number of columns.");
  //  Allocate work space if needed
  wsize = wls::query_work_size(m, n);
  work.set_size(wsize);
  //  Invoke C++ function
  p[0] = 0;
  *rank = wls::rrqr_factor_nodag(&A[rowoffset + A.size(1) * coloffset], thres,
                                 m, n, &QR[0], &(p.data())[0],
                                 &(work.data())[0], wsize, A.size(1));
}

//  rrqr_qmulti  Perform Q*bs, where Q is stored implicitly in QR
static void rrqr_qmulti(const ::coder::array<real_T, 2U> &QR, coder::SizeType m,
                        coder::SizeType n, coder::SizeType rank,
                        ::coder::array<real_T, 2U> &bs, coder::SizeType nrhs,
                        ::coder::array<real_T, 1U> &work)
{
  coder::SizeType stride_bs;
  coder::SizeType u1;
  coder::SizeType wsize;
  stride_bs = bs.size(1);
  //  Obtain input arguments
  if (m == 0) {
    m = QR.size(1);
  }
  if (n == 0) {
    n = QR.size(0) - 1;
  }
  if (rank == 0) {
    rank = n;
  }
  u1 = n;
  if (m <= n) {
    u1 = m;
  }
  if ((rank > u1) || (rank < 1)) {
    m2cErrMsgIdAndTxt(
        "wlslib:WrongRank",
        "Rank %d must be a positive value no greater than min(%d, %d).",
        (int)rank, (int)m, (int)n);
  }
  if (nrhs == 0) {
    nrhs = bs.size(0);
  }
  //  Resize work space if needed
  wsize = wls::query_work_size(m, n);
  work.set_size(wsize);
  //  zero out extra rows in bs to avoid errors in LAPACK
  u1 = n + 1;
  for (coder::SizeType i{u1}; i <= m; i++) {
    for (coder::SizeType j{0}; j < nrhs; j++) {
      bs[(i + bs.size(1) * j) - 1] = 0.0;
    }
  }
  //  Invoke C++ function
  wls::rrqr_qmulti(&QR[0], m, n, rank, QR.size(1), nrhs, &bs[0], stride_bs,
                   &(work.data())[0], wsize);
}

//  rrqr_rtsolve  Perform forward substitution to compute bs=R'\bs, where R is
static void rrqr_rtsolve(const ::coder::array<real_T, 2U> &QR,
                         coder::SizeType n, coder::SizeType rank,
                         ::coder::array<real_T, 2U> &bs, coder::SizeType nrhs)
{
  coder::SizeType i;
  if (n == 0) {
    n = QR.size(0) - 1;
  }
  if (rank == 0) {
    rank = n;
  }
  if (QR.size(1) > n) {
    i = n;
  } else {
    i = QR.size(1);
  }
  if ((rank > i) || (rank < 1)) {
    m2cErrMsgIdAndTxt(
        "wlslib:WrongRank",
        "Rank %d must be a positive value no greater than min(%d, %d).",
        (int)rank, (int)QR.size(1), (int)n);
  }
  if (nrhs == 0) {
    nrhs = bs.size(0);
  }
  //  Obtain stride
  wls::rrqr_rtsolve(&QR[0], n, rank, QR.size(1), nrhs, &bs[0], bs.size(1));
}

//  wls_buhmann_weights  Weights based on Buhmann's radial basis function
static void wls_buhmann_weights(const ::coder::array<real_T, 2U> &us,
                                coder::SizeType npoints, coder::SizeType degree,
                                const ::coder::array<real_T, 1U> &params_sh,
                                const ::coder::array<real_T, 2U> &params_pw,
                                ::coder::array<real_T, 1U> &ws)
{
  real_T d;
  real_T dist_k;
  real_T r;
  real_T r1;
  real_T r2;
  real_T rho;
  real_T sigma;
  coder::SizeType abs_degree;
  coder::SizeType i;
  if (degree == 0) {
    degree = 2;
  }
  if (degree < 0) {
    abs_degree = 1 - degree;
  } else {
    abs_degree = degree + 1;
  }
  if ((params_sh.size(0) != 0) && (params_sh[0] != 0.0)) {
    sigma = params_sh[0];

    //  Assign default rho
  } else if (abs_degree - 1 >= 7) {
    sigma = 1.4;
  } else {
    sigma = dv1[abs_degree - 2];
  }
  if (ws.size(0) == 0) {
    ws.set_size(npoints);
  } else {
    m2cAssert(ws.size(0) >= npoints,
              "length of ws cannot be smaller than npoints");
  }
  //  Compute rho to be sigma times the kth distance for k=ceil(1.5*ncoff)
  if (degree >= 0) {
    //  Compute 2-norm
    i = us.size(1);
    for (coder::SizeType b_i{0}; b_i < npoints; b_i++) {
      d = us[us.size(1) * b_i];
      r2 = d * d;
      for (coder::SizeType j{2}; j <= i; j++) {
        d = us[(j + us.size(1) * b_i) - 1];
        r2 += d * d;
      }
      ws[b_i] = std::sqrt(r2);
    }
  } else {
    //  Compute inf-norm for tensor-product
    i = us.size(1);
    for (coder::SizeType b_i{0}; b_i < npoints; b_i++) {
      r = std::abs(us[us.size(1) * b_i]);
      for (coder::SizeType j{2}; j <= i; j++) {
        r1 = std::abs(us[(j + us.size(1) * b_i) - 1]);
        if (r1 > r) {
          r = r1;
        }
      }
      ws[b_i] = r;
    }
  }
  if (us.size(1) == 1) {
    i = abs_degree;
  } else if (us.size(1) == 2) {
    if (degree < 0) {
      i = abs_degree * abs_degree;
    } else {
      i = (abs_degree + 1) * abs_degree / 2;
    }
  } else if (degree < 0) {
    i = abs_degree * abs_degree * abs_degree;
  } else {
    i = (abs_degree + 2) * (abs_degree + 1) * abs_degree / 6;
  }
  dist_k = find_kth_shortest_dist(ws, (i * 3 + 1) / 2, 1, npoints);
  rho = sigma * dist_k;
  if ((params_pw.size(0) == 0) || (params_pw.size(1) == 0)) {
    for (coder::SizeType b_i{0}; b_i < npoints; b_i++) {
      if (degree > 0) {
        //  Compute 2-norm
        d = us[us.size(1) * b_i];
        r2 = d * d;
        i = us.size(1);
        for (coder::SizeType j{2}; j <= i; j++) {
          d = us[(j + us.size(1) * b_i) - 1];
          r2 += d * d;
        }
        r = std::sqrt(r2);
      } else {
        //  Compute inf-norm for tensor-product
        r = std::abs(us[us.size(1) * b_i]);
        i = us.size(1);
        for (coder::SizeType j{2}; j <= i; j++) {
          r1 = std::abs(us[(j + us.size(1) * b_i) - 1]);
          if (r1 > r) {
            r = r1;
          }
        }
      }
      if (r > rho) {
        ws[b_i] = 0.0;
      } else {
        real_T r_sqrt;
        r /= rho;
        r_sqrt = std::sqrt(r);
        ws[b_i] = r * r *
                      (r * r_sqrt *
                           (r_sqrt * (r_sqrt * 112.0 / 45.0 + -7.0) +
                            5.333333333333333) +
                       -0.93333333333333335) +
                  0.1111111111111111;
      }
    }
  } else {
    m2cAssert(params_pw.size(0) >= npoints,
              "size(params_pw,1) should be >=npoints");
    for (coder::SizeType b_i{0}; b_i < npoints; b_i++) {
      real_T b_gamma;
      b_gamma = params_pw[params_pw.size(1) * b_i];
      if (b_gamma <= 0.0) {
        ws[b_i] = 0.0;
      } else {
        if (degree > 0) {
          //  Compute 2-norm
          d = us[us.size(1) * b_i];
          r2 = d * d;
          i = us.size(1);
          for (coder::SizeType j{2}; j <= i; j++) {
            d = us[(j + us.size(1) * b_i) - 1];
            r2 += d * d;
          }
          r = std::sqrt(r2);
        } else {
          //  Compute inf-norm for tensor-product
          r = std::abs(us[us.size(1) * b_i]);
          i = us.size(1);
          for (coder::SizeType j{2}; j <= i; j++) {
            r1 = std::abs(us[(j + us.size(1) * b_i) - 1]);
            if (r1 > r) {
              r = r1;
            }
          }
        }
        if (r > rho) {
          ws[b_i] = 0.0;
        } else {
          real_T r_sqrt;
          r /= rho;
          r_sqrt = std::sqrt(r);
          ws[b_i] =
              b_gamma * (r * r *
                             (r * r_sqrt *
                                  (r_sqrt * (r_sqrt * 112.0 / 45.0 + -7.0) +
                                   5.333333333333333) +
                              -0.93333333333333335) +
                         0.1111111111111111);
        }
      }
    }
  }
}

//  wls_buhmann_weights  Weights based on Buhmann's radial basis function
static void wls_buhmann_weights(const ::coder::array<real_T, 2U> &us,
                                coder::SizeType npoints, coder::SizeType degree,
                                ::coder::array<real_T, 1U> &ws)
{
  real_T d;
  real_T dist_k;
  real_T r;
  real_T r1;
  real_T r2;
  real_T rho;
  real_T sigma;
  coder::SizeType abs_degree;
  coder::SizeType i;
  if (degree == 0) {
    degree = 2;
  }
  if (degree < 0) {
    abs_degree = 1 - degree;
  } else {
    abs_degree = degree + 1;
  }
  //  Assign default rho
  if (abs_degree - 1 >= 7) {
    sigma = 1.4;
  } else {
    sigma = dv1[abs_degree - 2];
  }
  if (ws.size(0) == 0) {
    ws.set_size(npoints);
  } else {
    m2cAssert(ws.size(0) >= npoints,
              "length of ws cannot be smaller than npoints");
  }
  //  Compute rho to be sigma times the kth distance for k=ceil(1.5*ncoff)
  if (degree >= 0) {
    //  Compute 2-norm
    i = us.size(1);
    for (coder::SizeType b_i{0}; b_i < npoints; b_i++) {
      d = us[us.size(1) * b_i];
      r2 = d * d;
      for (coder::SizeType j{2}; j <= i; j++) {
        d = us[(j + us.size(1) * b_i) - 1];
        r2 += d * d;
      }
      ws[b_i] = std::sqrt(r2);
    }
  } else {
    //  Compute inf-norm for tensor-product
    i = us.size(1);
    for (coder::SizeType b_i{0}; b_i < npoints; b_i++) {
      r = std::abs(us[us.size(1) * b_i]);
      for (coder::SizeType j{2}; j <= i; j++) {
        r1 = std::abs(us[(j + us.size(1) * b_i) - 1]);
        if (r1 > r) {
          r = r1;
        }
      }
      ws[b_i] = r;
    }
  }
  if (us.size(1) == 1) {
    i = abs_degree;
  } else if (us.size(1) == 2) {
    if (degree < 0) {
      i = abs_degree * abs_degree;
    } else {
      i = (abs_degree + 1) * abs_degree / 2;
    }
  } else if (degree < 0) {
    i = abs_degree * abs_degree * abs_degree;
  } else {
    i = (abs_degree + 2) * (abs_degree + 1) * abs_degree / 6;
  }
  dist_k = find_kth_shortest_dist(ws, (i * 3 + 1) / 2, 1, npoints);
  rho = sigma * dist_k;
  for (coder::SizeType b_i{0}; b_i < npoints; b_i++) {
    if (degree > 0) {
      //  Compute 2-norm
      d = us[us.size(1) * b_i];
      r2 = d * d;
      i = us.size(1);
      for (coder::SizeType j{2}; j <= i; j++) {
        d = us[(j + us.size(1) * b_i) - 1];
        r2 += d * d;
      }
      r = std::sqrt(r2);
    } else {
      //  Compute inf-norm for tensor-product
      r = std::abs(us[us.size(1) * b_i]);
      i = us.size(1);
      for (coder::SizeType j{2}; j <= i; j++) {
        r1 = std::abs(us[(j + us.size(1) * b_i) - 1]);
        if (r1 > r) {
          r = r1;
        }
      }
    }
    if (r > rho) {
      ws[b_i] = 0.0;
    } else {
      real_T r_sqrt;
      r /= rho;
      r_sqrt = std::sqrt(r);
      ws[b_i] = r * r *
                    (r * r_sqrt *
                         (r_sqrt * (r_sqrt * 112.0 / 45.0 + -7.0) +
                          5.333333333333333) +
                     -0.93333333333333335) +
                0.1111111111111111;
    }
  }
}

//  wls_eno_weights  WLS-ENO weights based on function values
static void wls_eno_weights(const ::coder::array<real_T, 2U> &us,
                            coder::SizeType npoints, coder::SizeType degree,
                            const ::coder::array<real_T, 2U> &us_unscaled,
                            const ::coder::array<real_T, 1U> &params_sh,
                            const ::coder::array<real_T, 2U> &params_pw,
                            ::coder::array<real_T, 1U> &ws)
{
  real_T alpha;
  real_T b_degree;
  real_T c0;
  real_T c1;
  real_T c1dfg;
  real_T epsilon;
  real_T epsilon_ENO;
  real_T h2bar;
  real_T h2bar_tmp;
  real_T r;
  real_T r1;
  real_T r2;
  real_T safegauard;
  coder::SizeType i;
  m2cAssert(params_sh.size(0) >= 2, "first two shared parameters are required");
  m2cAssert(params_pw.size(0) >= npoints,
            "size(params_pw,1) should be >=npoints");
  m2cAssert(params_pw.size(1) >= 2, "size(params_pw,2) should be >=2");
  if (ws.size(0) == 0) {
    ws.set_size(npoints);
  } else {
    m2cAssert(ws.size(0) >= npoints,
              "length of ws cannot be smaller than npoints");
  }
  //  Compute hbar using ws as buffer space
  if (degree >= 0) {
    //  Compute 2-norm
    i = us_unscaled.size(1);
    for (coder::SizeType b_i{0}; b_i < npoints; b_i++) {
      h2bar_tmp = us_unscaled[us_unscaled.size(1) * b_i];
      r2 = h2bar_tmp * h2bar_tmp;
      for (coder::SizeType j{2}; j <= i; j++) {
        h2bar_tmp = us_unscaled[(j + us_unscaled.size(1) * b_i) - 1];
        r2 += h2bar_tmp * h2bar_tmp;
      }
      ws[b_i] = std::sqrt(r2);
    }
  } else {
    //  Compute inf-norm for tensor-product
    i = us_unscaled.size(1);
    for (coder::SizeType b_i{0}; b_i < npoints; b_i++) {
      r = std::abs(us_unscaled[us_unscaled.size(1) * b_i]);
      for (coder::SizeType j{2}; j <= i; j++) {
        r1 = std::abs(us_unscaled[(j + us_unscaled.size(1) * b_i) - 1]);
        if (r1 > r) {
          r = r1;
        }
      }
      ws[b_i] = r;
    }
  }
  h2bar = ws[0] * ws[0];
  for (coder::SizeType b_i{2}; b_i <= npoints; b_i++) {
    h2bar_tmp = ws[b_i - 1];
    h2bar += h2bar_tmp * h2bar_tmp;
  }
  h2bar /= static_cast<real_T>(npoints);
  //  Evaluate the inverse-distance weights as base
  b_degree = 0.5 - static_cast<real_T>(degree < 0);
  //  use 0.5 or -0.5
  if ((params_sh.size(0) >= 5) && (params_sh[4] != 0.0)) {
    h2bar_tmp = params_sh[4];
  } else {
    h2bar_tmp = 0.01;
  }
  epsilon = 0.01;
  alpha = std::abs(b_degree) / 2.0;
  if (h2bar_tmp != 0.0) {
    epsilon = h2bar_tmp;
  }
  m2cAssert(ws.size(0) >= npoints,
            "length of ws cannot be smaller than npoints");
  for (coder::SizeType b_i{0}; b_i < npoints; b_i++) {
    r = std::abs(us[us.size(1) * b_i]);
    if (us.size(1) > 1) {
      if (b_degree > 0.0) {
        //  Compute 2-norm
        r2 = r * r;
        i = us.size(1);
        for (coder::SizeType c_i{2}; c_i <= i; c_i++) {
          h2bar_tmp = us[(c_i + us.size(1) * b_i) - 1];
          r2 += h2bar_tmp * h2bar_tmp;
        }
      } else {
        //  Compute inf-norm for tensor-product
        i = us.size(1);
        for (coder::SizeType c_i{2}; c_i <= i; c_i++) {
          r1 = std::abs(us[(c_i + us.size(1) * b_i) - 1]);
          if (r1 > r) {
            r = r1;
          }
        }
        r2 = r * r;
      }
    } else {
      r2 = r * r;
    }
    //  Compute weight
    ws[b_i] = std::pow(std::sqrt(r2 + epsilon), -alpha);
  }
  if ((params_sh.size(0) >= 3) && (params_sh[2] != 0.0)) {
    c0 = params_sh[2];
  } else {
    c0 = 1.0;
  }
  if ((params_sh.size(0) >= 4) && (params_sh[3] != 0.0)) {
    c1 = params_sh[3];
  } else {
    c1 = 0.05;
  }
  c1dfg = c1 * params_sh[1];
  if ((params_sh.size(0) >= 6) && (params_sh[5] != 0.0)) {
    epsilon_ENO = params_sh[5];
  } else {
    epsilon_ENO = 0.001;
  }
  safegauard = epsilon_ENO * (params_sh[1] * params_sh[1]) * h2bar;
  if (params_pw.size(1) > 2) {
    for (coder::SizeType b_i{0}; b_i < npoints; b_i++) {
      h2bar_tmp = params_pw[params_pw.size(1) * b_i] - params_sh[0];
      ws[b_i] = ws[b_i] / ((c0 * (h2bar_tmp * h2bar_tmp) +
                            c1dfg * params_pw[params_pw.size(1) * b_i + 1]) +
                           safegauard);
    }
  }
}

//  wls_invdist_weights  Weights based on inverse distance
static void wls_invdist_weights(const ::coder::array<real_T, 2U> &us,
                                coder::SizeType npoints, coder::SizeType degree,
                                const ::coder::array<real_T, 1U> &params_sh,
                                const ::coder::array<real_T, 2U> &params_pw,
                                ::coder::array<real_T, 1U> &ws)
{
  real_T alpha;
  real_T epsilon;
  coder::SizeType b_degree;
  epsilon = 0.01;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  alpha = static_cast<real_T>(b_degree) / 2.0;
  if ((params_sh.size(0) != 0) && (params_sh[0] != 0.0)) {
    epsilon = params_sh[0];
  }
  if ((params_sh.size(0) > 1) && (params_sh[1] != 0.0)) {
    alpha = params_sh[1];
  }
  if (ws.size(0) == 0) {
    ws.set_size(npoints);
  } else {
    m2cAssert(ws.size(0) >= npoints,
              "length of ws cannot be smaller than npoints");
  }
  if ((params_pw.size(0) == 0) || (params_pw.size(1) == 0)) {
    for (coder::SizeType i{0}; i < npoints; i++) {
      real_T r;
      real_T r2;
      r = std::abs(us[us.size(1) * i]);
      if (us.size(1) > 1) {
        if (degree > 0) {
          //  Compute 2-norm
          r2 = r * r;
          b_degree = us.size(1);
          for (coder::SizeType b_i{2}; b_i <= b_degree; b_i++) {
            real_T d;
            d = us[(b_i + us.size(1) * i) - 1];
            r2 += d * d;
          }
        } else {
          //  Compute inf-norm for tensor-product
          b_degree = us.size(1);
          for (coder::SizeType b_i{2}; b_i <= b_degree; b_i++) {
            real_T r1;
            r1 = std::abs(us[(b_i + us.size(1) * i) - 1]);
            if (r1 > r) {
              r = r1;
            }
          }
          r2 = r * r;
        }
      } else {
        r2 = r * r;
      }
      //  Compute weight
      ws[i] = std::pow(std::sqrt(r2 + epsilon), -alpha);
    }
  } else {
    m2cAssert(params_pw.size(0) >= npoints,
              "size(params_pw,1) should be >=npoints");
    for (coder::SizeType i{0}; i < npoints; i++) {
      real_T b_gamma;
      b_gamma = params_pw[params_pw.size(1) * i];
      if (b_gamma <= 0.0) {
        ws[i] = 0.0;
      } else {
        real_T r;
        real_T r2;
        r = std::abs(us[us.size(1) * i]);
        if (us.size(1) > 1) {
          if (degree > 0) {
            //  Compute 2-norm
            r2 = r * r;
            b_degree = us.size(1);
            for (coder::SizeType b_i{2}; b_i <= b_degree; b_i++) {
              real_T d;
              d = us[(b_i + us.size(1) * i) - 1];
              r2 += d * d;
            }
          } else {
            //  Compute inf-norm for tensor-product
            b_degree = us.size(1);
            for (coder::SizeType b_i{2}; b_i <= b_degree; b_i++) {
              real_T r1;
              r1 = std::abs(us[(b_i + us.size(1) * i) - 1]);
              if (r1 > r) {
                r = r1;
              }
            }
            r2 = r * r;
          }
        } else {
          r2 = r * r;
        }
        //  Compute weight
        ws[i] = b_gamma * std::pow(std::sqrt(r2 + epsilon), -alpha);
      }
    }
  }
}

//  wls_invdist_weights  Weights based on inverse distance
static void wls_invdist_weights(const ::coder::array<real_T, 2U> &us,
                                coder::SizeType npoints, coder::SizeType degree,
                                ::coder::array<real_T, 1U> &ws)
{
  real_T alpha;
  coder::SizeType b_degree;
  if (degree < 0) {
    b_degree = -degree;
  } else {
    b_degree = degree;
  }
  alpha = static_cast<real_T>(b_degree) / 2.0;
  if (ws.size(0) == 0) {
    ws.set_size(npoints);
  } else {
    m2cAssert(ws.size(0) >= npoints,
              "length of ws cannot be smaller than npoints");
  }
  for (coder::SizeType i{0}; i < npoints; i++) {
    real_T r;
    real_T r2;
    r = std::abs(us[us.size(1) * i]);
    if (us.size(1) > 1) {
      if (degree > 0) {
        //  Compute 2-norm
        r2 = r * r;
        b_degree = us.size(1);
        for (coder::SizeType b_i{2}; b_i <= b_degree; b_i++) {
          real_T d;
          d = us[(b_i + us.size(1) * i) - 1];
          r2 += d * d;
        }
      } else {
        //  Compute inf-norm for tensor-product
        b_degree = us.size(1);
        for (coder::SizeType b_i{2}; b_i <= b_degree; b_i++) {
          real_T r1;
          r1 = std::abs(us[(b_i + us.size(1) * i) - 1]);
          if (r1 > r) {
            r = r1;
          }
        }
        r2 = r * r;
      }
    } else {
      r2 = r * r;
    }
    //  Compute weight
    ws[i] = std::pow(std::sqrt(r2 + 0.01), -alpha);
  }
}

//  wls_resize  Reinitialize the buffers of WlsObject
static void wls_resize(WlsObject *b_wls, coder::SizeType dim,
                       coder::SizeType nstpnts, coder::SizeType degree,
                       coder::SizeType order, boolean_T use_dag)
{
  coder::SizeType b_degree;
  coder::SizeType ncols;
  coder::SizeType nrows;
  coder::SizeType stride;
  coder::SizeType unnamed_idx_0;
  b_wls->degree = degree;
  b_wls->order = order;
  b_wls->use_dag = use_dag;
  //  make stride a multiple of four
  stride = ((nstpnts + 3) / 4) << 2;
  b_wls->stride = stride;
  if (order == 0) {
    nrows = stride;
  } else if (order == 1) {
    nrows = (dim + 1) * stride;
  } else {
    coder::SizeType nrblks;
    switch (dim) {
    case 1:
      nrblks = order + 1;
      break;
    case 2:
      nrblks = (order + 1) * (order + 2) / 2;
      break;
    default:
      m2cAssert(dim >= 1, "Dimension must be 1, 2, or 3.");
      nrblks = (order + 1) * (order + 2) * (order + 3) / 6;
      break;
    }
    nrows = nrblks * stride;
  }
  b_wls->us.set_size(stride, dim);
  b_wls->rweights.set_size(stride);
  b_wls->nstpnts = nstpnts;
  //  determine number of columns and allocate V and QR
  switch (dim) {
  case 1:
    if (degree < 0) {
      b_degree = -degree;
    } else {
      b_degree = degree;
    }
    ncols = b_degree + 1;
    break;
  case 2:
    if (degree > 0) {
      ncols = (degree + 1) * (degree + 2) / 2;
    } else {
      ncols = (1 - degree) * (1 - degree);
    }
    break;
  default:
    m2cAssert(dim >= 1, "Dimension must be 1, 2, or 3.");
    if (degree > 0) {
      ncols = (degree + 1) * (degree + 2) * (degree + 3) / 6;
    } else {
      ncols = (1 - degree) * (1 - degree) * (1 - degree);
    }
    break;
  }
  b_wls->hs_inv.size[1] = dim;
  b_wls->hs_inv.size[0] = 1;
  if (use_dag) {
    if ((dim != b_wls->dag.size(1)) || (ncols + 1 != b_wls->dag.size(0))) {
      //  Reset DAG if dimension or degree has changed.
      b_wls->dag.set_size(ncols + 1, dim);
      unnamed_idx_0 = b_wls->dag.size(1) * b_wls->dag.size(0) - 1;
      b_degree = b_wls->dag.size(0);
      b_wls->dag[unnamed_idx_0 % b_degree * b_wls->dag.size(1) +
                 unnamed_idx_0 / b_degree] = MAX_uint8_T;
    }
  } else {
    b_wls->dag.set_size(0, dim);
  }
  b_wls->jpvt.set_size(ncols);
  //  V is always full, but QR has one fewer row and column in interp0 mode
  b_wls->V.set_size(ncols, nrows);
  unnamed_idx_0 = (ncols - b_wls->interp0) + 1;
  b_wls->QR.set_size(unnamed_idx_0, nrows);
  b_wls->rank = 0;
  //  work space
  b_degree = ncols << 2;
  unnamed_idx_0 = ncols + 1;
  if (nrows >= unnamed_idx_0) {
    unnamed_idx_0 = nrows;
  }
  if (b_degree < 4160) {
    b_degree = 4160;
  }
  b_wls->work.set_size((unnamed_idx_0 << 5) + b_degree);
}

// wls_eval_ops - Evaluate the operator with given function values
void wls_eval_ops(const WlsObject *b_wls,
                  const ::coder::array<int8_T, 2U> &vdops,
                  const ::coder::array<real_T, 2U> &fs,
                  ::coder::array<real_T, 2U> &result)
{
  coder::SizeType nOps;
  nOps = vdops.size(1);
  if ((fs.size(0) == 0) || (fs.size(1) == 0)) {
    result.set_size(0, 1);
  } else {
    coder::SizeType i;
    coder::SizeType loop_ub;
    result.set_size(vdops.size(1), fs.size(1));
    loop_ub = fs.size(1) * vdops.size(1);
    for (i = 0; i < loop_ub; i++) {
      result[i] = 0.0;
    }
    //  Compute solution
    i = fs.size(1);
    for (coder::SizeType iFunc{0}; iFunc < i; iFunc++) {
      coder::SizeType iOp;
      iOp = 0;
      for (coder::SizeType iDiff{0}; iDiff < nOps; iDiff++) {
        loop_ub = b_wls->nrows;
        for (coder::SizeType iRow{0}; iRow < loop_ub; iRow++) {
          result[iFunc + result.size(1) * iOp] = static_cast<int8_T>(
              (result[iFunc + result.size(1) * iOp]) +
              static_cast<int8_T>(std::round(
                  fs[iFunc + fs.size(1) * iRow] *
                  static_cast<real_T>(vdops[iDiff + vdops.size(1) * iRow]))));
        }
        if (iOp + 1 == result.size(0)) {
          iOp = 0;
        } else {
          iOp++;
        }
      }
    }
  }
}

// wls_eval_ops - Evaluate the operator with given function values
void wls_eval_ops(const WlsObject *b_wls,
                  const ::coder::array<int8_T, 2U> &vdops,
                  const ::coder::array<real_T, 2U> &fs, boolean_T isdiv,
                  ::coder::array<real_T, 2U> &result)
{
  coder::SizeType nOps;
  nOps = vdops.size(1) - 1;
  if ((fs.size(0) == 0) || (fs.size(1) == 0)) {
    result.set_size(0, 1);
  } else if (isdiv) {
    coder::SizeType i;
    coder::SizeType iFunc;
    coder::SizeType iOp;
    coder::SizeType loop_ub;
    loop_ub = vdops.size(1) / b_wls->us.size(1);
    result.set_size(loop_ub, 1);
    for (i = 0; i < loop_ub; i++) {
      result[i] = 0.0;
    }
    //  Compute solution
    iFunc = 1;
    iOp = 0;
    for (coder::SizeType iDiff{0}; iDiff <= nOps; iDiff++) {
      i = b_wls->nrows;
      for (coder::SizeType iRow{0}; iRow < i; iRow++) {
        result[iOp % result.size(0) + iOp / result.size(0)] =
            static_cast<int8_T>(
                (result[iOp % result.size(0) + iOp / result.size(0)]) +
                static_cast<int8_T>(std::round(
                    fs[(iFunc + fs.size(1) * iRow) - 1] *
                    static_cast<real_T>(vdops[iDiff + vdops.size(1) * iRow]))));
      }
      if (iOp + 1 == result.size(0)) {
        iOp = 0;
      } else {
        iOp++;
      }
      if (iFunc == fs.size(1)) {
        iFunc = 1;
      } else {
        iFunc++;
      }
    }
  } else {
    coder::SizeType i;
    coder::SizeType loop_ub;
    result.set_size(vdops.size(1), fs.size(1));
    loop_ub = fs.size(1) * vdops.size(1);
    for (i = 0; i < loop_ub; i++) {
      result[i] = 0.0;
    }
    //  Compute solution
    i = fs.size(1);
    for (coder::SizeType iFunc{0}; iFunc < i; iFunc++) {
      coder::SizeType iOp;
      iOp = 0;
      for (coder::SizeType iDiff{0}; iDiff <= nOps; iDiff++) {
        loop_ub = b_wls->nrows;
        for (coder::SizeType iRow{0}; iRow < loop_ub; iRow++) {
          result[iFunc + result.size(1) * iOp] = static_cast<int8_T>(
              (result[iFunc + result.size(1) * iOp]) +
              static_cast<int8_T>(std::round(
                  fs[iFunc + fs.size(1) * iRow] *
                  static_cast<real_T>(vdops[iDiff + vdops.size(1) * iRow]))));
        }
        if (iOp + 1 == result.size(0)) {
          iOp = 0;
        } else {
          iOp++;
        }
      }
    }
  }
}

//  wls_func - Evaluate wls-fitting at one or more points.
void wls_func(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
              const ::coder::array<real_T, 2U> &fs, coder::SizeType nevpnts,
              ::coder::array<real_T, 2U> &vdops,
              ::coder::array<real_T, 2U> &result)
{
  coder::SizeType b_nevpnts;
  coder::SizeType i;
  coder::SizeType i1;
  coder::SizeType j;
  coder::SizeType loop_ub;
  coder::SizeType nDims;
  coder::SizeType nOps;
  coder::SizeType nRhs;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, b_nevpnts, b_wls->degree, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  b_wls->rhs.set_size(b_nevpnts, u1 - b_wls->interp0);
  //  Omit zeros in the diff operators
  i = b_wls->ncols - b_wls->interp0;
  for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
    j = b_wls->jpvt[iMonomial] + b_wls->interp0;
    //  Do not sum if nargin<3
    for (coder::SizeType iEval{0}; iEval < b_nevpnts; iEval++) {
      b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iEval] =
          b_wls->V[iEval + b_wls->V.size(1) * (j - 1)];
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (i1 = 0; i1 < u0; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  vdops.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    for (j = 0; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      i = b_wls->nstpnts;
      for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      vdops[j] = 1.0 - s;
    }
  }
  //  Step 4: Optionally, evaluate the operator
  nOps = vdops.size(1);
  if ((fs.size(0) == 0) || (fs.size(1) == 0)) {
    result.set_size(0, 1);
  } else {
    result.set_size(vdops.size(1), fs.size(1));
    loop_ub = fs.size(1) * vdops.size(1);
    for (i = 0; i < loop_ub; i++) {
      result[i] = 0.0;
    }
    //  Compute solution
    i = fs.size(1);
    for (coder::SizeType iFunc{0}; iFunc < i; iFunc++) {
      coder::SizeType iOp;
      iOp = 0;
      for (coder::SizeType iDiff{0}; iDiff < nOps; iDiff++) {
        i1 = b_wls->nrows;
        for (coder::SizeType iRow{0}; iRow < i1; iRow++) {
          result[iFunc + result.size(1) * iOp] =
              result[iFunc + result.size(1) * iOp] +
              fs[iFunc + fs.size(1) * iRow] *
                  vdops[iDiff + vdops.size(1) * iRow];
        }
        if (iOp + 1 == result.size(0)) {
          iOp = 0;
        } else {
          iOp++;
        }
      }
    }
  }
}

//  wls_func - Evaluate wls-fitting at one or more points.
void wls_func(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
              const ::coder::array<real_T, 2U> &fs,
              ::coder::array<real_T, 2U> &vdops,
              ::coder::array<real_T, 2U> &result)
{
  coder::SizeType i;
  coder::SizeType i1;
  coder::SizeType j;
  coder::SizeType loop_ub;
  coder::SizeType nDims;
  coder::SizeType nOps;
  coder::SizeType nRhs;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  nevpnts = eval_pnts.size(0);
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  b_wls->rhs.set_size(eval_pnts.size(0), u1 - b_wls->interp0);
  //  Omit zeros in the diff operators
  i = b_wls->ncols - b_wls->interp0;
  for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
    j = b_wls->jpvt[iMonomial] + b_wls->interp0;
    //  Do not sum if nargin<3
    for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
      b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iEval] =
          b_wls->V[iEval + b_wls->V.size(1) * (j - 1)];
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (i1 = 0; i1 < u0; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  vdops.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    for (j = 0; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      i = b_wls->nstpnts;
      for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      vdops[j] = 1.0 - s;
    }
  }
  //  Step 4: Optionally, evaluate the operator
  nOps = vdops.size(1);
  if ((fs.size(0) == 0) || (fs.size(1) == 0)) {
    result.set_size(0, 1);
  } else {
    result.set_size(vdops.size(1), fs.size(1));
    loop_ub = fs.size(1) * vdops.size(1);
    for (i = 0; i < loop_ub; i++) {
      result[i] = 0.0;
    }
    //  Compute solution
    i = fs.size(1);
    for (coder::SizeType iFunc{0}; iFunc < i; iFunc++) {
      coder::SizeType iOp;
      iOp = 0;
      for (coder::SizeType iDiff{0}; iDiff < nOps; iDiff++) {
        i1 = b_wls->nrows;
        for (coder::SizeType iRow{0}; iRow < i1; iRow++) {
          result[iFunc + result.size(1) * iOp] =
              result[iFunc + result.size(1) * iOp] +
              fs[iFunc + fs.size(1) * iRow] *
                  vdops[iDiff + vdops.size(1) * iRow];
        }
        if (iOp + 1 == result.size(0)) {
          iOp = 0;
        } else {
          iOp++;
        }
      }
    }
  }
}

//  wls_func - Evaluate wls-fitting at one or more points.
void wls_func(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
              ::coder::array<real_T, 2U> &vdops)
{
  coder::SizeType i;
  coder::SizeType j;
  coder::SizeType nDims;
  coder::SizeType nRhs;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  nevpnts = eval_pnts.size(0);
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  b_wls->rhs.set_size(eval_pnts.size(0), u1 - b_wls->interp0);
  //  Omit zeros in the diff operators
  i = b_wls->ncols - b_wls->interp0;
  for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
    j = b_wls->jpvt[iMonomial] + b_wls->interp0;
    //  Do not sum if nargin<3
    for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
      b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iEval] =
          b_wls->V[iEval + b_wls->V.size(1) * (j - 1)];
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    u0 = b_wls->QR.size(1);
    for (i = 0; i < u0; i++) {
      coder::SizeType loop_ub;
      loop_ub = b_wls->QR.size(0);
      for (coder::SizeType i1{0}; i1 < loop_ub; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  vdops.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    for (j = 0; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      i = b_wls->nstpnts;
      for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      vdops[j] = 1.0 - s;
    }
  }
}

//  wls_init  Initialize WlsObject in 1D, 2D, or 3D.
void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const WlsWeight *weight, coder::SizeType degree,
              coder::SizeType order, coder::SizeType interp0, boolean_T use_dag,
              coder::SizeType nstpnts)
{
  coder::SizeType dim;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  b_wls->interp0 = interp0 != 0;
  interp0 = b_wls->interp0;
  b_wls->use_dag = use_dag;
  if (nstpnts <= 0) {
    nstpnts = us.size(0);
  } else {
    m2cAssert(
        nstpnts <= us.size(0),
        "Number of points cannot be greater than the first dimension of `us`.");
  }
  //  Resize buffers
  wls_resize(b_wls, us.size(1), nstpnts, degree, order, use_dag);
  if (nstpnts != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    coder::SizeType b_us;
    coder::SizeType i;
    coder::SizeType ncols;
    coder::SizeType nrblks;
    coder::SizeType src;
    coder::SizeType trg;
    coder::SizeType u1;
    //  Recompute DAG if use_dag and its signature does not match
    if (use_dag) {
      i = b_wls->dag.size(1) * b_wls->dag.size(0) - 1;
      b_us = b_wls->dag.size(0);
      if (b_wls->dag[i % b_us * b_wls->dag.size(1) + i / b_us] !=
          degree + 127) {
        switch (us.size(1)) {
        case 1:
          gen_vander_1d_dag(degree, b_wls->dag);
          break;
        case 2:
          gen_vander_2d_dag(degree, b_wls->dag);
          break;
        default:
          gen_vander_3d_dag(degree, b_wls->dag);
          break;
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b = true;
        b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            u1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > u1) {
                b_us -= u1;
              }
            }
          }
          u1 = b_wls->us.size(0);
          b_wls->us[b_i % u1 * b_wls->us.size(1) + b_i / u1] = us[b_us] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        b_wls->origin.data[2] = us[2];
        for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              us[us.size(1) * b_i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b = true;
        b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            u1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > u1) {
                b_us -= u1;
              }
            }
          }
          u1 = b_wls->us.size(0);
          b_wls->us[b_i % u1 * b_wls->us.size(1) + b_i / u1] = us[b_us];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        b_wls->origin.data[2] = 0.0;
        for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] = us[us.size(1) * b_i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
        i = b_wls->us.size(0);
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i]));
      }
      break;
    case 2:
      for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])));
      }
      break;
    default:
      for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(
                std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                          std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])),
                std::abs(b_wls->us[b_wls->us.size(1) * b_i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (coder::SizeType b_i{0}; b_i <= dim; b_i++) {
      b_wls->hs_inv.data[b_i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
          i = b_wls->us.size(0);
          b_us = b_wls->us.size(0);
          b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i] =
              b_wls->us[b_i % b_us * b_wls->us.size(1) + b_i / b_us] * maxx_inv;
        }
        break;
      case 2:
        for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
        }
        break;
      default:
        for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              b_wls->us[b_wls->us.size(1) * b_i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight->name.size(1) == 0) || (weight->name[0] == 'U')) &&
        (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight->name.size(1) == 0) || (weight->name[0] == 'U')) {
        //  unit weights
        b_us = b_wls->rweights.size(0);
        b_wls->rweights.set_size(b_us);
        for (i = 0; i < b_us; i++) {
          b_wls->rweights[i] = 1.0;
        }
      } else if ((weight->name[0] == 'I') || (weight->name[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, nstpnts, degree, weight->params_shared,
                            weight->params_pointwise, b_wls->rweights);
      } else if ((weight->name[0] == 'B') || (weight->name[0] == 'b')) {
        //  Buhmann weights. All points share same parameters
        wls_buhmann_weights(b_wls->us, nstpnts, degree, weight->params_shared,
                            weight->params_pointwise, b_wls->rweights);
      } else {
        if ((weight->name[0] != 'E') && (weight->name[0] != 'e')) {
          m2cErrMsgIdAndTxt(
              "wlslib:WrongWeightName",
              "Weighting scheme must be Unit, InvDist, Buhmann, or ENO.");
        }
        //  WLS-ENO
        wls_eno_weights(b_wls->us, nstpnts, degree, us, weight->params_shared,
                        weight->params_pointwise, b_wls->rweights);
      }
    }
    //  Compute Vandermonde system and recompute DAG if needed
    gen_vander(b_wls->us, nstpnts, degree, order, b_wls->rweights, b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (nstpnts != b_wls->stride) &&
        (nstpnts != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = nstpnts;
      for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
          i = b_wls->V.size(0);
          for (coder::SizeType j{0}; j < i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    b_wls->nrows = nrblks * nstpnts;
    b_wls->ncols = ncols;
    //  Omit rows in CVM if needed
    b_us = weight->omit_rows.size(0);
    u1 = b_wls->nrows;
    if (b_us <= u1) {
      u1 = b_us;
    }
    for (coder::SizeType b_i{0}; b_i < u1; b_i++) {
      if (weight->omit_rows[b_i]) {
        b_us = b_wls->V.size(0);
        for (i = 0; i < b_us; i++) {
          b_wls->V[b_i + b_wls->V.size(1) * i] = 0.0;
        }
      }
    }
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (coder::SizeType j{0}; j < nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          i = us.size(1) + 2;
          for (coder::SizeType blk{i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (coder::SizeType j{0}; j < nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        gen_vander(b_wls->hs_inv.data, b_wls->hs_inv.size, order, b_wls->V);
        for (coder::SizeType blk{2}; blk <= nrblks; blk++) {
          coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (coder::SizeType j{0}; j < nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (nstpnts != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = nstpnts;
        for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
            b_wls->rweights[trg + b_i] = b_wls->rweights[src + b_i];
          }
          trg += nstpnts;
        }
      }
    }
  }
}

void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const ::coder::array<char_T, 2U> &weight, coder::SizeType degree)
{
  coder::SizeType dim;
  coder::SizeType interp0;
  coder::SizeType nstpnts;
  coder::SizeType order;
  boolean_T use_dag;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  order = b_wls->order;
  interp0 = b_wls->interp0;
  use_dag = b_wls->use_dag;
  nstpnts = us.size(0) - 1;
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), degree, b_wls->order,
             b_wls->use_dag);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    coder::SizeType b_us;
    coder::SizeType i;
    coder::SizeType ncols;
    coder::SizeType nrblks;
    coder::SizeType src;
    coder::SizeType trg;
    //  Recompute DAG if use_dag and its signature does not match
    if (use_dag) {
      i = b_wls->dag.size(1) * b_wls->dag.size(0) - 1;
      b_us = b_wls->dag.size(0);
      if (b_wls->dag[i % b_us * b_wls->dag.size(1) + i / b_us] !=
          degree + 127) {
        switch (us.size(1)) {
        case 1:
          gen_vander_1d_dag(degree, b_wls->dag);
          break;
        case 2:
          gen_vander_2d_dag(degree, b_wls->dag);
          break;
        default:
          gen_vander_3d_dag(degree, b_wls->dag);
          break;
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          coder::SizeType i1;
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[b_i % i1 * b_wls->us.size(1) + b_i / i1] = us[b_us] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        b_wls->origin.data[2] = us[2];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              us[us.size(1) * b_i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          coder::SizeType i1;
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[b_i % i1 * b_wls->us.size(1) + b_i / i1] = us[b_us];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        b_wls->origin.data[2] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] = us[us.size(1) * b_i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        i = b_wls->us.size(0);
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i]));
      }
      break;
    case 2:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])));
      }
      break;
    default:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(
                std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                          std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])),
                std::abs(b_wls->us[b_wls->us.size(1) * b_i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (coder::SizeType b_i{0}; b_i <= dim; b_i++) {
      b_wls->hs_inv.data[b_i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->us.size(0);
          b_us = b_wls->us.size(0);
          b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i] =
              b_wls->us[b_i % b_us * b_wls->us.size(1) + b_i / b_us] * maxx_inv;
        }
        break;
      case 2:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
        }
        break;
      default:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              b_wls->us[b_wls->us.size(1) * b_i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight.size(1) == 0) || (weight[0] == 'U')) && (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight.size(1) == 0) || (weight[0] == 'U')) {
        //  unit weights
        b_us = b_wls->rweights.size(0);
        b_wls->rweights.set_size(b_us);
        for (i = 0; i < b_us; i++) {
          b_wls->rweights[i] = 1.0;
        }
      } else if ((weight[0] == 'I') || (weight[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree, b_wls->rweights);
      } else {
        if ((weight[0] != 'B') && (weight[0] != 'b')) {
          m2cErrMsgIdAndTxt("wlslib:WrongWeightName",
                            "When using a character string, weighting scheme "
                            "must be Unit, InvDist, or Buhmann.");
        }
        //  Buhmann weights with default parameters
        wls_buhmann_weights(b_wls->us, us.size(0), degree, b_wls->rweights);
      }
    }
    //  Compute Vandermonde system and recompute DAG if needed
    gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->V.size(0);
          for (coder::SizeType j{0}; j < i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Omit rows in CVM if needed
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          i = us.size(1) + 2;
          for (coder::SizeType blk{i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        gen_vander(b_wls->hs_inv.data, b_wls->hs_inv.size, order, b_wls->V);
        for (coder::SizeType blk{2}; blk <= nrblks; blk++) {
          coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
            b_wls->rweights[trg + b_i] = b_wls->rweights[src + b_i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
  }
}

void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const ::coder::array<char_T, 2U> &weight, coder::SizeType degree,
              coder::SizeType order)
{
  coder::SizeType dim;
  coder::SizeType interp0;
  coder::SizeType nstpnts;
  boolean_T use_dag;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  interp0 = b_wls->interp0;
  use_dag = b_wls->use_dag;
  nstpnts = us.size(0) - 1;
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), degree, order, b_wls->use_dag);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    coder::SizeType b_us;
    coder::SizeType i;
    coder::SizeType ncols;
    coder::SizeType nrblks;
    coder::SizeType src;
    coder::SizeType trg;
    //  Recompute DAG if use_dag and its signature does not match
    if (use_dag) {
      i = b_wls->dag.size(1) * b_wls->dag.size(0) - 1;
      b_us = b_wls->dag.size(0);
      if (b_wls->dag[i % b_us * b_wls->dag.size(1) + i / b_us] !=
          degree + 127) {
        switch (us.size(1)) {
        case 1:
          gen_vander_1d_dag(degree, b_wls->dag);
          break;
        case 2:
          gen_vander_2d_dag(degree, b_wls->dag);
          break;
        default:
          gen_vander_3d_dag(degree, b_wls->dag);
          break;
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          coder::SizeType i1;
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[b_i % i1 * b_wls->us.size(1) + b_i / i1] = us[b_us] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        b_wls->origin.data[2] = us[2];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              us[us.size(1) * b_i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          coder::SizeType i1;
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[b_i % i1 * b_wls->us.size(1) + b_i / i1] = us[b_us];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        b_wls->origin.data[2] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] = us[us.size(1) * b_i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        i = b_wls->us.size(0);
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i]));
      }
      break;
    case 2:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])));
      }
      break;
    default:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(
                std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                          std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])),
                std::abs(b_wls->us[b_wls->us.size(1) * b_i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (coder::SizeType b_i{0}; b_i <= dim; b_i++) {
      b_wls->hs_inv.data[b_i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->us.size(0);
          b_us = b_wls->us.size(0);
          b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i] =
              b_wls->us[b_i % b_us * b_wls->us.size(1) + b_i / b_us] * maxx_inv;
        }
        break;
      case 2:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
        }
        break;
      default:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              b_wls->us[b_wls->us.size(1) * b_i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight.size(1) == 0) || (weight[0] == 'U')) && (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight.size(1) == 0) || (weight[0] == 'U')) {
        //  unit weights
        b_us = b_wls->rweights.size(0);
        b_wls->rweights.set_size(b_us);
        for (i = 0; i < b_us; i++) {
          b_wls->rweights[i] = 1.0;
        }
      } else if ((weight[0] == 'I') || (weight[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree, b_wls->rweights);
      } else {
        if ((weight[0] != 'B') && (weight[0] != 'b')) {
          m2cErrMsgIdAndTxt("wlslib:WrongWeightName",
                            "When using a character string, weighting scheme "
                            "must be Unit, InvDist, or Buhmann.");
        }
        //  Buhmann weights with default parameters
        wls_buhmann_weights(b_wls->us, us.size(0), degree, b_wls->rweights);
      }
    }
    //  Compute Vandermonde system and recompute DAG if needed
    gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->V.size(0);
          for (coder::SizeType j{0}; j < i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Omit rows in CVM if needed
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          i = us.size(1) + 2;
          for (coder::SizeType blk{i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        gen_vander(b_wls->hs_inv.data, b_wls->hs_inv.size, order, b_wls->V);
        for (coder::SizeType blk{2}; blk <= nrblks; blk++) {
          coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
            b_wls->rweights[trg + b_i] = b_wls->rweights[src + b_i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
  }
}

void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const ::coder::array<char_T, 2U> &weight, coder::SizeType degree,
              coder::SizeType order, coder::SizeType interp0)
{
  coder::SizeType dim;
  coder::SizeType nstpnts;
  boolean_T use_dag;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  b_wls->interp0 = interp0 != 0;
  interp0 = b_wls->interp0;
  use_dag = b_wls->use_dag;
  nstpnts = us.size(0) - 1;
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), degree, order, b_wls->use_dag);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    coder::SizeType b_us;
    coder::SizeType i;
    coder::SizeType ncols;
    coder::SizeType nrblks;
    coder::SizeType src;
    coder::SizeType trg;
    //  Recompute DAG if use_dag and its signature does not match
    if (use_dag) {
      i = b_wls->dag.size(1) * b_wls->dag.size(0) - 1;
      b_us = b_wls->dag.size(0);
      if (b_wls->dag[i % b_us * b_wls->dag.size(1) + i / b_us] !=
          degree + 127) {
        switch (us.size(1)) {
        case 1:
          gen_vander_1d_dag(degree, b_wls->dag);
          break;
        case 2:
          gen_vander_2d_dag(degree, b_wls->dag);
          break;
        default:
          gen_vander_3d_dag(degree, b_wls->dag);
          break;
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          coder::SizeType i1;
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[b_i % i1 * b_wls->us.size(1) + b_i / i1] = us[b_us] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        b_wls->origin.data[2] = us[2];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              us[us.size(1) * b_i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          coder::SizeType i1;
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[b_i % i1 * b_wls->us.size(1) + b_i / i1] = us[b_us];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        b_wls->origin.data[2] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] = us[us.size(1) * b_i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        i = b_wls->us.size(0);
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i]));
      }
      break;
    case 2:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])));
      }
      break;
    default:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(
                std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                          std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])),
                std::abs(b_wls->us[b_wls->us.size(1) * b_i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (coder::SizeType b_i{0}; b_i <= dim; b_i++) {
      b_wls->hs_inv.data[b_i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->us.size(0);
          b_us = b_wls->us.size(0);
          b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i] =
              b_wls->us[b_i % b_us * b_wls->us.size(1) + b_i / b_us] * maxx_inv;
        }
        break;
      case 2:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
        }
        break;
      default:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              b_wls->us[b_wls->us.size(1) * b_i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight.size(1) == 0) || (weight[0] == 'U')) && (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight.size(1) == 0) || (weight[0] == 'U')) {
        //  unit weights
        b_us = b_wls->rweights.size(0);
        b_wls->rweights.set_size(b_us);
        for (i = 0; i < b_us; i++) {
          b_wls->rweights[i] = 1.0;
        }
      } else if ((weight[0] == 'I') || (weight[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree, b_wls->rweights);
      } else {
        if ((weight[0] != 'B') && (weight[0] != 'b')) {
          m2cErrMsgIdAndTxt("wlslib:WrongWeightName",
                            "When using a character string, weighting scheme "
                            "must be Unit, InvDist, or Buhmann.");
        }
        //  Buhmann weights with default parameters
        wls_buhmann_weights(b_wls->us, us.size(0), degree, b_wls->rweights);
      }
    }
    //  Compute Vandermonde system and recompute DAG if needed
    gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->V.size(0);
          for (coder::SizeType j{0}; j < i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Omit rows in CVM if needed
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          i = us.size(1) + 2;
          for (coder::SizeType blk{i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        gen_vander(b_wls->hs_inv.data, b_wls->hs_inv.size, order, b_wls->V);
        for (coder::SizeType blk{2}; blk <= nrblks; blk++) {
          coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
            b_wls->rweights[trg + b_i] = b_wls->rweights[src + b_i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
  }
}

void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const ::coder::array<char_T, 2U> &weight, coder::SizeType degree,
              coder::SizeType order, coder::SizeType interp0, boolean_T use_dag)
{
  coder::SizeType dim;
  coder::SizeType nstpnts;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  b_wls->interp0 = interp0 != 0;
  interp0 = b_wls->interp0;
  b_wls->use_dag = use_dag;
  nstpnts = us.size(0) - 1;
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), degree, order, use_dag);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    coder::SizeType b_us;
    coder::SizeType i;
    coder::SizeType ncols;
    coder::SizeType nrblks;
    coder::SizeType src;
    coder::SizeType trg;
    //  Recompute DAG if use_dag and its signature does not match
    if (use_dag) {
      i = b_wls->dag.size(1) * b_wls->dag.size(0) - 1;
      b_us = b_wls->dag.size(0);
      if (b_wls->dag[i % b_us * b_wls->dag.size(1) + i / b_us] !=
          degree + 127) {
        switch (us.size(1)) {
        case 1:
          gen_vander_1d_dag(degree, b_wls->dag);
          break;
        case 2:
          gen_vander_2d_dag(degree, b_wls->dag);
          break;
        default:
          gen_vander_3d_dag(degree, b_wls->dag);
          break;
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          coder::SizeType i1;
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[b_i % i1 * b_wls->us.size(1) + b_i / i1] = us[b_us] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        b_wls->origin.data[2] = us[2];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              us[us.size(1) * b_i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          coder::SizeType i1;
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[b_i % i1 * b_wls->us.size(1) + b_i / i1] = us[b_us];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        b_wls->origin.data[2] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] = us[us.size(1) * b_i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        i = b_wls->us.size(0);
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i]));
      }
      break;
    case 2:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])));
      }
      break;
    default:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(
                std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                          std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])),
                std::abs(b_wls->us[b_wls->us.size(1) * b_i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (coder::SizeType b_i{0}; b_i <= dim; b_i++) {
      b_wls->hs_inv.data[b_i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->us.size(0);
          b_us = b_wls->us.size(0);
          b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i] =
              b_wls->us[b_i % b_us * b_wls->us.size(1) + b_i / b_us] * maxx_inv;
        }
        break;
      case 2:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
        }
        break;
      default:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              b_wls->us[b_wls->us.size(1) * b_i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight.size(1) == 0) || (weight[0] == 'U')) && (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight.size(1) == 0) || (weight[0] == 'U')) {
        //  unit weights
        b_us = b_wls->rweights.size(0);
        b_wls->rweights.set_size(b_us);
        for (i = 0; i < b_us; i++) {
          b_wls->rweights[i] = 1.0;
        }
      } else if ((weight[0] == 'I') || (weight[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree, b_wls->rweights);
      } else {
        if ((weight[0] != 'B') && (weight[0] != 'b')) {
          m2cErrMsgIdAndTxt("wlslib:WrongWeightName",
                            "When using a character string, weighting scheme "
                            "must be Unit, InvDist, or Buhmann.");
        }
        //  Buhmann weights with default parameters
        wls_buhmann_weights(b_wls->us, us.size(0), degree, b_wls->rweights);
      }
    }
    //  Compute Vandermonde system and recompute DAG if needed
    gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->V.size(0);
          for (coder::SizeType j{0}; j < i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Omit rows in CVM if needed
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          i = us.size(1) + 2;
          for (coder::SizeType blk{i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        gen_vander(b_wls->hs_inv.data, b_wls->hs_inv.size, order, b_wls->V);
        for (coder::SizeType blk{2}; blk <= nrblks; blk++) {
          coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
            b_wls->rweights[trg + b_i] = b_wls->rweights[src + b_i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
  }
}

//  wls_init  Initialize WlsObject in 1D, 2D, or 3D.
void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us)
{
  coder::SizeType degree;
  coder::SizeType dim;
  coder::SizeType interp0;
  coder::SizeType nstpnts;
  coder::SizeType order;
  boolean_T use_dag;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  //  Default is to use unit weight
  degree = b_wls->degree;
  order = b_wls->order;
  interp0 = b_wls->interp0;
  use_dag = b_wls->use_dag;
  nstpnts = us.size(0) - 1;
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), b_wls->degree, b_wls->order,
             b_wls->use_dag);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    coder::SizeType b_us;
    coder::SizeType i;
    coder::SizeType ncols;
    coder::SizeType nrblks;
    coder::SizeType src;
    coder::SizeType trg;
    //  Recompute DAG if use_dag and its signature does not match
    if (use_dag) {
      i = b_wls->dag.size(1) * b_wls->dag.size(0) - 1;
      b_us = b_wls->dag.size(0);
      if (b_wls->dag[i % b_us * b_wls->dag.size(1) + i / b_us] !=
          degree + 127) {
        switch (us.size(1)) {
        case 1:
          gen_vander_1d_dag(degree, b_wls->dag);
          break;
        case 2:
          gen_vander_2d_dag(degree, b_wls->dag);
          break;
        default:
          gen_vander_3d_dag(degree, b_wls->dag);
          break;
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          coder::SizeType i1;
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[b_i % i1 * b_wls->us.size(1) + b_i / i1] = us[b_us] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        b_wls->origin.data[2] = us[2];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              us[us.size(1) * b_i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          coder::SizeType i1;
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[b_i % i1 * b_wls->us.size(1) + b_i / i1] = us[b_us];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        b_wls->origin.data[2] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] = us[us.size(1) * b_i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        i = b_wls->us.size(0);
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i]));
      }
      break;
    case 2:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])));
      }
      break;
    default:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(
                std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                          std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])),
                std::abs(b_wls->us[b_wls->us.size(1) * b_i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (coder::SizeType b_i{0}; b_i <= dim; b_i++) {
      b_wls->hs_inv.data[b_i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->us.size(0);
          b_us = b_wls->us.size(0);
          b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i] =
              b_wls->us[b_i % b_us * b_wls->us.size(1) + b_i / b_us] * maxx_inv;
        }
        break;
      case 2:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
        }
        break;
      default:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              b_wls->us[b_wls->us.size(1) * b_i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (order == 0) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      //  unit weights
      b_us = b_wls->rweights.size(0);
      b_wls->rweights.set_size(b_us);
      for (i = 0; i < b_us; i++) {
        b_wls->rweights[i] = 1.0;
      }
    }
    //  Compute Vandermonde system and recompute DAG if needed
    gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->V.size(0);
          for (coder::SizeType j{0}; j < i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Omit rows in CVM if needed
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          i = us.size(1) + 2;
          for (coder::SizeType blk{i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        gen_vander(b_wls->hs_inv.data, b_wls->hs_inv.size, order, b_wls->V);
        for (coder::SizeType blk{2}; blk <= nrblks; blk++) {
          coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
            b_wls->rweights[trg + b_i] = b_wls->rweights[src + b_i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
  }
}

//  wls_init  Initialize WlsObject in 1D, 2D, or 3D.
void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const WlsWeight *weight)
{
  coder::SizeType degree;
  coder::SizeType dim;
  coder::SizeType interp0;
  coder::SizeType nstpnts;
  coder::SizeType order;
  boolean_T use_dag;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  degree = b_wls->degree;
  order = b_wls->order;
  interp0 = b_wls->interp0;
  use_dag = b_wls->use_dag;
  nstpnts = us.size(0) - 1;
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), b_wls->degree, b_wls->order,
             b_wls->use_dag);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    coder::SizeType b_us;
    coder::SizeType i;
    coder::SizeType ncols;
    coder::SizeType nrblks;
    coder::SizeType src;
    coder::SizeType trg;
    coder::SizeType u1;
    //  Recompute DAG if use_dag and its signature does not match
    if (use_dag) {
      i = b_wls->dag.size(1) * b_wls->dag.size(0) - 1;
      b_us = b_wls->dag.size(0);
      if (b_wls->dag[i % b_us * b_wls->dag.size(1) + i / b_us] !=
          degree + 127) {
        switch (us.size(1)) {
        case 1:
          gen_vander_1d_dag(degree, b_wls->dag);
          break;
        case 2:
          gen_vander_2d_dag(degree, b_wls->dag);
          break;
        default:
          gen_vander_3d_dag(degree, b_wls->dag);
          break;
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            u1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > u1) {
                b_us -= u1;
              }
            }
          }
          u1 = b_wls->us.size(0);
          b_wls->us[b_i % u1 * b_wls->us.size(1) + b_i / u1] = us[b_us] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        b_wls->origin.data[2] = us[2];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              us[us.size(1) * b_i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            u1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > u1) {
                b_us -= u1;
              }
            }
          }
          u1 = b_wls->us.size(0);
          b_wls->us[b_i % u1 * b_wls->us.size(1) + b_i / u1] = us[b_us];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        b_wls->origin.data[2] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] = us[us.size(1) * b_i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        i = b_wls->us.size(0);
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i]));
      }
      break;
    case 2:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])));
      }
      break;
    default:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(
                std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                          std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])),
                std::abs(b_wls->us[b_wls->us.size(1) * b_i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (coder::SizeType b_i{0}; b_i <= dim; b_i++) {
      b_wls->hs_inv.data[b_i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->us.size(0);
          b_us = b_wls->us.size(0);
          b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i] =
              b_wls->us[b_i % b_us * b_wls->us.size(1) + b_i / b_us] * maxx_inv;
        }
        break;
      case 2:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
        }
        break;
      default:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              b_wls->us[b_wls->us.size(1) * b_i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight->name.size(1) == 0) || (weight->name[0] == 'U')) &&
        (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight->name.size(1) == 0) || (weight->name[0] == 'U')) {
        //  unit weights
        b_us = b_wls->rweights.size(0);
        b_wls->rweights.set_size(b_us);
        for (i = 0; i < b_us; i++) {
          b_wls->rweights[i] = 1.0;
        }
      } else if ((weight->name[0] == 'I') || (weight->name[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else if ((weight->name[0] == 'B') || (weight->name[0] == 'b')) {
        //  Buhmann weights. All points share same parameters
        wls_buhmann_weights(b_wls->us, us.size(0), degree,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else {
        if ((weight->name[0] != 'E') && (weight->name[0] != 'e')) {
          m2cErrMsgIdAndTxt(
              "wlslib:WrongWeightName",
              "Weighting scheme must be Unit, InvDist, Buhmann, or ENO.");
        }
        //  WLS-ENO
        wls_eno_weights(b_wls->us, us.size(0), degree, us,
                        weight->params_shared, weight->params_pointwise,
                        b_wls->rweights);
      }
    }
    //  Compute Vandermonde system and recompute DAG if needed
    gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->V.size(0);
          for (coder::SizeType j{0}; j < i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Omit rows in CVM if needed
    b_us = weight->omit_rows.size(0);
    u1 = b_wls->nrows;
    if (b_us <= u1) {
      u1 = b_us;
    }
    for (coder::SizeType b_i{0}; b_i < u1; b_i++) {
      if (weight->omit_rows[b_i]) {
        b_us = b_wls->V.size(0);
        for (i = 0; i < b_us; i++) {
          b_wls->V[b_i + b_wls->V.size(1) * i] = 0.0;
        }
      }
    }
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          i = us.size(1) + 2;
          for (coder::SizeType blk{i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        gen_vander(b_wls->hs_inv.data, b_wls->hs_inv.size, order, b_wls->V);
        for (coder::SizeType blk{2}; blk <= nrblks; blk++) {
          coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
            b_wls->rweights[trg + b_i] = b_wls->rweights[src + b_i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
  }
}

//  wls_init  Initialize WlsObject in 1D, 2D, or 3D.
void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const WlsWeight *weight, coder::SizeType degree)
{
  coder::SizeType dim;
  coder::SizeType interp0;
  coder::SizeType nstpnts;
  coder::SizeType order;
  boolean_T use_dag;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  order = b_wls->order;
  interp0 = b_wls->interp0;
  use_dag = b_wls->use_dag;
  nstpnts = us.size(0) - 1;
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), degree, b_wls->order,
             b_wls->use_dag);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    coder::SizeType b_us;
    coder::SizeType i;
    coder::SizeType ncols;
    coder::SizeType nrblks;
    coder::SizeType src;
    coder::SizeType trg;
    coder::SizeType u1;
    //  Recompute DAG if use_dag and its signature does not match
    if (use_dag) {
      i = b_wls->dag.size(1) * b_wls->dag.size(0) - 1;
      b_us = b_wls->dag.size(0);
      if (b_wls->dag[i % b_us * b_wls->dag.size(1) + i / b_us] !=
          degree + 127) {
        switch (us.size(1)) {
        case 1:
          gen_vander_1d_dag(degree, b_wls->dag);
          break;
        case 2:
          gen_vander_2d_dag(degree, b_wls->dag);
          break;
        default:
          gen_vander_3d_dag(degree, b_wls->dag);
          break;
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            u1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > u1) {
                b_us -= u1;
              }
            }
          }
          u1 = b_wls->us.size(0);
          b_wls->us[b_i % u1 * b_wls->us.size(1) + b_i / u1] = us[b_us] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        b_wls->origin.data[2] = us[2];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              us[us.size(1) * b_i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            u1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > u1) {
                b_us -= u1;
              }
            }
          }
          u1 = b_wls->us.size(0);
          b_wls->us[b_i % u1 * b_wls->us.size(1) + b_i / u1] = us[b_us];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        b_wls->origin.data[2] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] = us[us.size(1) * b_i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        i = b_wls->us.size(0);
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i]));
      }
      break;
    case 2:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])));
      }
      break;
    default:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(
                std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                          std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])),
                std::abs(b_wls->us[b_wls->us.size(1) * b_i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (coder::SizeType b_i{0}; b_i <= dim; b_i++) {
      b_wls->hs_inv.data[b_i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->us.size(0);
          b_us = b_wls->us.size(0);
          b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i] =
              b_wls->us[b_i % b_us * b_wls->us.size(1) + b_i / b_us] * maxx_inv;
        }
        break;
      case 2:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
        }
        break;
      default:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              b_wls->us[b_wls->us.size(1) * b_i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight->name.size(1) == 0) || (weight->name[0] == 'U')) &&
        (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight->name.size(1) == 0) || (weight->name[0] == 'U')) {
        //  unit weights
        b_us = b_wls->rweights.size(0);
        b_wls->rweights.set_size(b_us);
        for (i = 0; i < b_us; i++) {
          b_wls->rweights[i] = 1.0;
        }
      } else if ((weight->name[0] == 'I') || (weight->name[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else if ((weight->name[0] == 'B') || (weight->name[0] == 'b')) {
        //  Buhmann weights. All points share same parameters
        wls_buhmann_weights(b_wls->us, us.size(0), degree,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else {
        if ((weight->name[0] != 'E') && (weight->name[0] != 'e')) {
          m2cErrMsgIdAndTxt(
              "wlslib:WrongWeightName",
              "Weighting scheme must be Unit, InvDist, Buhmann, or ENO.");
        }
        //  WLS-ENO
        wls_eno_weights(b_wls->us, us.size(0), degree, us,
                        weight->params_shared, weight->params_pointwise,
                        b_wls->rweights);
      }
    }
    //  Compute Vandermonde system and recompute DAG if needed
    gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->V.size(0);
          for (coder::SizeType j{0}; j < i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Omit rows in CVM if needed
    b_us = weight->omit_rows.size(0);
    u1 = b_wls->nrows;
    if (b_us <= u1) {
      u1 = b_us;
    }
    for (coder::SizeType b_i{0}; b_i < u1; b_i++) {
      if (weight->omit_rows[b_i]) {
        b_us = b_wls->V.size(0);
        for (i = 0; i < b_us; i++) {
          b_wls->V[b_i + b_wls->V.size(1) * i] = 0.0;
        }
      }
    }
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          i = us.size(1) + 2;
          for (coder::SizeType blk{i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        gen_vander(b_wls->hs_inv.data, b_wls->hs_inv.size, order, b_wls->V);
        for (coder::SizeType blk{2}; blk <= nrblks; blk++) {
          coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
            b_wls->rweights[trg + b_i] = b_wls->rweights[src + b_i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
  }
}

//  wls_init  Initialize WlsObject in 1D, 2D, or 3D.
void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const WlsWeight *weight, coder::SizeType degree,
              coder::SizeType order)
{
  coder::SizeType dim;
  coder::SizeType interp0;
  coder::SizeType nstpnts;
  boolean_T use_dag;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  interp0 = b_wls->interp0;
  use_dag = b_wls->use_dag;
  nstpnts = us.size(0) - 1;
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), degree, order, b_wls->use_dag);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    coder::SizeType b_us;
    coder::SizeType i;
    coder::SizeType ncols;
    coder::SizeType nrblks;
    coder::SizeType src;
    coder::SizeType trg;
    coder::SizeType u1;
    //  Recompute DAG if use_dag and its signature does not match
    if (use_dag) {
      i = b_wls->dag.size(1) * b_wls->dag.size(0) - 1;
      b_us = b_wls->dag.size(0);
      if (b_wls->dag[i % b_us * b_wls->dag.size(1) + i / b_us] !=
          degree + 127) {
        switch (us.size(1)) {
        case 1:
          gen_vander_1d_dag(degree, b_wls->dag);
          break;
        case 2:
          gen_vander_2d_dag(degree, b_wls->dag);
          break;
        default:
          gen_vander_3d_dag(degree, b_wls->dag);
          break;
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            u1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > u1) {
                b_us -= u1;
              }
            }
          }
          u1 = b_wls->us.size(0);
          b_wls->us[b_i % u1 * b_wls->us.size(1) + b_i / u1] = us[b_us] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        b_wls->origin.data[2] = us[2];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              us[us.size(1) * b_i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            u1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > u1) {
                b_us -= u1;
              }
            }
          }
          u1 = b_wls->us.size(0);
          b_wls->us[b_i % u1 * b_wls->us.size(1) + b_i / u1] = us[b_us];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        b_wls->origin.data[2] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] = us[us.size(1) * b_i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        i = b_wls->us.size(0);
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i]));
      }
      break;
    case 2:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])));
      }
      break;
    default:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(
                std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                          std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])),
                std::abs(b_wls->us[b_wls->us.size(1) * b_i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (coder::SizeType b_i{0}; b_i <= dim; b_i++) {
      b_wls->hs_inv.data[b_i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->us.size(0);
          b_us = b_wls->us.size(0);
          b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i] =
              b_wls->us[b_i % b_us * b_wls->us.size(1) + b_i / b_us] * maxx_inv;
        }
        break;
      case 2:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
        }
        break;
      default:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              b_wls->us[b_wls->us.size(1) * b_i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight->name.size(1) == 0) || (weight->name[0] == 'U')) &&
        (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight->name.size(1) == 0) || (weight->name[0] == 'U')) {
        //  unit weights
        b_us = b_wls->rweights.size(0);
        b_wls->rweights.set_size(b_us);
        for (i = 0; i < b_us; i++) {
          b_wls->rweights[i] = 1.0;
        }
      } else if ((weight->name[0] == 'I') || (weight->name[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else if ((weight->name[0] == 'B') || (weight->name[0] == 'b')) {
        //  Buhmann weights. All points share same parameters
        wls_buhmann_weights(b_wls->us, us.size(0), degree,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else {
        if ((weight->name[0] != 'E') && (weight->name[0] != 'e')) {
          m2cErrMsgIdAndTxt(
              "wlslib:WrongWeightName",
              "Weighting scheme must be Unit, InvDist, Buhmann, or ENO.");
        }
        //  WLS-ENO
        wls_eno_weights(b_wls->us, us.size(0), degree, us,
                        weight->params_shared, weight->params_pointwise,
                        b_wls->rweights);
      }
    }
    //  Compute Vandermonde system and recompute DAG if needed
    gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->V.size(0);
          for (coder::SizeType j{0}; j < i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Omit rows in CVM if needed
    b_us = weight->omit_rows.size(0);
    u1 = b_wls->nrows;
    if (b_us <= u1) {
      u1 = b_us;
    }
    for (coder::SizeType b_i{0}; b_i < u1; b_i++) {
      if (weight->omit_rows[b_i]) {
        b_us = b_wls->V.size(0);
        for (i = 0; i < b_us; i++) {
          b_wls->V[b_i + b_wls->V.size(1) * i] = 0.0;
        }
      }
    }
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          i = us.size(1) + 2;
          for (coder::SizeType blk{i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        gen_vander(b_wls->hs_inv.data, b_wls->hs_inv.size, order, b_wls->V);
        for (coder::SizeType blk{2}; blk <= nrblks; blk++) {
          coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
            b_wls->rweights[trg + b_i] = b_wls->rweights[src + b_i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
  }
}

//  wls_init  Initialize WlsObject in 1D, 2D, or 3D.
void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const WlsWeight *weight, coder::SizeType degree,
              coder::SizeType order, coder::SizeType interp0)
{
  coder::SizeType dim;
  coder::SizeType nstpnts;
  boolean_T use_dag;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  b_wls->interp0 = interp0 != 0;
  interp0 = b_wls->interp0;
  use_dag = b_wls->use_dag;
  nstpnts = us.size(0) - 1;
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), degree, order, b_wls->use_dag);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    coder::SizeType b_us;
    coder::SizeType i;
    coder::SizeType ncols;
    coder::SizeType nrblks;
    coder::SizeType src;
    coder::SizeType trg;
    coder::SizeType u1;
    //  Recompute DAG if use_dag and its signature does not match
    if (use_dag) {
      i = b_wls->dag.size(1) * b_wls->dag.size(0) - 1;
      b_us = b_wls->dag.size(0);
      if (b_wls->dag[i % b_us * b_wls->dag.size(1) + i / b_us] !=
          degree + 127) {
        switch (us.size(1)) {
        case 1:
          gen_vander_1d_dag(degree, b_wls->dag);
          break;
        case 2:
          gen_vander_2d_dag(degree, b_wls->dag);
          break;
        default:
          gen_vander_3d_dag(degree, b_wls->dag);
          break;
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            u1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > u1) {
                b_us -= u1;
              }
            }
          }
          u1 = b_wls->us.size(0);
          b_wls->us[b_i % u1 * b_wls->us.size(1) + b_i / u1] = us[b_us] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        b_wls->origin.data[2] = us[2];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              us[us.size(1) * b_i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            u1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > u1) {
                b_us -= u1;
              }
            }
          }
          u1 = b_wls->us.size(0);
          b_wls->us[b_i % u1 * b_wls->us.size(1) + b_i / u1] = us[b_us];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        b_wls->origin.data[2] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] = us[us.size(1) * b_i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        i = b_wls->us.size(0);
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i]));
      }
      break;
    case 2:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])));
      }
      break;
    default:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(
                std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                          std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])),
                std::abs(b_wls->us[b_wls->us.size(1) * b_i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (coder::SizeType b_i{0}; b_i <= dim; b_i++) {
      b_wls->hs_inv.data[b_i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->us.size(0);
          b_us = b_wls->us.size(0);
          b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i] =
              b_wls->us[b_i % b_us * b_wls->us.size(1) + b_i / b_us] * maxx_inv;
        }
        break;
      case 2:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
        }
        break;
      default:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              b_wls->us[b_wls->us.size(1) * b_i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight->name.size(1) == 0) || (weight->name[0] == 'U')) &&
        (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight->name.size(1) == 0) || (weight->name[0] == 'U')) {
        //  unit weights
        b_us = b_wls->rweights.size(0);
        b_wls->rweights.set_size(b_us);
        for (i = 0; i < b_us; i++) {
          b_wls->rweights[i] = 1.0;
        }
      } else if ((weight->name[0] == 'I') || (weight->name[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else if ((weight->name[0] == 'B') || (weight->name[0] == 'b')) {
        //  Buhmann weights. All points share same parameters
        wls_buhmann_weights(b_wls->us, us.size(0), degree,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else {
        if ((weight->name[0] != 'E') && (weight->name[0] != 'e')) {
          m2cErrMsgIdAndTxt(
              "wlslib:WrongWeightName",
              "Weighting scheme must be Unit, InvDist, Buhmann, or ENO.");
        }
        //  WLS-ENO
        wls_eno_weights(b_wls->us, us.size(0), degree, us,
                        weight->params_shared, weight->params_pointwise,
                        b_wls->rweights);
      }
    }
    //  Compute Vandermonde system and recompute DAG if needed
    gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->V.size(0);
          for (coder::SizeType j{0}; j < i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Omit rows in CVM if needed
    b_us = weight->omit_rows.size(0);
    u1 = b_wls->nrows;
    if (b_us <= u1) {
      u1 = b_us;
    }
    for (coder::SizeType b_i{0}; b_i < u1; b_i++) {
      if (weight->omit_rows[b_i]) {
        b_us = b_wls->V.size(0);
        for (i = 0; i < b_us; i++) {
          b_wls->V[b_i + b_wls->V.size(1) * i] = 0.0;
        }
      }
    }
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          i = us.size(1) + 2;
          for (coder::SizeType blk{i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        gen_vander(b_wls->hs_inv.data, b_wls->hs_inv.size, order, b_wls->V);
        for (coder::SizeType blk{2}; blk <= nrblks; blk++) {
          coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
            b_wls->rweights[trg + b_i] = b_wls->rweights[src + b_i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
  }
}

//  wls_init  Initialize WlsObject in 1D, 2D, or 3D.
void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const WlsWeight *weight, coder::SizeType degree,
              coder::SizeType order, coder::SizeType interp0, boolean_T use_dag)
{
  coder::SizeType dim;
  coder::SizeType nstpnts;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  b_wls->interp0 = interp0 != 0;
  interp0 = b_wls->interp0;
  b_wls->use_dag = use_dag;
  nstpnts = us.size(0) - 1;
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), degree, order, use_dag);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    coder::SizeType b_us;
    coder::SizeType i;
    coder::SizeType ncols;
    coder::SizeType nrblks;
    coder::SizeType src;
    coder::SizeType trg;
    coder::SizeType u1;
    //  Recompute DAG if use_dag and its signature does not match
    if (use_dag) {
      i = b_wls->dag.size(1) * b_wls->dag.size(0) - 1;
      b_us = b_wls->dag.size(0);
      if (b_wls->dag[i % b_us * b_wls->dag.size(1) + i / b_us] !=
          degree + 127) {
        switch (us.size(1)) {
        case 1:
          gen_vander_1d_dag(degree, b_wls->dag);
          break;
        case 2:
          gen_vander_2d_dag(degree, b_wls->dag);
          break;
        default:
          gen_vander_3d_dag(degree, b_wls->dag);
          break;
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            u1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > u1) {
                b_us -= u1;
              }
            }
          }
          u1 = b_wls->us.size(0);
          b_wls->us[b_i % u1 * b_wls->us.size(1) + b_i / u1] = us[b_us] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        b_wls->origin.data[2] = us[2];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              us[us.size(1) * b_i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            u1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > u1) {
                b_us -= u1;
              }
            }
          }
          u1 = b_wls->us.size(0);
          b_wls->us[b_i % u1 * b_wls->us.size(1) + b_i / u1] = us[b_us];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        b_wls->origin.data[2] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] = us[us.size(1) * b_i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        i = b_wls->us.size(0);
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i]));
      }
      break;
    case 2:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])));
      }
      break;
    default:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(
                std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                          std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])),
                std::abs(b_wls->us[b_wls->us.size(1) * b_i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (coder::SizeType b_i{0}; b_i <= dim; b_i++) {
      b_wls->hs_inv.data[b_i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->us.size(0);
          b_us = b_wls->us.size(0);
          b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i] =
              b_wls->us[b_i % b_us * b_wls->us.size(1) + b_i / b_us] * maxx_inv;
        }
        break;
      case 2:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
        }
        break;
      default:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              b_wls->us[b_wls->us.size(1) * b_i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight->name.size(1) == 0) || (weight->name[0] == 'U')) &&
        (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight->name.size(1) == 0) || (weight->name[0] == 'U')) {
        //  unit weights
        b_us = b_wls->rweights.size(0);
        b_wls->rweights.set_size(b_us);
        for (i = 0; i < b_us; i++) {
          b_wls->rweights[i] = 1.0;
        }
      } else if ((weight->name[0] == 'I') || (weight->name[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else if ((weight->name[0] == 'B') || (weight->name[0] == 'b')) {
        //  Buhmann weights. All points share same parameters
        wls_buhmann_weights(b_wls->us, us.size(0), degree,
                            weight->params_shared, weight->params_pointwise,
                            b_wls->rweights);
      } else {
        if ((weight->name[0] != 'E') && (weight->name[0] != 'e')) {
          m2cErrMsgIdAndTxt(
              "wlslib:WrongWeightName",
              "Weighting scheme must be Unit, InvDist, Buhmann, or ENO.");
        }
        //  WLS-ENO
        wls_eno_weights(b_wls->us, us.size(0), degree, us,
                        weight->params_shared, weight->params_pointwise,
                        b_wls->rweights);
      }
    }
    //  Compute Vandermonde system and recompute DAG if needed
    gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->V.size(0);
          for (coder::SizeType j{0}; j < i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Omit rows in CVM if needed
    b_us = weight->omit_rows.size(0);
    u1 = b_wls->nrows;
    if (b_us <= u1) {
      u1 = b_us;
    }
    for (coder::SizeType b_i{0}; b_i < u1; b_i++) {
      if (weight->omit_rows[b_i]) {
        b_us = b_wls->V.size(0);
        for (i = 0; i < b_us; i++) {
          b_wls->V[b_i + b_wls->V.size(1) * i] = 0.0;
        }
      }
    }
    //  Perform QR with column pivoting
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          i = us.size(1) + 2;
          for (coder::SizeType blk{i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        gen_vander(b_wls->hs_inv.data, b_wls->hs_inv.size, order, b_wls->V);
        for (coder::SizeType blk{2}; blk <= nrblks; blk++) {
          coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
            b_wls->rweights[trg + b_i] = b_wls->rweights[src + b_i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
  }
}

//  wls_init  Initialize WlsObject in 1D, 2D, or 3D.
void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const ::coder::array<char_T, 2U> &weight, coder::SizeType degree,
              coder::SizeType order, coder::SizeType interp0, boolean_T use_dag,
              coder::SizeType nstpnts)
{
  coder::SizeType dim;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  b_wls->interp0 = interp0 != 0;
  interp0 = b_wls->interp0;
  b_wls->use_dag = use_dag;
  if (nstpnts <= 0) {
    nstpnts = us.size(0);
  } else {
    m2cAssert(
        nstpnts <= us.size(0),
        "Number of points cannot be greater than the first dimension of `us`.");
  }
  //  Resize buffers
  wls_resize(b_wls, us.size(1), nstpnts, degree, order, use_dag);
  if (nstpnts != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    coder::SizeType b_us;
    coder::SizeType i;
    coder::SizeType ncols;
    coder::SizeType nrblks;
    coder::SizeType src;
    coder::SizeType trg;
    //  Recompute DAG if use_dag and its signature does not match
    if (use_dag) {
      i = b_wls->dag.size(1) * b_wls->dag.size(0) - 1;
      b_us = b_wls->dag.size(0);
      if (b_wls->dag[i % b_us * b_wls->dag.size(1) + i / b_us] !=
          degree + 127) {
        switch (us.size(1)) {
        case 1:
          gen_vander_1d_dag(degree, b_wls->dag);
          break;
        case 2:
          gen_vander_2d_dag(degree, b_wls->dag);
          break;
        default:
          gen_vander_3d_dag(degree, b_wls->dag);
          break;
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b = true;
        b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
          coder::SizeType i1;
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[b_i % i1 * b_wls->us.size(1) + b_i / i1] = us[b_us] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        b_wls->origin.data[2] = us[2];
        for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              us[us.size(1) * b_i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b = true;
        b1 = ((us.size(1) <= 0) || (us.size(0) <= 0));
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
          coder::SizeType i1;
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[b_i % i1 * b_wls->us.size(1) + b_i / i1] = us[b_us];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        b_wls->origin.data[2] = 0.0;
        for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] = us[us.size(1) * b_i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
        i = b_wls->us.size(0);
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i]));
      }
      break;
    case 2:
      for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])));
      }
      break;
    default:
      for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(
                std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                          std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])),
                std::abs(b_wls->us[b_wls->us.size(1) * b_i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (coder::SizeType b_i{0}; b_i <= dim; b_i++) {
      b_wls->hs_inv.data[b_i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
          i = b_wls->us.size(0);
          b_us = b_wls->us.size(0);
          b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i] =
              b_wls->us[b_i % b_us * b_wls->us.size(1) + b_i / b_us] * maxx_inv;
        }
        break;
      case 2:
        for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
        }
        break;
      default:
        for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              b_wls->us[b_wls->us.size(1) * b_i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight.size(1) == 0) || (weight[0] == 'U')) && (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight.size(1) == 0) || (weight[0] == 'U')) {
        //  unit weights
        b_us = b_wls->rweights.size(0);
        b_wls->rweights.set_size(b_us);
        for (i = 0; i < b_us; i++) {
          b_wls->rweights[i] = 1.0;
        }
      } else if ((weight[0] == 'I') || (weight[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, nstpnts, degree, b_wls->rweights);
      } else {
        if ((weight[0] != 'B') && (weight[0] != 'b')) {
          m2cErrMsgIdAndTxt("wlslib:WrongWeightName",
                            "When using a character string, weighting scheme "
                            "must be Unit, InvDist, or Buhmann.");
        }
        //  Buhmann weights with default parameters
        wls_buhmann_weights(b_wls->us, nstpnts, degree, b_wls->rweights);
      }
    }
    //  Compute Vandermonde system and recompute DAG if needed
    gen_vander(b_wls->us, nstpnts, degree, order, b_wls->rweights, b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (nstpnts != b_wls->stride) &&
        (nstpnts != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = nstpnts;
      for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
          i = b_wls->V.size(0);
          for (coder::SizeType j{0}; j < i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    b_wls->nrows = nrblks * nstpnts;
    b_wls->ncols = ncols;
    //  Omit rows in CVM if needed
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (coder::SizeType j{0}; j < nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          i = us.size(1) + 2;
          for (coder::SizeType blk{i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (coder::SizeType j{0}; j < nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        gen_vander(b_wls->hs_inv.data, b_wls->hs_inv.size, order, b_wls->V);
        for (coder::SizeType blk{2}; blk <= nrblks; blk++) {
          coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (coder::SizeType j{0}; j < nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (nstpnts != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = nstpnts;
        for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (coder::SizeType b_i{0}; b_i < nstpnts; b_i++) {
            b_wls->rweights[trg + b_i] = b_wls->rweights[src + b_i];
          }
          trg += nstpnts;
        }
      }
    }
  }
}

//  wls_init  Initialize WlsObject in 1D, 2D, or 3D.
void wls_init(WlsObject *b_wls, const ::coder::array<real_T, 2U> &us,
              const ::coder::array<char_T, 2U> &weight)
{
  coder::SizeType degree;
  coder::SizeType dim;
  coder::SizeType interp0;
  coder::SizeType nstpnts;
  coder::SizeType order;
  boolean_T use_dag;
  m2cAssert(us.size(1) >= 1, "");
  //  Process input arguments
  dim = us.size(1) - 1;
  degree = b_wls->degree;
  order = b_wls->order;
  interp0 = b_wls->interp0;
  use_dag = b_wls->use_dag;
  nstpnts = us.size(0) - 1;
  //  Resize buffers
  wls_resize(b_wls, us.size(1), us.size(0), b_wls->degree, b_wls->order,
             b_wls->use_dag);
  if (us.size(0) != 0) {
    real_T maxx;
    real_T maxx_inv;
    real_T thres;
    coder::SizeType b_us;
    coder::SizeType i;
    coder::SizeType ncols;
    coder::SizeType nrblks;
    coder::SizeType src;
    coder::SizeType trg;
    //  Recompute DAG if use_dag and its signature does not match
    if (use_dag) {
      i = b_wls->dag.size(1) * b_wls->dag.size(0) - 1;
      b_us = b_wls->dag.size(0);
      if (b_wls->dag[i % b_us * b_wls->dag.size(1) + i / b_us] !=
          degree + 127) {
        switch (us.size(1)) {
        case 1:
          gen_vander_1d_dag(degree, b_wls->dag);
          break;
        case 2:
          gen_vander_2d_dag(degree, b_wls->dag);
          break;
        default:
          gen_vander_3d_dag(degree, b_wls->dag);
          break;
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  Make the first node the origin in interp0 mode
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          coder::SizeType i1;
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[b_i % i1 * b_wls->us.size(1) + b_i / i1] = us[b_us] - us[0];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = us[0];
        b_wls->origin.data[1] = us[1];
        b_wls->origin.data[2] = us[2];
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i] - us[0];
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              us[us.size(1) * b_i + 1] - us[1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              us[us.size(1) * b_i + 2] - us[2];
        }
        break;
      }
    } else {
      switch (us.size(1)) {
      case 1: {
        boolean_T b;
        boolean_T b1;
        b_wls->origin.size[1] = 1;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b = true;
        b1 = us.size(1) <= 0;
        i = us.size(1) * us.size(0);
        b_us = 0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          coder::SizeType i1;
          if (b1 || (b_i >= i)) {
            b_us = 0;
            b = true;
          } else if (b) {
            b = false;
            b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
          } else {
            i1 = us.size(1) * us.size(0) - 1;
            if (b_us > MAX_int32_T - us.size(1)) {
              b_us = b_i % us.size(0) * us.size(1) + b_i / us.size(0);
            } else {
              b_us += us.size(1);
              if (b_us > i1) {
                b_us -= i1;
              }
            }
          }
          i1 = b_wls->us.size(0);
          b_wls->us[b_i % i1 * b_wls->us.size(1) + b_i / i1] = us[b_us];
        }
      } break;
      case 2:
        b_wls->origin.size[1] = 2;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
        }
        break;
      default:
        b_wls->origin.size[1] = 3;
        b_wls->origin.size[0] = 1;
        b_wls->origin.data[0] = 0.0;
        b_wls->origin.data[1] = 0.0;
        b_wls->origin.data[2] = 0.0;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] = us[us.size(1) * b_i];
          b_wls->us[b_wls->us.size(1) * b_i + 1] = us[us.size(1) * b_i + 1];
          b_wls->us[b_wls->us.size(1) * b_i + 2] = us[us.size(1) * b_i + 2];
        }
        break;
      }
    }
    //  Scale us to be between -1 and 1
    maxx = 0.0;
    switch (us.size(1)) {
    case 1:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        i = b_wls->us.size(0);
        maxx = std::fmax(
            maxx, std::abs(b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i]));
      }
      break;
    case 2:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx, std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                            std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])));
      }
      break;
    default:
      for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
        maxx = std::fmax(
            maxx,
            std::fmax(
                std::fmax(std::abs(b_wls->us[b_wls->us.size(1) * b_i]),
                          std::abs(b_wls->us[b_wls->us.size(1) * b_i + 1])),
                std::abs(b_wls->us[b_wls->us.size(1) * b_i + 2])));
      }
      break;
    }
    if (maxx == 0.0) {
      maxx_inv = 1.0;
    } else {
      maxx_inv = 1.0 / maxx;
    }
    for (coder::SizeType b_i{0}; b_i <= dim; b_i++) {
      b_wls->hs_inv.data[b_i] = maxx_inv;
    }
    //  scale wls.us
    if (maxx_inv != 1.0) {
      switch (us.size(1)) {
      case 1:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->us.size(0);
          b_us = b_wls->us.size(0);
          b_wls->us[b_i % i * b_wls->us.size(1) + b_i / i] =
              b_wls->us[b_i % b_us * b_wls->us.size(1) + b_i / b_us] * maxx_inv;
        }
        break;
      case 2:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
        }
        break;
      default:
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          b_wls->us[b_wls->us.size(1) * b_i] =
              b_wls->us[b_wls->us.size(1) * b_i] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 1] =
              b_wls->us[b_wls->us.size(1) * b_i + 1] * maxx_inv;
          b_wls->us[b_wls->us.size(1) * b_i + 2] =
              b_wls->us[b_wls->us.size(1) * b_i + 2] * maxx_inv;
        }
        break;
      }
    }
    //  Compute point-wise weights
    if (((weight.size(1) == 0) || (weight[0] == 'U')) && (order == 0)) {
      //  Unit weights
      b_wls->rweights.set_size(0);
    } else {
      b_wls->rweights.set_size(b_wls->V.size(1));
      if ((weight.size(1) == 0) || (weight[0] == 'U')) {
        //  unit weights
        b_us = b_wls->rweights.size(0);
        b_wls->rweights.set_size(b_us);
        for (i = 0; i < b_us; i++) {
          b_wls->rweights[i] = 1.0;
        }
      } else if ((weight[0] == 'I') || (weight[0] == 'i')) {
        //  inverse distance
        wls_invdist_weights(b_wls->us, us.size(0), degree, b_wls->rweights);
      } else {
        if ((weight[0] != 'B') && (weight[0] != 'b')) {
          m2cErrMsgIdAndTxt("wlslib:WrongWeightName",
                            "When using a character string, weighting scheme "
                            "must be Unit, InvDist, or Buhmann.");
        }
        //  Buhmann weights with default parameters
        wls_buhmann_weights(b_wls->us, us.size(0), degree, b_wls->rweights);
      }
    }
    //  Compute Vandermonde system and recompute DAG if needed
    gen_vander(b_wls->us, us.size(0), degree, order, b_wls->rweights, b_wls->V);
    nrblks = b_wls->V.size(1) / b_wls->stride;
    ncols = b_wls->V.size(0);
    //  Compact CVM if needed
    if ((order > 0) && (us.size(0) != b_wls->stride) &&
        (us.size(0) != b_wls->stride)) {
      //  Compact the storage of Vandermonde matrix
      trg = us.size(0);
      for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
        src = (b_b - 1) * b_wls->stride;
        for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
          i = b_wls->V.size(0);
          for (coder::SizeType j{0}; j < i; j++) {
            b_wls->V[trg + b_wls->V.size(1) * j] =
                b_wls->V[src + b_wls->V.size(1) * j];
          }
          src++;
          trg++;
        }
      }
    }
    b_wls->nrows = nrblks * us.size(0);
    b_wls->ncols = ncols;
    //  Omit rows in CVM if needed
    if ((degree > 1) && (degree < 7)) {
      thres = dv[degree - 1];
    } else {
      thres = 1.0E+8;
    }
    //  In interp0 mode, we trim off the first row and first column.
    rrqr_factor(b_wls->V, thres, interp0, interp0, b_wls->nrows - interp0,
                ncols - interp0, b_wls->QR, b_wls->jpvt, &b_wls->rank,
                b_wls->work);
    b_wls->fullrank = b_wls->rank == ncols - interp0;
    b_wls->rowmajor = true;
    if ((b_wls->rweights.size(0) != 0) && (order > 0)) {
      //  Compute weights for derivatives
      if (order <= 2) {
        real_T s;
        coder::SizeType J;
        s = 1.0 / maxx_inv;
        for (coder::SizeType blk{0}; blk <= dim; blk++) {
          J = (blk + 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] = b_wls->rweights[j] * s;
          }
        }
        if (order == 2) {
          s = 1.0 / (maxx_inv * maxx_inv);
          i = us.size(1) + 2;
          for (coder::SizeType blk{i}; blk <= nrblks; blk++) {
            J = (blk - 1) * b_wls->stride;
            for (coder::SizeType j{0}; j <= nstpnts; j++) {
              b_wls->rweights[J + j] = b_wls->rweights[j] * s;
            }
          }
        }
      } else {
        //  Compute scaling factors for each block. Use wls.rhs as work space.
        gen_vander(b_wls->hs_inv.data, b_wls->hs_inv.size, order, b_wls->V);
        for (coder::SizeType blk{2}; blk <= nrblks; blk++) {
          coder::SizeType J;
          J = (blk - 1) * b_wls->stride;
          for (coder::SizeType j{0}; j <= nstpnts; j++) {
            b_wls->rweights[J + j] =
                b_wls->rweights[j] / b_wls->V[b_wls->V.size(1) * (blk - 1)];
          }
        }
      }
      if (us.size(0) != b_wls->stride) {
        //  Compact the storage of Vandermonde matrix
        trg = us.size(0);
        for (coder::SizeType b_b{2}; b_b <= nrblks; b_b++) {
          src = (b_b - 1) * b_wls->stride;
          for (coder::SizeType b_i{0}; b_i <= nstpnts; b_i++) {
            b_wls->rweights[trg + b_i] = b_wls->rweights[src + b_i];
          }
          trg = (trg + nstpnts) + 1;
        }
      }
    }
  }
}

// wls_solve_sys - Solve Vandermonde system to obtain the operator
void wls_solve_sys(WlsObject *b_wls, ::coder::array<real_T, 2U> &vdops)
{
  coder::SizeType b_loop_ub;
  coder::SizeType i;
  coder::SizeType loop_ub;
  coder::SizeType nRhs;
  coder::SizeType nrows;
  coder::SizeType nrows_vdops;
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      b_loop_ub = b_wls->QR.size(0);
      for (coder::SizeType i1{0}; i1 < b_loop_ub; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  loop_ub = b_wls->ncols;
  b_loop_ub = b_wls->nrows;
  if (loop_ub >= b_loop_ub) {
    nrows_vdops = loop_ub;
  } else {
    nrows_vdops = b_loop_ub;
  }
  vdops.set_size(nrows_vdops, nRhs);
  //  Transpose the operator for row-major
  i = nrows_vdops - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (coder::SizeType j{0}; j < nRhs; j++) {
      vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    for (coder::SizeType j{0}; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      i = b_wls->nstpnts;
      for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      vdops[j] = 1.0 - s;
    }
  }
}

// wls_solve_sys - Solve Vandermonde system to obtain the operator
void wls_solve_sys(WlsObject *b_wls, const ::coder::array<int8_T, 2U> &diff_idx,
                   ::coder::array<real_T, 2U> &vdops)
{
  coder::SizeType b_loop_ub;
  coder::SizeType i;
  coder::SizeType i1;
  coder::SizeType loop_ub;
  coder::SizeType nRhs;
  coder::SizeType nrows;
  coder::SizeType nrows_vdops;
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      b_loop_ub = b_wls->QR.size(0);
      for (i1 = 0; i1 < b_loop_ub; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  loop_ub = b_wls->ncols;
  b_loop_ub = b_wls->nrows;
  if (loop_ub >= b_loop_ub) {
    nrows_vdops = loop_ub;
  } else {
    nrows_vdops = b_loop_ub;
  }
  vdops.set_size(nrows_vdops, nRhs);
  //  Transpose the operator for row-major
  i = nrows_vdops - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (coder::SizeType j{0}; j < nRhs; j++) {
      vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    boolean_T b;
    boolean_T b1;
    //  In interp0 mode, set the first entry based on partition of unity
    b = true;
    b1 = ((diff_idx.size(1) <= 0) || (diff_idx.size(0) <= 0));
    i = diff_idx.size(1) * diff_idx.size(0);
    i1 = 0;
    for (coder::SizeType j{0}; j < nRhs; j++) {
      real_T s;
      coder::SizeType totalw;
      if (b1 || (j >= i)) {
        i1 = 0;
        b = true;
      } else if (b) {
        b = false;
        i1 = j % diff_idx.size(0) * diff_idx.size(1) + j / diff_idx.size(0);
      } else {
        loop_ub = diff_idx.size(1) * diff_idx.size(0) - 1;
        if (i1 > MAX_int32_T - diff_idx.size(1)) {
          i1 = j % diff_idx.size(0) * diff_idx.size(1) + j / diff_idx.size(0);
        } else {
          i1 += diff_idx.size(1);
          if (i1 > loop_ub) {
            i1 -= loop_ub;
          }
        }
      }
      s = 0.0;
      loop_ub = b_wls->nstpnts;
      for (coder::SizeType b_i{2}; b_i <= loop_ub; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      if (diff_idx[i1] > 1) {
        totalw = 0;
      } else {
        totalw = b_wls->nevpnts;
        //  Unit weights summed together
      }
      vdops[j] = static_cast<real_T>(totalw) - s;
    }
  }
}

// wls_solve_sys - Solve Vandermonde system to obtain the operator
void wls_solve_sys(WlsObject *b_wls, const ::coder::array<int8_T, 2U> &diff_idx,
                   const ::coder::array<real_T, 2U> &ws,
                   ::coder::array<real_T, 2U> &vdops)
{
  coder::SizeType b_loop_ub;
  coder::SizeType i;
  coder::SizeType i1;
  coder::SizeType loop_ub;
  coder::SizeType nRhs;
  coder::SizeType nrows;
  coder::SizeType nrows_vdops;
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      b_loop_ub = b_wls->QR.size(0);
      for (i1 = 0; i1 < b_loop_ub; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  loop_ub = b_wls->ncols;
  b_loop_ub = b_wls->nrows;
  if (loop_ub >= b_loop_ub) {
    nrows_vdops = loop_ub;
  } else {
    nrows_vdops = b_loop_ub;
  }
  vdops.set_size(nrows_vdops, nRhs);
  //  Transpose the operator for row-major
  i = nrows_vdops - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (coder::SizeType j{0}; j < nRhs; j++) {
      vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    coder::SizeType iWeight;
    boolean_T b;
    boolean_T b1;
    //  In interp0 mode, set the first entry based on partition of unity
    iWeight = 1;
    b = true;
    b1 = ((diff_idx.size(1) <= 0) || (diff_idx.size(0) <= 0));
    i = diff_idx.size(1) * diff_idx.size(0);
    i1 = 0;
    for (coder::SizeType j{0}; j < nRhs; j++) {
      real_T s;
      real_T totalw;
      if (b1 || (j >= i)) {
        i1 = 0;
        b = true;
      } else if (b) {
        b = false;
        i1 = j % diff_idx.size(0) * diff_idx.size(1) + j / diff_idx.size(0);
      } else {
        loop_ub = diff_idx.size(1) * diff_idx.size(0) - 1;
        if (i1 > MAX_int32_T - diff_idx.size(1)) {
          i1 = j % diff_idx.size(0) * diff_idx.size(1) + j / diff_idx.size(0);
        } else {
          i1 += diff_idx.size(1);
          if (i1 > loop_ub) {
            i1 -= loop_ub;
          }
        }
      }
      s = 0.0;
      loop_ub = b_wls->nstpnts;
      for (coder::SizeType b_i{2}; b_i <= loop_ub; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      if (diff_idx[i1] > 1) {
        totalw = 0.0;
      } else {
        loop_ub = ws.size(0);
        if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
          totalw = b_wls->nevpnts;
          //  Unit weights summed together
        } else {
          //  All weights summed together
          totalw = 0.0;
          for (coder::SizeType b_i{0}; b_i < loop_ub; b_i++) {
            totalw += ws[(iWeight + ws.size(1) * b_i) - 1];
          }
          iWeight += iWeight < ws.size(1);
        }
      }
      vdops[j] = totalw - s;
    }
  }
}

//  wls_tab_mbasis - Tabulate monomial basis functions and derivatives
void wls_tab_mbasis(WlsObject *b_wls, const ::coder::array<real_T, 2U> &evpnts)
{
  coder::SizeType nDims;
  coder::SizeType nevpnts;
  nevpnts = evpnts.size(0) - 1;
  nDims = evpnts.size(1) - 1;
  b_wls->nevpnts = evpnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((evpnts.size(0) + 3) / 4) << 2, evpnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (evpnts[dim + evpnts.size(1) * iPoint] - b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            evpnts[dim + evpnts.size(1) * iPoint] * b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, evpnts.size(0), b_wls->degree, b_wls->V);
}

//  wls_tab_mbasis - Tabulate monomial basis functions and derivatives
void wls_tab_mbasis(WlsObject *b_wls, const ::coder::array<real_T, 2U> &evpnts,
                    coder::SizeType order)
{
  coder::SizeType nDims;
  coder::SizeType nevpnts;
  nevpnts = evpnts.size(0) - 1;
  nDims = evpnts.size(1) - 1;
  b_wls->nevpnts = evpnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((evpnts.size(0) + 3) / 4) << 2, evpnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (evpnts[dim + evpnts.size(1) * iPoint] - b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            evpnts[dim + evpnts.size(1) * iPoint] * b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, evpnts.size(0), b_wls->degree, order,
             b_wls->hs_inv.data, b_wls->hs_inv.size, b_wls->V);
}

//  wls_tab_mbasis - Tabulate monomial basis functions and derivatives
void wls_tab_mbasis(WlsObject *b_wls, const ::coder::array<real_T, 2U> &evpnts,
                    coder::SizeType order, coder::SizeType nevpnts)
{
  coder::SizeType nDims;
  if (nevpnts == 0) {
    nevpnts = evpnts.size(0);
  }
  nDims = evpnts.size(1) - 1;
  b_wls->nevpnts = nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((nevpnts + 3) / 4) << 2, evpnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (evpnts[dim + evpnts.size(1) * iPoint] - b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            evpnts[dim + evpnts.size(1) * iPoint] * b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, nevpnts, b_wls->degree, order, b_wls->hs_inv.data,
             b_wls->hs_inv.size, b_wls->V);
}

// wls_update_rhs - Update the RHS vectors
void wls_update_rhs(WlsObject *b_wls,
                    const ::coder::array<int8_T, 2U> &diff_idx)
{
  coder::SizeType i;
  coder::SizeType nDiff;
  coder::SizeType nevpnts_tmp;
  coder::SizeType u0;
  coder::SizeType u1;
  nevpnts_tmp = b_wls->nevpnts;
  nDiff = diff_idx.size(0);
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  b_wls->rhs.set_size(nevpnts_tmp, u1 - b_wls->interp0);
  //  Omit zeros in the diff operators
  i = diff_idx.size(0);
  while ((i > 0) && (i <= diff_idx.size(0)) &&
         (diff_idx[diff_idx.size(1) * (i - 1)] == 0)) {
    nDiff--;
    i--;
  }
  //  Summing up rows in the differential operator
  u0 = diff_idx.size(1);
  for (coder::SizeType jDiff{0}; jDiff < u0; jDiff++) {
    //  Loop through the operators
    for (coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > diff_idx.size(0)) ||
          (diff_idx[jDiff + diff_idx.size(1) * iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > diff_idx.size(0)) {
          offset = 0;
        } else {
          offset = (diff_idx[jDiff + diff_idx.size(1) * iOp] - 1) *
                   b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        u1 = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < u1; iMonomial++) {
          coder::SizeType j;
          j = b_wls->jpvt[iMonomial] + b_wls->interp0;
          //  Do not sum if nargin<3
          for (coder::SizeType iEval{0}; iEval < nevpnts_tmp; iEval++) {
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iEval] =
                b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
          }
        }
      }
    }
  }
}

// wls_update_rhs - Update the RHS vectors
void wls_update_rhs2(WlsObject *b_wls,
                     const ::coder::array<int8_T, 2U> &diff_idx,
                     const ::coder::array<real_T, 2U> &ws)
{
  coder::SizeType i;
  coder::SizeType lenWs;
  coder::SizeType nDiff;
  coder::SizeType nevpnts;
  coder::SizeType u0;
  coder::SizeType u1;
  nevpnts = b_wls->nevpnts - 1;
  nDiff = diff_idx.size(0);
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(diff_idx.size(0), u0);
  u0 *= diff_idx.size(0);
  for (u1 = 0; u1 < u0; u1++) {
    b_wls->rhs[u1] = 0.0;
  }
  //  Omit zeros in the diff operators
  i = diff_idx.size(0);
  while ((i > 0) && (i <= diff_idx.size(0)) &&
         (diff_idx[diff_idx.size(1) * (i - 1)] == 0)) {
    nDiff--;
    i--;
  }
  if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
    lenWs = 1;
  } else {
    lenWs = ws.size(1);
  }
  //  Summing up rows in the differential operator
  u1 = diff_idx.size(1);
  for (coder::SizeType jDiff{0}; jDiff < u1; jDiff++) {
    coder::SizeType iWeight;
    iWeight = 1;
    //  Loop through the operators
    for (coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > diff_idx.size(0)) ||
          (diff_idx[jDiff + diff_idx.size(1) * iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > diff_idx.size(0)) {
          offset = 0;
        } else {
          offset = (diff_idx[jDiff + diff_idx.size(1) * iOp] - 1) *
                   b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        u0 = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < u0; iMonomial++) {
          coder::SizeType j;
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[(iWeight + ws.size(1) * iEval) - 1] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
      if (iWeight == lenWs) {
        iWeight = 1;
      } else {
        iWeight++;
      }
    }
  }
}

// wls_update_rhs - Update the RHS vectors
void wls_update_rhs3(WlsObject *b_wls,
                     const ::coder::array<int8_T, 2U> &diff_idx,
                     const ::coder::array<real_T, 2U> &ws)
{
  coder::SizeType b_i;
  coder::SizeType i;
  coder::SizeType lenWs;
  coder::SizeType nDiff;
  coder::SizeType nevpnts;
  nevpnts = b_wls->nevpnts - 1;
  nDiff = diff_idx.size(0);
  //  Omit zeros in the diff operators
  i = diff_idx.size(0);
  while ((i > 0) && (i <= diff_idx.size(0)) &&
         (diff_idx[diff_idx.size(1) * (i - 1)] == 0)) {
    nDiff--;
    i--;
  }
  if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
    lenWs = 1;
  } else {
    lenWs = ws.size(1);
  }
  //  Summing up rows in the differential operator
  b_i = diff_idx.size(1);
  for (coder::SizeType jDiff{0}; jDiff < b_i; jDiff++) {
    coder::SizeType iWeight;
    iWeight = 1;
    //  Loop through the operators
    for (coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > diff_idx.size(0)) ||
          (diff_idx[jDiff + diff_idx.size(1) * iOp] > 0)) {
        coder::SizeType i1;
        coder::SizeType offset;
        if (iOp + 1 > diff_idx.size(0)) {
          offset = 0;
        } else {
          offset = (diff_idx[jDiff + diff_idx.size(1) * iOp] - 1) *
                   b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i1 = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i1; iMonomial++) {
          coder::SizeType j;
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[(iWeight + ws.size(1) * iEval) - 1] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
      if (iWeight == lenWs) {
        iWeight = 1;
      } else {
        iWeight++;
      }
    }
  }
}

//  wls_var_bilap  Compute bi-Laplacian operators as weighted sum at
void wls_var_bilap(WlsObject *b_wls,
                   const ::coder::array<real_T, 2U> &eval_pnts,
                   const ::coder::array<real_T, 2U> &varargin_1,
                   const ::coder::array<real_T, 2U> &varargin_2,
                   coder::SizeType varargin_3,
                   ::coder::array<real_T, 2U> &varargout_1,
                   ::coder::array<real_T, 2U> &varargout_2)
{
  coder::SizeType bilap_size_idx_1;
  coder::SizeType i;
  coder::SizeType i1;
  coder::SizeType nDims;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T bilap_data[9];
  switch (b_wls->us.size(1)) {
  case 1:
    bilap_size_idx_1 = 1;
    bilap_data[0] = 4;
    break;
  case 2:
    if (b_wls->degree > 0) {
      bilap_size_idx_1 = 4;
      bilap_data[0] = 6;
      bilap_data[1] = 7;
      bilap_data[2] = 7;
      bilap_data[3] = 8;
    } else {
      bilap_size_idx_1 = 4;
      bilap_data[0] = 9;
      bilap_data[1] = 10;
      bilap_data[2] = 10;
      bilap_data[3] = 11;
    }
    break;
  default:
    if (b_wls->degree > 0) {
      bilap_size_idx_1 = 9;
      for (i = 0; i < 9; i++) {
        bilap_data[i] = iv[i];
      }
    } else {
      bilap_size_idx_1 = 9;
      for (i = 0; i < 9; i++) {
        bilap_data[i] = iv1[i];
      }
    }
    break;
  }
  nevpnts = varargin_3;
  if (varargin_3 == 0) {
    nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, nevpnts, b_wls->degree, b_wls->hs_inv.data,
             b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(1, u0);
  for (i = 0; i < u0; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  for (coder::SizeType jDiff{0}; jDiff < bilap_size_idx_1; jDiff++) {
    coder::SizeType offset;
    //  Loop through the operators
    offset = (bilap_data[jDiff] - 1) * b_wls->us.size(0);
    //  Sum up monomials weighted by weights for each component
    i = b_wls->ncols - b_wls->interp0;
    for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      coder::SizeType j;
      j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
      if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
        for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
          b_wls->rhs[iMonomial] =
              b_wls->rhs[iMonomial] +
              b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      } else {
        for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
          b_wls->rhs[iMonomial] =
              b_wls->rhs[iMonomial] +
              varargin_1[varargin_1.size(1) * iEval] *
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    u0 = b_wls->QR.size(1);
    for (i = 0; i < u0; i++) {
      bilap_size_idx_1 = b_wls->QR.size(0);
      for (i1 = 0; i1 < bilap_size_idx_1; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  }
  varargout_1.set_size(u1, 1);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    varargout_1[varargout_1.size(1) * (b_i + b_wls->interp0)] = b_wls->rhs[b_i];
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
      varargout_1[varargout_1.size(1) * iRow] =
          varargout_1[varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
    }
  }
  if (b_wls->interp0 != 0) {
    real_T s;
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    s = 0.0;
    for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
      s += varargout_1[varargout_1.size(1) * (b_i - 1)];
    }
    varargout_1[0] = 0.0 - s;
  }
  //  Step 4: Optionally, evaluate the operator
  if ((varargin_2.size(0) == 0) || (varargin_2.size(1) == 0)) {
    varargout_2.set_size(0, 1);
  } else {
    varargout_2.set_size(1, varargin_2.size(1));
    u0 = varargin_2.size(1);
    for (i = 0; i < u0; i++) {
      varargout_2[i] = 0.0;
    }
    //  Compute solution
    i = varargin_2.size(1);
    i1 = b_wls->nrows;
    for (coder::SizeType iFunc{0}; iFunc < i; iFunc++) {
      for (coder::SizeType iRow{0}; iRow < i1; iRow++) {
        varargout_2[iFunc] =
            varargout_2[iFunc] + varargin_2[iFunc + varargin_2.size(1) * iRow] *
                                     varargout_1[varargout_1.size(1) * iRow];
      }
    }
  }
}

//  wls_var_bilap  Compute bi-Laplacian operators as weighted sum at
void wls_var_bilap(WlsObject *b_wls,
                   const ::coder::array<real_T, 2U> &eval_pnts,
                   const ::coder::array<real_T, 2U> &varargin_1,
                   const ::coder::array<real_T, 2U> &varargin_2,
                   ::coder::array<real_T, 2U> &varargout_1,
                   ::coder::array<real_T, 2U> &varargout_2)
{
  coder::SizeType bilap_size_idx_1;
  coder::SizeType i;
  coder::SizeType i1;
  coder::SizeType nDims;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T bilap_data[9];
  switch (b_wls->us.size(1)) {
  case 1:
    bilap_size_idx_1 = 1;
    bilap_data[0] = 4;
    break;
  case 2:
    if (b_wls->degree > 0) {
      bilap_size_idx_1 = 4;
      bilap_data[0] = 6;
      bilap_data[1] = 7;
      bilap_data[2] = 7;
      bilap_data[3] = 8;
    } else {
      bilap_size_idx_1 = 4;
      bilap_data[0] = 9;
      bilap_data[1] = 10;
      bilap_data[2] = 10;
      bilap_data[3] = 11;
    }
    break;
  default:
    if (b_wls->degree > 0) {
      bilap_size_idx_1 = 9;
      for (i = 0; i < 9; i++) {
        bilap_data[i] = iv[i];
      }
    } else {
      bilap_size_idx_1 = 9;
      for (i = 0; i < 9; i++) {
        bilap_data[i] = iv1[i];
      }
    }
    break;
  }
  nevpnts = eval_pnts.size(0) - 1;
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv.data,
             b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(1, u0);
  for (i = 0; i < u0; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  for (coder::SizeType jDiff{0}; jDiff < bilap_size_idx_1; jDiff++) {
    coder::SizeType offset;
    //  Loop through the operators
    offset = (bilap_data[jDiff] - 1) * b_wls->us.size(0);
    //  Sum up monomials weighted by weights for each component
    i = b_wls->ncols - b_wls->interp0;
    for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      coder::SizeType j;
      j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
      if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
        for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial] =
              b_wls->rhs[iMonomial] +
              b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      } else {
        for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial] =
              b_wls->rhs[iMonomial] +
              varargin_1[varargin_1.size(1) * iEval] *
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    u0 = b_wls->QR.size(1);
    for (i = 0; i < u0; i++) {
      bilap_size_idx_1 = b_wls->QR.size(0);
      for (i1 = 0; i1 < bilap_size_idx_1; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  }
  varargout_1.set_size(u1, 1);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    varargout_1[varargout_1.size(1) * (b_i + b_wls->interp0)] = b_wls->rhs[b_i];
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
      varargout_1[varargout_1.size(1) * iRow] =
          varargout_1[varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
    }
  }
  if (b_wls->interp0 != 0) {
    real_T s;
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    s = 0.0;
    for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
      s += varargout_1[varargout_1.size(1) * (b_i - 1)];
    }
    varargout_1[0] = 0.0 - s;
  }
  //  Step 4: Optionally, evaluate the operator
  if ((varargin_2.size(0) == 0) || (varargin_2.size(1) == 0)) {
    varargout_2.set_size(0, 1);
  } else {
    varargout_2.set_size(1, varargin_2.size(1));
    u0 = varargin_2.size(1);
    for (i = 0; i < u0; i++) {
      varargout_2[i] = 0.0;
    }
    //  Compute solution
    i = varargin_2.size(1);
    i1 = b_wls->nrows;
    for (coder::SizeType iFunc{0}; iFunc < i; iFunc++) {
      for (coder::SizeType iRow{0}; iRow < i1; iRow++) {
        varargout_2[iFunc] =
            varargout_2[iFunc] + varargin_2[iFunc + varargin_2.size(1) * iRow] *
                                     varargout_1[varargout_1.size(1) * iRow];
      }
    }
  }
}

//  wls_var_bilap  Compute bi-Laplacian operators as weighted sum at
void wls_var_bilap(WlsObject *b_wls,
                   const ::coder::array<real_T, 2U> &eval_pnts,
                   ::coder::array<real_T, 2U> &varargout_1)
{
  coder::SizeType bilap_size_idx_1;
  coder::SizeType i;
  coder::SizeType nDims;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T bilap_data[9];
  switch (b_wls->us.size(1)) {
  case 1:
    bilap_size_idx_1 = 1;
    bilap_data[0] = 4;
    break;
  case 2:
    if (b_wls->degree > 0) {
      bilap_size_idx_1 = 4;
      bilap_data[0] = 6;
      bilap_data[1] = 7;
      bilap_data[2] = 7;
      bilap_data[3] = 8;
    } else {
      bilap_size_idx_1 = 4;
      bilap_data[0] = 9;
      bilap_data[1] = 10;
      bilap_data[2] = 10;
      bilap_data[3] = 11;
    }
    break;
  default:
    if (b_wls->degree > 0) {
      bilap_size_idx_1 = 9;
      for (i = 0; i < 9; i++) {
        bilap_data[i] = iv[i];
      }
    } else {
      bilap_size_idx_1 = 9;
      for (i = 0; i < 9; i++) {
        bilap_data[i] = iv1[i];
      }
    }
    break;
  }
  nevpnts = eval_pnts.size(0);
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv.data,
             b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(1, u0);
  for (i = 0; i < u0; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  for (coder::SizeType jDiff{0}; jDiff < bilap_size_idx_1; jDiff++) {
    coder::SizeType offset;
    //  Loop through the operators
    offset = (bilap_data[jDiff] - 1) * b_wls->us.size(0);
    //  Sum up monomials weighted by weights for each component
    i = b_wls->ncols - b_wls->interp0;
    for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      coder::SizeType j;
      j = b_wls->jpvt[iMonomial] + b_wls->interp0;
      for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
        b_wls->rhs[iMonomial] =
            b_wls->rhs[iMonomial] +
            b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    u0 = b_wls->QR.size(1);
    for (i = 0; i < u0; i++) {
      bilap_size_idx_1 = b_wls->QR.size(0);
      for (coder::SizeType i1{0}; i1 < bilap_size_idx_1; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  }
  varargout_1.set_size(u1, 1);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    varargout_1[varargout_1.size(1) * (b_i + b_wls->interp0)] = b_wls->rhs[b_i];
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
      varargout_1[varargout_1.size(1) * iRow] =
          varargout_1[varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
    }
  }
  if (b_wls->interp0 != 0) {
    real_T s;
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    s = 0.0;
    for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
      s += varargout_1[varargout_1.size(1) * (b_i - 1)];
    }
    varargout_1[0] = 0.0 - s;
  }
}

//  wls_var_bilap  Compute bi-Laplacian operators as weighted sum at
void wls_var_bilap(WlsObject *b_wls,
                   const ::coder::array<real_T, 2U> &eval_pnts,
                   const ::coder::array<real_T, 2U> &varargin_1,
                   ::coder::array<real_T, 2U> &varargout_1)
{
  coder::SizeType bilap_size_idx_1;
  coder::SizeType i;
  coder::SizeType nDims;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T bilap_data[9];
  switch (b_wls->us.size(1)) {
  case 1:
    bilap_size_idx_1 = 1;
    bilap_data[0] = 4;
    break;
  case 2:
    if (b_wls->degree > 0) {
      bilap_size_idx_1 = 4;
      bilap_data[0] = 6;
      bilap_data[1] = 7;
      bilap_data[2] = 7;
      bilap_data[3] = 8;
    } else {
      bilap_size_idx_1 = 4;
      bilap_data[0] = 9;
      bilap_data[1] = 10;
      bilap_data[2] = 10;
      bilap_data[3] = 11;
    }
    break;
  default:
    if (b_wls->degree > 0) {
      bilap_size_idx_1 = 9;
      for (i = 0; i < 9; i++) {
        bilap_data[i] = iv[i];
      }
    } else {
      bilap_size_idx_1 = 9;
      for (i = 0; i < 9; i++) {
        bilap_data[i] = iv1[i];
      }
    }
    break;
  }
  nevpnts = eval_pnts.size(0) - 1;
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv.data,
             b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(1, u0);
  for (i = 0; i < u0; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  for (coder::SizeType jDiff{0}; jDiff < bilap_size_idx_1; jDiff++) {
    coder::SizeType offset;
    //  Loop through the operators
    offset = (bilap_data[jDiff] - 1) * b_wls->us.size(0);
    //  Sum up monomials weighted by weights for each component
    i = b_wls->ncols - b_wls->interp0;
    for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      coder::SizeType j;
      j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
      if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
        for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial] =
              b_wls->rhs[iMonomial] +
              b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      } else {
        for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial] =
              b_wls->rhs[iMonomial] +
              varargin_1[varargin_1.size(1) * iEval] *
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    u0 = b_wls->QR.size(1);
    for (i = 0; i < u0; i++) {
      bilap_size_idx_1 = b_wls->QR.size(0);
      for (coder::SizeType i1{0}; i1 < bilap_size_idx_1; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  }
  varargout_1.set_size(u1, 1);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    varargout_1[varargout_1.size(1) * (b_i + b_wls->interp0)] = b_wls->rhs[b_i];
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
      varargout_1[varargout_1.size(1) * iRow] =
          varargout_1[varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
    }
  }
  if (b_wls->interp0 != 0) {
    real_T s;
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    s = 0.0;
    for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
      s += varargout_1[varargout_1.size(1) * (b_i - 1)];
    }
    varargout_1[0] = 0.0 - s;
  }
}

//  wls_var_curl  Variational curl operators as weighted sum at evaluation
void wls_var_curl(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  const ::coder::array<real_T, 2U> &ws,
                  const ::coder::array<real_T, 2U> &,
                  coder::SizeType varargin_1, ::coder::array<real_T, 2U> &vdops,
                  const real_T[], coder::SizeType result_size[2])
{
  if (ws.size(1) <= 1) {
    coder::SizeType b_i;
    coder::SizeType i;
    coder::SizeType i1;
    coder::SizeType j;
    coder::SizeType loop_ub;
    coder::SizeType nDiff;
    coder::SizeType nDims;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType nrows_vdops;
    coder::SizeType u0;
    coder::SizeType u1;
    nevpnts = varargin_1;
    if (varargin_1 == 0) {
      nevpnts = eval_pnts.size(0);
    }
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = nevpnts;
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((nevpnts + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType dim{0}; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[dim]) *
              b_wls->hs_inv.data[dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType dim{0}; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    b_gen_vander(b_wls->us, nevpnts, b_wls->degree, b_wls->hs_inv.data,
                 b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    nDiff = 8;
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(9, u0);
    loop_ub = u0 * 9;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    b_i = 9;
    while ((b_i > 0) && (iv2[b_i - 1] == 0)) {
      nDiff--;
      b_i--;
    }
    //  Summing up rows in the differential operator
    for (coder::SizeType iOp{0}; iOp <= nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > 9) || (iv2[iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > 9) {
          offset = 0;
        } else {
          offset = (iv2[iOp] - 1) * b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[ws.size(1) * iEval] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, 9);
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (i1 = 0; i1 < u0; i1++) {
          b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * i1];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, 9);
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                  b_wls->work);
    }
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      nrows_vdops = u0;
    } else {
      nrows_vdops = u1;
    }
    vdops.set_size(nrows_vdops, 9);
    //  Transpose the operator for row-major
    i = nrows_vdops - b_wls->interp0;
    for (b_i = 0; b_i < i; b_i++) {
      for (j = 0; j < 9; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < 9; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  In interp0 mode, set the first entry based on partition of unity
      i = b_wls->nstpnts;
      for (j = 0; j < 9; j++) {
        real_T s;
        real_T totalw;
        s = 0.0;
        for (b_i = 2; b_i <= i; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        if (iv2[j] > 1) {
          totalw = 0.0;
        } else {
          i1 = ws.size(0);
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            totalw = nevpnts;
            //  Unit weights summed together
          } else {
            //  All weights summed together
            totalw = 0.0;
            for (b_i = 0; b_i < i1; b_i++) {
              totalw += ws[ws.size(1) * b_i];
            }
          }
        }
        vdops[j] = totalw - s;
      }
    }
    i = b_wls->nrows;
    for (b_i = 0; b_i < i; b_i++) {
      real_T b_vdops;
      real_T c_vdops;
      real_T d_vdops;
      b_vdops = vdops[vdops.size(1) * b_i + 2];
      d_vdops = vdops[vdops.size(1) * b_i + 1];
      c_vdops = vdops[vdops.size(1) * b_i];
      vdops[vdops.size(1) * b_i] = 0.0;
      vdops[vdops.size(1) * b_i + 1] = -b_vdops;
      vdops[vdops.size(1) * b_i + 2] = d_vdops;
      vdops[vdops.size(1) * b_i + 3] = b_vdops;
      vdops[vdops.size(1) * b_i + 4] = 0.0;
      vdops[vdops.size(1) * b_i + 5] = -c_vdops;
      vdops[vdops.size(1) * b_i + 6] = -d_vdops;
      vdops[vdops.size(1) * b_i + 7] = c_vdops;
      vdops[vdops.size(1) * b_i + 8] = 0.0;
    }
  } else {
    coder::SizeType b_i;
    coder::SizeType i;
    coder::SizeType i1;
    coder::SizeType iWeight;
    coder::SizeType j;
    coder::SizeType lenWs;
    coder::SizeType loop_ub;
    coder::SizeType nDiff;
    coder::SizeType nDims;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType u0;
    coder::SizeType u1;
    nevpnts = varargin_1;
    if (varargin_1 == 0) {
      nevpnts = eval_pnts.size(0);
    }
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = nevpnts;
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((nevpnts + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType dim{0}; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[dim]) *
              b_wls->hs_inv.data[dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType dim{0}; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    b_gen_vander(b_wls->us, nevpnts, b_wls->degree, b_wls->hs_inv.data,
                 b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    nDiff = 8;
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(9, u0);
    loop_ub = u0 * 9;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    b_i = 9;
    while ((b_i > 0) && (iv3[b_i - 1] == 0)) {
      nDiff--;
      b_i--;
    }
    if (ws.size(0) == 0) {
      lenWs = 1;
    } else {
      lenWs = ws.size(1);
    }
    //  Summing up rows in the differential operator
    iWeight = 1;
    //  Loop through the operators
    for (coder::SizeType iOp{0}; iOp <= nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > 9) || (iv3[iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > 9) {
          offset = 0;
        } else {
          offset = (iv3[iOp] - 1) * b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if (ws.size(0) == 0) {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[(iWeight + ws.size(1) * iEval) - 1] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
      if (iWeight == lenWs) {
        iWeight = 1;
      } else {
        iWeight++;
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, 9);
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (i1 = 0; i1 < u0; i1++) {
          b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * i1];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, 9);
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                  b_wls->work);
    }
    vdops.set_size(u1, 9);
    //  Transpose the operator for row-major
    i = u1 - b_wls->interp0;
    for (b_i = 0; b_i < i; b_i++) {
      for (j = 0; j < 9; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < 9; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  In interp0 mode, set the first entry based on partition of unity
      iWeight = 1;
      i = b_wls->nstpnts;
      for (j = 0; j < 9; j++) {
        real_T s;
        real_T totalw;
        s = 0.0;
        for (b_i = 2; b_i <= i; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        if (iv3[j] > 1) {
          totalw = 0.0;
        } else {
          i1 = ws.size(0);
          if (ws.size(0) == 0) {
            totalw = nevpnts;
            //  Unit weights summed together
          } else {
            //  All weights summed together
            totalw = 0.0;
            for (b_i = 0; b_i < i1; b_i++) {
              totalw += ws[(iWeight + ws.size(1) * b_i) - 1];
            }
            iWeight += iWeight < ws.size(1);
          }
        }
        vdops[j] = totalw - s;
      }
    }
    i = b_wls->nrows;
    for (b_i = 0; b_i < i; b_i++) {
      real_T b_vdops;
      real_T c_vdops;
      real_T d_vdops;
      real_T e_vdops;
      real_T f_vdops;
      real_T g_vdops;
      b_vdops = vdops[vdops.size(1) * b_i + 3];
      c_vdops = vdops[vdops.size(1) * b_i];
      d_vdops = vdops[vdops.size(1) * b_i + 1];
      e_vdops = vdops[vdops.size(1) * b_i + 4];
      f_vdops = vdops[vdops.size(1) * b_i + 5];
      g_vdops = vdops[vdops.size(1) * b_i + 2];
      vdops[vdops.size(1) * b_i] = 0.0;
      vdops[vdops.size(1) * b_i + 1] = -b_vdops;
      vdops[vdops.size(1) * b_i + 2] = c_vdops;
      vdops[vdops.size(1) * b_i + 3] = d_vdops;
      vdops[vdops.size(1) * b_i + 4] = 0.0;
      vdops[vdops.size(1) * b_i + 5] = -e_vdops;
      vdops[vdops.size(1) * b_i + 6] = -f_vdops;
      vdops[vdops.size(1) * b_i + 7] = g_vdops;
      vdops[vdops.size(1) * b_i + 8] = 0.0;
    }
  }
  //  compute output value
  result_size[1] = 0;
  result_size[0] = 3;
}

//  wls_var_curl  Variational curl operators as weighted sum at evaluation
void wls_var_curl(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  const ::coder::array<real_T, 2U> &ws,
                  const ::coder::array<real_T, 2U> &fs,
                  ::coder::array<real_T, 2U> &vdops, real_T result_data[],
                  coder::SizeType result_size[2])
{
  real_T d_vdops;
  real_T e_vdops;
  real_T f_vdops;
  coder::SizeType b_i;
  coder::SizeType i;
  if (ws.size(1) <= 1) {
    coder::SizeType i1;
    coder::SizeType j;
    coder::SizeType loop_ub;
    coder::SizeType nDiff;
    coder::SizeType nDims;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType nrows_vdops;
    coder::SizeType u0;
    coder::SizeType u1;
    nevpnts = eval_pnts.size(0);
    //  Step 1: Tabulate monomial basis functions at evaluation points
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = eval_pnts.size(0);
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType dim{0}; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[dim]) *
              b_wls->hs_inv.data[dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType dim{0}; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    b_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree,
                 b_wls->hs_inv.data, b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    nDiff = 8;
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(9, u0);
    loop_ub = u0 * 9;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    b_i = 9;
    while ((b_i > 0) && (iv2[b_i - 1] == 0)) {
      nDiff--;
      b_i--;
    }
    //  Summing up rows in the differential operator
    for (coder::SizeType iOp{0}; iOp <= nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > 9) || (iv2[iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > 9) {
          offset = 0;
        } else {
          offset = (iv2[iOp] - 1) * b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[ws.size(1) * iEval] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, 9);
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (i1 = 0; i1 < u0; i1++) {
          b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * i1];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, 9);
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                  b_wls->work);
    }
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      nrows_vdops = u0;
    } else {
      nrows_vdops = u1;
    }
    vdops.set_size(nrows_vdops, 9);
    //  Transpose the operator for row-major
    i = nrows_vdops - b_wls->interp0;
    for (b_i = 0; b_i < i; b_i++) {
      for (j = 0; j < 9; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < 9; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  In interp0 mode, set the first entry based on partition of unity
      i = b_wls->nstpnts;
      for (j = 0; j < 9; j++) {
        real_T s;
        real_T totalw;
        s = 0.0;
        for (b_i = 2; b_i <= i; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        if (iv2[j] > 1) {
          totalw = 0.0;
        } else {
          i1 = ws.size(0);
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            totalw = nevpnts;
            //  Unit weights summed together
          } else {
            //  All weights summed together
            totalw = 0.0;
            for (b_i = 0; b_i < i1; b_i++) {
              totalw += ws[ws.size(1) * b_i];
            }
          }
        }
        vdops[j] = totalw - s;
      }
    }
    i = b_wls->nrows;
    for (b_i = 0; b_i < i; b_i++) {
      real_T b_vdops;
      real_T c_vdops;
      b_vdops = vdops[vdops.size(1) * b_i + 2];
      e_vdops = vdops[vdops.size(1) * b_i + 1];
      c_vdops = vdops[vdops.size(1) * b_i];
      vdops[vdops.size(1) * b_i] = 0.0;
      vdops[vdops.size(1) * b_i + 1] = -b_vdops;
      vdops[vdops.size(1) * b_i + 2] = e_vdops;
      vdops[vdops.size(1) * b_i + 3] = b_vdops;
      vdops[vdops.size(1) * b_i + 4] = 0.0;
      vdops[vdops.size(1) * b_i + 5] = -c_vdops;
      vdops[vdops.size(1) * b_i + 6] = -e_vdops;
      vdops[vdops.size(1) * b_i + 7] = c_vdops;
      vdops[vdops.size(1) * b_i + 8] = 0.0;
    }
  } else {
    coder::SizeType i1;
    coder::SizeType iWeight;
    coder::SizeType j;
    coder::SizeType lenWs;
    coder::SizeType loop_ub;
    coder::SizeType nDiff;
    coder::SizeType nDims;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType u0;
    coder::SizeType u1;
    nevpnts = eval_pnts.size(0);
    //  Step 1: Tabulate monomial basis functions at evaluation points
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = eval_pnts.size(0);
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType dim{0}; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[dim]) *
              b_wls->hs_inv.data[dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType dim{0}; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    b_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree,
                 b_wls->hs_inv.data, b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    nDiff = 8;
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(9, u0);
    loop_ub = u0 * 9;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    b_i = 9;
    while ((b_i > 0) && (iv3[b_i - 1] == 0)) {
      nDiff--;
      b_i--;
    }
    if (ws.size(0) == 0) {
      lenWs = 1;
    } else {
      lenWs = ws.size(1);
    }
    //  Summing up rows in the differential operator
    iWeight = 1;
    //  Loop through the operators
    for (coder::SizeType iOp{0}; iOp <= nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > 9) || (iv3[iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > 9) {
          offset = 0;
        } else {
          offset = (iv3[iOp] - 1) * b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if (ws.size(0) == 0) {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[(iWeight + ws.size(1) * iEval) - 1] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
      if (iWeight == lenWs) {
        iWeight = 1;
      } else {
        iWeight++;
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, 9);
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (i1 = 0; i1 < u0; i1++) {
          b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * i1];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, 9);
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                  b_wls->work);
    }
    vdops.set_size(u1, 9);
    //  Transpose the operator for row-major
    i = u1 - b_wls->interp0;
    for (b_i = 0; b_i < i; b_i++) {
      for (j = 0; j < 9; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < 9; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  In interp0 mode, set the first entry based on partition of unity
      iWeight = 1;
      i = b_wls->nstpnts;
      for (j = 0; j < 9; j++) {
        real_T s;
        real_T totalw;
        s = 0.0;
        for (b_i = 2; b_i <= i; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        if (iv3[j] > 1) {
          totalw = 0.0;
        } else {
          i1 = ws.size(0);
          if (ws.size(0) == 0) {
            totalw = nevpnts;
            //  Unit weights summed together
          } else {
            //  All weights summed together
            totalw = 0.0;
            for (b_i = 0; b_i < i1; b_i++) {
              totalw += ws[(iWeight + ws.size(1) * b_i) - 1];
            }
            iWeight += iWeight < ws.size(1);
          }
        }
        vdops[j] = totalw - s;
      }
    }
    i = b_wls->nrows;
    for (b_i = 0; b_i < i; b_i++) {
      real_T b_vdops;
      real_T c_vdops;
      real_T g_vdops;
      b_vdops = vdops[vdops.size(1) * b_i + 3];
      c_vdops = vdops[vdops.size(1) * b_i];
      d_vdops = vdops[vdops.size(1) * b_i + 1];
      f_vdops = vdops[vdops.size(1) * b_i + 4];
      e_vdops = vdops[vdops.size(1) * b_i + 5];
      g_vdops = vdops[vdops.size(1) * b_i + 2];
      vdops[vdops.size(1) * b_i] = 0.0;
      vdops[vdops.size(1) * b_i + 1] = -b_vdops;
      vdops[vdops.size(1) * b_i + 2] = c_vdops;
      vdops[vdops.size(1) * b_i + 3] = d_vdops;
      vdops[vdops.size(1) * b_i + 4] = 0.0;
      vdops[vdops.size(1) * b_i + 5] = -f_vdops;
      vdops[vdops.size(1) * b_i + 6] = -e_vdops;
      vdops[vdops.size(1) * b_i + 7] = g_vdops;
      vdops[vdops.size(1) * b_i + 8] = 0.0;
    }
  }
  //  compute output value
  if ((fs.size(0) != 0) && (fs.size(1) != 0)) {
    result_size[1] = 1;
    result_size[0] = 3;
    result_data[0] = 0.0;
    result_data[1] = 0.0;
    result_data[2] = 0.0;
    i = b_wls->nrows;
    for (b_i = 0; b_i < i; b_i++) {
      e_vdops = fs[fs.size(1) * b_i + 1];
      d_vdops = fs[fs.size(1) * b_i + 2];
      result_data[0] =
          (result_data[0] + vdops[vdops.size(1) * b_i + 1] * e_vdops) +
          vdops[vdops.size(1) * b_i + 2] * d_vdops;
      f_vdops = fs[fs.size(1) * b_i];
      result_data[1] =
          (result_data[1] + f_vdops * vdops[vdops.size(1) * b_i + 3]) +
          d_vdops * vdops[vdops.size(1) * b_i + 5];
      result_data[2] =
          (result_data[2] + f_vdops * vdops[vdops.size(1) * b_i + 6]) +
          e_vdops * vdops[vdops.size(1) * b_i + 7];
    }
  } else {
    result_size[1] = 0;
    result_size[0] = 3;
  }
}

//  wls_var_curl  Variational curl operators as weighted sum at evaluation
void wls_var_curl(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  ::coder::array<real_T, 2U> &vdops)
{
  coder::SizeType b_i;
  coder::SizeType i;
  coder::SizeType j;
  coder::SizeType loop_ub;
  coder::SizeType nDiff;
  coder::SizeType nDims;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  nevpnts = eval_pnts.size(0);
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  b_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv.data,
               b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  nDiff = 8;
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(9, u0);
  loop_ub = u0 * 9;
  for (i = 0; i < loop_ub; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  b_i = 9;
  while ((b_i > 0) && (iv2[b_i - 1] == 0)) {
    nDiff--;
    b_i--;
  }
  //  Summing up rows in the differential operator
  for (coder::SizeType iOp{0}; iOp <= nDiff; iOp++) {
    //  Skip padded zeros in the differential operator
    if ((iOp + 1 > 9) || (iv2[iOp] > 0)) {
      coder::SizeType offset;
      if (iOp + 1 > 9) {
        offset = 0;
      } else {
        offset = (iv2[iOp] - 1) * b_wls->us.size(0);
      }
      //  Sum up monomials weighted by weights for each component
      i = b_wls->ncols - b_wls->interp0;
      for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
        j = b_wls->jpvt[iMonomial] + b_wls->interp0;
        for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
        }
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 9);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (coder::SizeType i1{0}; i1 < u0; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 9);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                b_wls->work);
  }
  vdops.set_size(u1, 9);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (b_i = 0; b_i < i; b_i++) {
    for (j = 0; j < 9; j++) {
      vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < 9; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    for (j = 0; j < 9; j++) {
      real_T s;
      coder::SizeType totalw;
      s = 0.0;
      for (b_i = 2; b_i <= i; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      if (iv2[j] > 1) {
        totalw = 0;
      } else {
        totalw = nevpnts;
        //  Unit weights summed together
      }
      vdops[j] = static_cast<real_T>(totalw) - s;
    }
  }
  i = b_wls->nrows;
  for (b_i = 0; b_i < i; b_i++) {
    real_T b_vdops;
    real_T c_vdops;
    real_T d;
    b_vdops = vdops[vdops.size(1) * b_i + 2];
    d = vdops[vdops.size(1) * b_i + 1];
    c_vdops = vdops[vdops.size(1) * b_i];
    vdops[vdops.size(1) * b_i] = 0.0;
    vdops[vdops.size(1) * b_i + 1] = -b_vdops;
    vdops[vdops.size(1) * b_i + 2] = d;
    vdops[vdops.size(1) * b_i + 3] = b_vdops;
    vdops[vdops.size(1) * b_i + 4] = 0.0;
    vdops[vdops.size(1) * b_i + 5] = -c_vdops;
    vdops[vdops.size(1) * b_i + 6] = -d;
    vdops[vdops.size(1) * b_i + 7] = c_vdops;
    vdops[vdops.size(1) * b_i + 8] = 0.0;
  }
  //  compute output value
}

//  wls_var_curl  Variational curl operators as weighted sum at evaluation
void wls_var_curl(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  const ::coder::array<real_T, 2U> &ws,
                  ::coder::array<real_T, 2U> &vdops)
{
  if (ws.size(1) <= 1) {
    coder::SizeType b_i;
    coder::SizeType i;
    coder::SizeType i1;
    coder::SizeType j;
    coder::SizeType loop_ub;
    coder::SizeType nDiff;
    coder::SizeType nDims;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType nrows_vdops;
    coder::SizeType u0;
    coder::SizeType u1;
    nevpnts = eval_pnts.size(0);
    //  Step 1: Tabulate monomial basis functions at evaluation points
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = eval_pnts.size(0);
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType dim{0}; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[dim]) *
              b_wls->hs_inv.data[dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType dim{0}; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    b_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree,
                 b_wls->hs_inv.data, b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    nDiff = 8;
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(9, u0);
    loop_ub = u0 * 9;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    b_i = 9;
    while ((b_i > 0) && (iv2[b_i - 1] == 0)) {
      nDiff--;
      b_i--;
    }
    //  Summing up rows in the differential operator
    for (coder::SizeType iOp{0}; iOp <= nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > 9) || (iv2[iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > 9) {
          offset = 0;
        } else {
          offset = (iv2[iOp] - 1) * b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[ws.size(1) * iEval] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, 9);
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (i1 = 0; i1 < u0; i1++) {
          b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * i1];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, 9);
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                  b_wls->work);
    }
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      nrows_vdops = u0;
    } else {
      nrows_vdops = u1;
    }
    vdops.set_size(nrows_vdops, 9);
    //  Transpose the operator for row-major
    i = nrows_vdops - b_wls->interp0;
    for (b_i = 0; b_i < i; b_i++) {
      for (j = 0; j < 9; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < 9; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  In interp0 mode, set the first entry based on partition of unity
      i = b_wls->nstpnts;
      for (j = 0; j < 9; j++) {
        real_T s;
        real_T totalw;
        s = 0.0;
        for (b_i = 2; b_i <= i; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        if (iv2[j] > 1) {
          totalw = 0.0;
        } else {
          i1 = ws.size(0);
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            totalw = nevpnts;
            //  Unit weights summed together
          } else {
            //  All weights summed together
            totalw = 0.0;
            for (b_i = 0; b_i < i1; b_i++) {
              totalw += ws[ws.size(1) * b_i];
            }
          }
        }
        vdops[j] = totalw - s;
      }
    }
    i = b_wls->nrows;
    for (b_i = 0; b_i < i; b_i++) {
      real_T b_vdops;
      real_T c_vdops;
      real_T d_vdops;
      b_vdops = vdops[vdops.size(1) * b_i + 2];
      d_vdops = vdops[vdops.size(1) * b_i + 1];
      c_vdops = vdops[vdops.size(1) * b_i];
      vdops[vdops.size(1) * b_i] = 0.0;
      vdops[vdops.size(1) * b_i + 1] = -b_vdops;
      vdops[vdops.size(1) * b_i + 2] = d_vdops;
      vdops[vdops.size(1) * b_i + 3] = b_vdops;
      vdops[vdops.size(1) * b_i + 4] = 0.0;
      vdops[vdops.size(1) * b_i + 5] = -c_vdops;
      vdops[vdops.size(1) * b_i + 6] = -d_vdops;
      vdops[vdops.size(1) * b_i + 7] = c_vdops;
      vdops[vdops.size(1) * b_i + 8] = 0.0;
    }
  } else {
    coder::SizeType b_i;
    coder::SizeType i;
    coder::SizeType i1;
    coder::SizeType iWeight;
    coder::SizeType j;
    coder::SizeType lenWs;
    coder::SizeType loop_ub;
    coder::SizeType nDiff;
    coder::SizeType nDims;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType u0;
    coder::SizeType u1;
    nevpnts = eval_pnts.size(0);
    //  Step 1: Tabulate monomial basis functions at evaluation points
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = eval_pnts.size(0);
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType dim{0}; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[dim]) *
              b_wls->hs_inv.data[dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType dim{0}; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    b_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree,
                 b_wls->hs_inv.data, b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    nDiff = 8;
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(9, u0);
    loop_ub = u0 * 9;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    b_i = 9;
    while ((b_i > 0) && (iv3[b_i - 1] == 0)) {
      nDiff--;
      b_i--;
    }
    if (ws.size(0) == 0) {
      lenWs = 1;
    } else {
      lenWs = ws.size(1);
    }
    //  Summing up rows in the differential operator
    iWeight = 1;
    //  Loop through the operators
    for (coder::SizeType iOp{0}; iOp <= nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > 9) || (iv3[iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > 9) {
          offset = 0;
        } else {
          offset = (iv3[iOp] - 1) * b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if (ws.size(0) == 0) {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[(iWeight + ws.size(1) * iEval) - 1] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
      if (iWeight == lenWs) {
        iWeight = 1;
      } else {
        iWeight++;
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, 9);
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (i1 = 0; i1 < u0; i1++) {
          b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * i1];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, 9);
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                  b_wls->work);
    }
    vdops.set_size(u1, 9);
    //  Transpose the operator for row-major
    i = u1 - b_wls->interp0;
    for (b_i = 0; b_i < i; b_i++) {
      for (j = 0; j < 9; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < 9; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  In interp0 mode, set the first entry based on partition of unity
      iWeight = 1;
      i = b_wls->nstpnts;
      for (j = 0; j < 9; j++) {
        real_T s;
        real_T totalw;
        s = 0.0;
        for (b_i = 2; b_i <= i; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        if (iv3[j] > 1) {
          totalw = 0.0;
        } else {
          i1 = ws.size(0);
          if (ws.size(0) == 0) {
            totalw = nevpnts;
            //  Unit weights summed together
          } else {
            //  All weights summed together
            totalw = 0.0;
            for (b_i = 0; b_i < i1; b_i++) {
              totalw += ws[(iWeight + ws.size(1) * b_i) - 1];
            }
            iWeight += iWeight < ws.size(1);
          }
        }
        vdops[j] = totalw - s;
      }
    }
    i = b_wls->nrows;
    for (b_i = 0; b_i < i; b_i++) {
      real_T b_vdops;
      real_T c_vdops;
      real_T d_vdops;
      real_T e_vdops;
      real_T f_vdops;
      real_T g_vdops;
      b_vdops = vdops[vdops.size(1) * b_i + 3];
      c_vdops = vdops[vdops.size(1) * b_i];
      d_vdops = vdops[vdops.size(1) * b_i + 1];
      e_vdops = vdops[vdops.size(1) * b_i + 4];
      f_vdops = vdops[vdops.size(1) * b_i + 5];
      g_vdops = vdops[vdops.size(1) * b_i + 2];
      vdops[vdops.size(1) * b_i] = 0.0;
      vdops[vdops.size(1) * b_i + 1] = -b_vdops;
      vdops[vdops.size(1) * b_i + 2] = c_vdops;
      vdops[vdops.size(1) * b_i + 3] = d_vdops;
      vdops[vdops.size(1) * b_i + 4] = 0.0;
      vdops[vdops.size(1) * b_i + 5] = -e_vdops;
      vdops[vdops.size(1) * b_i + 6] = -f_vdops;
      vdops[vdops.size(1) * b_i + 7] = g_vdops;
      vdops[vdops.size(1) * b_i + 8] = 0.0;
    }
  }
  //  compute output value
}

//  wls_var_curl_curl  Variational curl-curl operators as weighted sum at
void wls_var_curl_curl(WlsObject *b_wls,
                       const ::coder::array<real_T, 2U> &eval_pnts,
                       const ::coder::array<real_T, 2U> &ws,
                       const ::coder::array<real_T, 2U> &,
                       coder::SizeType varargin_1,
                       ::coder::array<real_T, 2U> &vdops, const real_T[],
                       coder::SizeType result_size[2])
{
  coder::SizeType dim;
  dim = b_wls->us.size(1);
  //  compute and reorganize vdops
  if (ws.size(1) <= 1) {
    coder::SizeType b_i;
    coder::SizeType hess_size;
    coder::SizeType i;
    coder::SizeType j;
    coder::SizeType loop_ub;
    coder::SizeType nDiff;
    coder::SizeType nDims;
    coder::SizeType nRhs;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType u0;
    coder::SizeType u1;
    int8_T hess_data[9];
    //  All components share the same weight, we need to compute Hessian
    switch (b_wls->us.size(1)) {
    case 1:
      hess_size = 1;
      hess_data[0] = 0;
      break;
    case 2:
      hess_size = 4;
      hess_data[0] = 4;
      hess_data[1] = 5;
      hess_data[2] = 6;
      hess_data[3] = 0;
      break;
    default:
      hess_size = 9;
      for (i = 0; i < 9; i++) {
        hess_data[i] = iv4[i];
      }
      break;
    }
    nevpnts = varargin_1;
    if (varargin_1 == 0) {
      nevpnts = eval_pnts.size(0);
    }
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = nevpnts;
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((nevpnts + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
          b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[b_dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[b_dim]) *
              b_wls->hs_inv.data[b_dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
          b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[b_dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[b_dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    c_gen_vander(b_wls->us, nevpnts, b_wls->degree, b_wls->hs_inv.data,
                 b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    nDiff = hess_size;
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(hess_size, u0);
    loop_ub = u0 * hess_size;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    b_i = hess_size;
    while ((b_i > 0) && (b_i <= hess_size) && (hess_data[b_i - 1] == 0)) {
      nDiff--;
      b_i--;
    }
    //  Summing up rows in the differential operator
    for (coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > hess_size) || (hess_data[iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > hess_size) {
          offset = 0;
        } else {
          offset = (hess_data[iOp] - 1) * b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[ws.size(1) * iEval] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    nRhs = b_wls->rhs.size(0);
    //  Multiply by generalized inverse of Vandermonde matrix
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (hess_size = 0; hess_size < u0; hess_size++) {
          b_wls->QRt[hess_size + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * hess_size];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    }
    vdops.set_size(u1, nRhs);
    //  Transpose the operator for row-major
    i = u1 - b_wls->interp0;
    for (b_i = 0; b_i < i; b_i++) {
      for (j = 0; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < nRhs; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  In interp0 mode, set the first entry based on partition of unity
      i = b_wls->nstpnts;
      for (j = 0; j < nRhs; j++) {
        real_T s;
        real_T totalw;
        s = 0.0;
        for (b_i = 2; b_i <= i; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        if (hess_data[j] > 1) {
          totalw = 0.0;
        } else {
          hess_size = ws.size(0);
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            totalw = nevpnts;
            //  Unit weights summed together
          } else {
            //  All weights summed together
            totalw = 0.0;
            for (b_i = 0; b_i < hess_size; b_i++) {
              totalw += ws[ws.size(1) * b_i];
            }
          }
        }
        vdops[j] = totalw - s;
      }
    }
    if (dim == 2) {
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        real_T b_vdops;
        real_T c_vdops;
        b_vdops = vdops[vdops.size(1) * b_i + 1];
        c_vdops = vdops[vdops.size(1) * b_i];
        vdops[vdops.size(1) * b_i] = -vdops[vdops.size(1) * b_i + 2];
        vdops[vdops.size(1) * b_i + 1] = b_vdops;
        vdops[vdops.size(1) * b_i + 2] = b_vdops;
        vdops[vdops.size(1) * b_i + 3] = -c_vdops;
      }
    } else if (dim == 3) {
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        real_T b_vdops;
        real_T c_vdops;
        real_T d;
        real_T d1;
        real_T d_vdops;
        real_T e_vdops;
        b_vdops = vdops[vdops.size(1) * b_i + 2];
        c_vdops = vdops[vdops.size(1) * b_i + 5];
        d_vdops = vdops[vdops.size(1) * b_i + 1];
        e_vdops = vdops[vdops.size(1) * b_i + 3];
        d = vdops[vdops.size(1) * b_i];
        d1 = vdops[vdops.size(1) * b_i + 4];
        vdops[vdops.size(1) * b_i] = -b_vdops - c_vdops;
        vdops[vdops.size(1) * b_i + 1] = d_vdops;
        vdops[vdops.size(1) * b_i + 2] = e_vdops;
        vdops[vdops.size(1) * b_i + 3] = d_vdops;
        vdops[vdops.size(1) * b_i + 4] = -d - c_vdops;
        vdops[vdops.size(1) * b_i + 5] = d1;
        vdops[vdops.size(1) * b_i + 6] = e_vdops;
        vdops[vdops.size(1) * b_i + 7] = d1;
        vdops[vdops.size(1) * b_i + 8] = -d - b_vdops;
      }
    }
  } else {
    coder::SizeType b_i;
    coder::SizeType grad_div_size_idx_0;
    coder::SizeType grad_div_size_idx_1;
    coder::SizeType hess_size;
    coder::SizeType i;
    coder::SizeType iWeight;
    coder::SizeType j;
    coder::SizeType lenWs;
    coder::SizeType loop_ub;
    coder::SizeType nDiff;
    coder::SizeType nDims;
    coder::SizeType nRhs;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType nrows_vdops;
    coder::SizeType u0;
    coder::SizeType u1;
    int8_T grad_div_data[18];
    //  Each component has its own weight, so we need to compute all components
    switch (b_wls->us.size(1)) {
    case 1:
      grad_div_size_idx_1 = 1;
      grad_div_size_idx_0 = 1;
      grad_div_data[0] = 0;
      break;
    case 2:
      grad_div_size_idx_1 = 1;
      grad_div_size_idx_0 = 4;
      grad_div_data[0] = 6;
      grad_div_data[1] = 5;
      grad_div_data[2] = 5;
      grad_div_data[3] = 4;
      break;
    default:
      grad_div_size_idx_1 = 2;
      grad_div_size_idx_0 = 9;
      for (i = 0; i < 18; i++) {
        grad_div_data[i] = iv5[i];
      }
      break;
    }
    nevpnts = varargin_1;
    if (varargin_1 == 0) {
      nevpnts = eval_pnts.size(0);
    }
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = nevpnts;
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((nevpnts + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
          b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[b_dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[b_dim]) *
              b_wls->hs_inv.data[b_dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
          b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[b_dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[b_dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    c_gen_vander(b_wls->us, nevpnts, b_wls->degree, b_wls->hs_inv.data,
                 b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    nDiff = grad_div_size_idx_0;
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(grad_div_size_idx_0, u0);
    loop_ub = u0 * grad_div_size_idx_0;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    b_i = grad_div_size_idx_0;
    while ((b_i > 0) && (b_i <= grad_div_size_idx_0) &&
           (grad_div_data[grad_div_size_idx_1 * (b_i - 1)] == 0)) {
      nDiff--;
      b_i--;
    }
    if (ws.size(0) == 0) {
      lenWs = 1;
    } else {
      lenWs = ws.size(1);
    }
    //  Summing up rows in the differential operator
    for (coder::SizeType jDiff{0}; jDiff < grad_div_size_idx_1; jDiff++) {
      iWeight = 1;
      //  Loop through the operators
      for (coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
        //  Skip padded zeros in the differential operator
        if ((iOp + 1 > grad_div_size_idx_0) ||
            (grad_div_data[jDiff + grad_div_size_idx_1 * iOp] > 0)) {
          coder::SizeType offset;
          if (iOp + 1 > grad_div_size_idx_0) {
            offset = 0;
          } else {
            offset = (grad_div_data[jDiff + grad_div_size_idx_1 * iOp] - 1) *
                     b_wls->us.size(0);
          }
          //  Sum up monomials weighted by weights for each component
          i = b_wls->ncols - b_wls->interp0;
          for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
            j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
            if (ws.size(0) == 0) {
              for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                    b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                    b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
              }
            } else {
              for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                    b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                    ws[(iWeight + ws.size(1) * iEval) - 1] *
                        b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
              }
            }
          }
        }
        if (iWeight == lenWs) {
          iWeight = 1;
        } else {
          iWeight++;
        }
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    nRhs = b_wls->rhs.size(0);
    //  Multiply by generalized inverse of Vandermonde matrix
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (hess_size = 0; hess_size < u0; hess_size++) {
          b_wls->QRt[hess_size + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * hess_size];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    }
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      nrows_vdops = u0;
    } else {
      nrows_vdops = u1;
    }
    vdops.set_size(nrows_vdops, nRhs);
    //  Transpose the operator for row-major
    i = nrows_vdops - b_wls->interp0;
    for (b_i = 0; b_i < i; b_i++) {
      for (j = 0; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < nRhs; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      boolean_T b;
      //  In interp0 mode, set the first entry based on partition of unity
      iWeight = 1;
      b = true;
      i = grad_div_size_idx_0 * grad_div_size_idx_1;
      hess_size = 0;
      u0 = b_wls->nstpnts;
      for (j = 0; j < nRhs; j++) {
        real_T s;
        real_T totalw;
        if (j >= i) {
          hess_size = 0;
          b = true;
        } else if (b) {
          b = false;
          hess_size = j % grad_div_size_idx_0 * grad_div_size_idx_1 +
                      j / grad_div_size_idx_0;
        } else if (hess_size > MAX_int32_T - grad_div_size_idx_1) {
          hess_size = j % grad_div_size_idx_0 * grad_div_size_idx_1 +
                      j / grad_div_size_idx_0;
        } else {
          hess_size += grad_div_size_idx_1;
          if (hess_size > i - 1) {
            hess_size = (hess_size - i) + 1;
          }
        }
        s = 0.0;
        for (b_i = 2; b_i <= u0; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        if (grad_div_data[hess_size] > 1) {
          totalw = 0.0;
        } else {
          loop_ub = ws.size(0);
          if (ws.size(0) == 0) {
            totalw = nevpnts;
            //  Unit weights summed together
          } else {
            //  All weights summed together
            totalw = 0.0;
            for (b_i = 0; b_i < loop_ub; b_i++) {
              totalw += ws[(iWeight + ws.size(1) * b_i) - 1];
            }
            iWeight += iWeight < ws.size(1);
          }
        }
        vdops[j] = totalw - s;
      }
    }
    //  Flip the signs of diagonal entries
    if (dim == 2) {
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        vdops[vdops.size(1) * b_i] = -vdops[vdops.size(1) * b_i];
        vdops[vdops.size(1) * b_i + 3] = -vdops[vdops.size(1) * b_i + 3];
      }
    } else if (dim == 3) {
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        vdops[vdops.size(1) * b_i] = -vdops[vdops.size(1) * b_i];
        vdops[vdops.size(1) * b_i + 4] = -vdops[vdops.size(1) * b_i + 4];
        vdops[vdops.size(1) * b_i + 8] = -vdops[vdops.size(1) * b_i + 8];
      }
    }
  }
  //  compute output value
  result_size[1] = 0;
  result_size[0] = 3;
}

//  wls_var_curl_curl  Variational curl-curl operators as weighted sum at
void wls_var_curl_curl(WlsObject *b_wls,
                       const ::coder::array<real_T, 2U> &eval_pnts,
                       const ::coder::array<real_T, 2U> &ws,
                       const ::coder::array<real_T, 2U> &fs,
                       ::coder::array<real_T, 2U> &vdops, real_T result_data[],
                       coder::SizeType result_size[2])
{
  real_T b_vdops;
  real_T d;
  real_T d1;
  coder::SizeType b_i;
  coder::SizeType dim;
  coder::SizeType i;
  dim = b_wls->us.size(1);
  //  compute and reorganize vdops
  if (ws.size(1) <= 1) {
    coder::SizeType hess_size;
    coder::SizeType j;
    coder::SizeType loop_ub;
    coder::SizeType nDiff;
    coder::SizeType nDims;
    coder::SizeType nRhs;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType u0;
    coder::SizeType u1;
    int8_T hess_data[9];
    //  All components share the same weight, we need to compute Hessian
    switch (b_wls->us.size(1)) {
    case 1:
      hess_size = 1;
      hess_data[0] = 0;
      break;
    case 2:
      hess_size = 4;
      hess_data[0] = 4;
      hess_data[1] = 5;
      hess_data[2] = 6;
      hess_data[3] = 0;
      break;
    default:
      hess_size = 9;
      for (i = 0; i < 9; i++) {
        hess_data[i] = iv4[i];
      }
      break;
    }
    nevpnts = eval_pnts.size(0);
    //  Step 1: Tabulate monomial basis functions at evaluation points
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = eval_pnts.size(0);
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
          b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[b_dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[b_dim]) *
              b_wls->hs_inv.data[b_dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
          b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[b_dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[b_dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    c_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree,
                 b_wls->hs_inv.data, b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    nDiff = hess_size;
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(hess_size, u0);
    loop_ub = u0 * hess_size;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    b_i = hess_size;
    while ((b_i > 0) && (b_i <= hess_size) && (hess_data[b_i - 1] == 0)) {
      nDiff--;
      b_i--;
    }
    //  Summing up rows in the differential operator
    for (coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > hess_size) || (hess_data[iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > hess_size) {
          offset = 0;
        } else {
          offset = (hess_data[iOp] - 1) * b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[ws.size(1) * iEval] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    nRhs = b_wls->rhs.size(0);
    //  Multiply by generalized inverse of Vandermonde matrix
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (hess_size = 0; hess_size < u0; hess_size++) {
          b_wls->QRt[hess_size + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * hess_size];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    }
    vdops.set_size(u1, nRhs);
    //  Transpose the operator for row-major
    i = u1 - b_wls->interp0;
    for (b_i = 0; b_i < i; b_i++) {
      for (j = 0; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < nRhs; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  In interp0 mode, set the first entry based on partition of unity
      i = b_wls->nstpnts;
      for (j = 0; j < nRhs; j++) {
        real_T s;
        real_T totalw;
        s = 0.0;
        for (b_i = 2; b_i <= i; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        if (hess_data[j] > 1) {
          totalw = 0.0;
        } else {
          hess_size = ws.size(0);
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            totalw = nevpnts;
            //  Unit weights summed together
          } else {
            //  All weights summed together
            totalw = 0.0;
            for (b_i = 0; b_i < hess_size; b_i++) {
              totalw += ws[ws.size(1) * b_i];
            }
          }
        }
        vdops[j] = totalw - s;
      }
    }
    if (dim == 2) {
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        real_T c_vdops;
        b_vdops = vdops[vdops.size(1) * b_i + 1];
        c_vdops = vdops[vdops.size(1) * b_i];
        vdops[vdops.size(1) * b_i] = -vdops[vdops.size(1) * b_i + 2];
        vdops[vdops.size(1) * b_i + 1] = b_vdops;
        vdops[vdops.size(1) * b_i + 2] = b_vdops;
        vdops[vdops.size(1) * b_i + 3] = -c_vdops;
      }
    } else if (dim == 3) {
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        real_T c_vdops;
        real_T d_vdops;
        real_T e_vdops;
        b_vdops = vdops[vdops.size(1) * b_i + 2];
        c_vdops = vdops[vdops.size(1) * b_i + 5];
        d_vdops = vdops[vdops.size(1) * b_i + 1];
        e_vdops = vdops[vdops.size(1) * b_i + 3];
        d = vdops[vdops.size(1) * b_i];
        d1 = vdops[vdops.size(1) * b_i + 4];
        vdops[vdops.size(1) * b_i] = -b_vdops - c_vdops;
        vdops[vdops.size(1) * b_i + 1] = d_vdops;
        vdops[vdops.size(1) * b_i + 2] = e_vdops;
        vdops[vdops.size(1) * b_i + 3] = d_vdops;
        vdops[vdops.size(1) * b_i + 4] = -d - c_vdops;
        vdops[vdops.size(1) * b_i + 5] = d1;
        vdops[vdops.size(1) * b_i + 6] = e_vdops;
        vdops[vdops.size(1) * b_i + 7] = d1;
        vdops[vdops.size(1) * b_i + 8] = -d - b_vdops;
      }
    }
  } else {
    coder::SizeType grad_div_size_idx_0;
    coder::SizeType grad_div_size_idx_1;
    coder::SizeType hess_size;
    coder::SizeType iWeight;
    coder::SizeType j;
    coder::SizeType lenWs;
    coder::SizeType loop_ub;
    coder::SizeType nDiff;
    coder::SizeType nDims;
    coder::SizeType nRhs;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType nrows_vdops;
    coder::SizeType u0;
    coder::SizeType u1;
    int8_T grad_div_data[18];
    //  Each component has its own weight, so we need to compute all components
    switch (b_wls->us.size(1)) {
    case 1:
      grad_div_size_idx_1 = 1;
      grad_div_size_idx_0 = 1;
      grad_div_data[0] = 0;
      break;
    case 2:
      grad_div_size_idx_1 = 1;
      grad_div_size_idx_0 = 4;
      grad_div_data[0] = 6;
      grad_div_data[1] = 5;
      grad_div_data[2] = 5;
      grad_div_data[3] = 4;
      break;
    default:
      grad_div_size_idx_1 = 2;
      grad_div_size_idx_0 = 9;
      for (i = 0; i < 18; i++) {
        grad_div_data[i] = iv5[i];
      }
      break;
    }
    nevpnts = eval_pnts.size(0);
    //  Step 1: Tabulate monomial basis functions at evaluation points
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = eval_pnts.size(0);
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
          b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[b_dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[b_dim]) *
              b_wls->hs_inv.data[b_dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
          b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[b_dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[b_dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    c_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree,
                 b_wls->hs_inv.data, b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    nDiff = grad_div_size_idx_0;
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(grad_div_size_idx_0, u0);
    loop_ub = u0 * grad_div_size_idx_0;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    b_i = grad_div_size_idx_0;
    while ((b_i > 0) && (b_i <= grad_div_size_idx_0) &&
           (grad_div_data[grad_div_size_idx_1 * (b_i - 1)] == 0)) {
      nDiff--;
      b_i--;
    }
    if (ws.size(0) == 0) {
      lenWs = 1;
    } else {
      lenWs = ws.size(1);
    }
    //  Summing up rows in the differential operator
    for (coder::SizeType jDiff{0}; jDiff < grad_div_size_idx_1; jDiff++) {
      iWeight = 1;
      //  Loop through the operators
      for (coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
        //  Skip padded zeros in the differential operator
        if ((iOp + 1 > grad_div_size_idx_0) ||
            (grad_div_data[jDiff + grad_div_size_idx_1 * iOp] > 0)) {
          coder::SizeType offset;
          if (iOp + 1 > grad_div_size_idx_0) {
            offset = 0;
          } else {
            offset = (grad_div_data[jDiff + grad_div_size_idx_1 * iOp] - 1) *
                     b_wls->us.size(0);
          }
          //  Sum up monomials weighted by weights for each component
          i = b_wls->ncols - b_wls->interp0;
          for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
            j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
            if (ws.size(0) == 0) {
              for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                    b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                    b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
              }
            } else {
              for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                    b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                    ws[(iWeight + ws.size(1) * iEval) - 1] *
                        b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
              }
            }
          }
        }
        if (iWeight == lenWs) {
          iWeight = 1;
        } else {
          iWeight++;
        }
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    nRhs = b_wls->rhs.size(0);
    //  Multiply by generalized inverse of Vandermonde matrix
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (hess_size = 0; hess_size < u0; hess_size++) {
          b_wls->QRt[hess_size + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * hess_size];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    }
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      nrows_vdops = u0;
    } else {
      nrows_vdops = u1;
    }
    vdops.set_size(nrows_vdops, nRhs);
    //  Transpose the operator for row-major
    i = nrows_vdops - b_wls->interp0;
    for (b_i = 0; b_i < i; b_i++) {
      for (j = 0; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < nRhs; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      boolean_T b;
      //  In interp0 mode, set the first entry based on partition of unity
      iWeight = 1;
      b = true;
      i = grad_div_size_idx_0 * grad_div_size_idx_1;
      hess_size = 0;
      u0 = b_wls->nstpnts;
      for (j = 0; j < nRhs; j++) {
        real_T s;
        real_T totalw;
        if (j >= i) {
          hess_size = 0;
          b = true;
        } else if (b) {
          b = false;
          hess_size = j % grad_div_size_idx_0 * grad_div_size_idx_1 +
                      j / grad_div_size_idx_0;
        } else if (hess_size > MAX_int32_T - grad_div_size_idx_1) {
          hess_size = j % grad_div_size_idx_0 * grad_div_size_idx_1 +
                      j / grad_div_size_idx_0;
        } else {
          hess_size += grad_div_size_idx_1;
          if (hess_size > i - 1) {
            hess_size = (hess_size - i) + 1;
          }
        }
        s = 0.0;
        for (b_i = 2; b_i <= u0; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        if (grad_div_data[hess_size] > 1) {
          totalw = 0.0;
        } else {
          loop_ub = ws.size(0);
          if (ws.size(0) == 0) {
            totalw = nevpnts;
            //  Unit weights summed together
          } else {
            //  All weights summed together
            totalw = 0.0;
            for (b_i = 0; b_i < loop_ub; b_i++) {
              totalw += ws[(iWeight + ws.size(1) * b_i) - 1];
            }
            iWeight += iWeight < ws.size(1);
          }
        }
        vdops[j] = totalw - s;
      }
    }
    //  Flip the signs of diagonal entries
    if (dim == 2) {
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        vdops[vdops.size(1) * b_i] = -vdops[vdops.size(1) * b_i];
        vdops[vdops.size(1) * b_i + 3] = -vdops[vdops.size(1) * b_i + 3];
      }
    } else if (dim == 3) {
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        vdops[vdops.size(1) * b_i] = -vdops[vdops.size(1) * b_i];
        vdops[vdops.size(1) * b_i + 4] = -vdops[vdops.size(1) * b_i + 4];
        vdops[vdops.size(1) * b_i + 8] = -vdops[vdops.size(1) * b_i + 8];
      }
    }
  }
  //  compute output value
  if ((fs.size(0) != 0) && (fs.size(1) != 0)) {
    result_size[1] = 1;
    result_size[0] = 3;
    if (dim - 1 >= 0) {
      std::memset(&result_data[0], 0, dim * sizeof(real_T));
    }
    switch (dim) {
    case 1:
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        result_data[0] += vdops[vdops.size(1) * b_i] * fs[fs.size(1) * b_i];
      }
      break;
    case 2:
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        d = fs[fs.size(1) * b_i];
        d1 = fs[fs.size(1) * b_i + 1];
        result_data[0] = (result_data[0] + vdops[vdops.size(1) * b_i] * d) +
                         vdops[vdops.size(1) * b_i + 1] * d1;
        result_data[1] = (result_data[1] + d * vdops[vdops.size(1) * b_i + 2]) +
                         d1 * vdops[vdops.size(1) * b_i + 3];
      }
      break;
    case 3:
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        d = fs[fs.size(1) * b_i];
        d1 = fs[fs.size(1) * b_i + 1];
        b_vdops = fs[fs.size(1) * b_i + 2];
        result_data[0] = ((result_data[0] + vdops[vdops.size(1) * b_i] * d) +
                          vdops[vdops.size(1) * b_i + 1] * d1) +
                         vdops[vdops.size(1) * b_i + 2] * b_vdops;
        result_data[1] =
            ((result_data[1] + d * vdops[vdops.size(1) * b_i + 3]) +
             d1 * vdops[vdops.size(1) * b_i + 4]) +
            b_vdops * vdops[vdops.size(1) * b_i + 5];
        result_data[2] =
            ((result_data[2] + d * vdops[vdops.size(1) * b_i + 6]) +
             d1 * vdops[vdops.size(1) * b_i + 7]) +
            b_vdops * vdops[vdops.size(1) * b_i + 8];
      }
      break;
    }
  } else {
    result_size[1] = 0;
    result_size[0] = 3;
  }
}

//  wls_var_curl_curl  Variational curl-curl operators as weighted sum at
void wls_var_curl_curl(WlsObject *b_wls,
                       const ::coder::array<real_T, 2U> &eval_pnts,
                       ::coder::array<real_T, 2U> &vdops)
{
  coder::SizeType b_i;
  coder::SizeType dim;
  coder::SizeType hess_size;
  coder::SizeType i;
  coder::SizeType j;
  coder::SizeType loop_ub;
  coder::SizeType nDiff;
  coder::SizeType nDims;
  coder::SizeType nRhs;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T hess_data[9];
  dim = b_wls->us.size(1);
  //  compute and reorganize vdops
  switch (b_wls->us.size(1)) {
  case 1:
    hess_size = 1;
    hess_data[0] = 0;
    break;
  case 2:
    hess_size = 4;
    hess_data[0] = 4;
    hess_data[1] = 5;
    hess_data[2] = 6;
    hess_data[3] = 0;
    break;
  default:
    hess_size = 9;
    for (i = 0; i < 9; i++) {
      hess_data[i] = iv4[i];
    }
    break;
  }
  nevpnts = eval_pnts.size(0);
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
        b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[b_dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[b_dim]) *
            b_wls->hs_inv.data[b_dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
        b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[b_dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[b_dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  c_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv.data,
               b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  nDiff = hess_size;
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(hess_size, u0);
  loop_ub = u0 * hess_size;
  for (i = 0; i < loop_ub; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  b_i = hess_size;
  while ((b_i > 0) && (b_i <= hess_size) && (hess_data[b_i - 1] == 0)) {
    nDiff--;
    b_i--;
  }
  //  Summing up rows in the differential operator
  for (coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
    //  Skip padded zeros in the differential operator
    if ((iOp + 1 > hess_size) || (hess_data[iOp] > 0)) {
      coder::SizeType offset;
      if (iOp + 1 > hess_size) {
        offset = 0;
      } else {
        offset = (hess_data[iOp] - 1) * b_wls->us.size(0);
      }
      //  Sum up monomials weighted by weights for each component
      i = b_wls->ncols - b_wls->interp0;
      for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
        j = b_wls->jpvt[iMonomial] + b_wls->interp0;
        for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
        }
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (hess_size = 0; hess_size < u0; hess_size++) {
        b_wls->QRt[hess_size + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * hess_size];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  vdops.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (b_i = 0; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    for (j = 0; j < nRhs; j++) {
      real_T s;
      coder::SizeType totalw;
      s = 0.0;
      for (b_i = 2; b_i <= i; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      if (hess_data[j] > 1) {
        totalw = 0;
      } else {
        totalw = nevpnts;
        //  Unit weights summed together
      }
      vdops[j] = static_cast<real_T>(totalw) - s;
    }
  }
  if (dim == 2) {
    i = b_wls->nrows;
    for (b_i = 0; b_i < i; b_i++) {
      real_T b_vdops;
      real_T c_vdops;
      b_vdops = vdops[vdops.size(1) * b_i + 1];
      c_vdops = vdops[vdops.size(1) * b_i];
      vdops[vdops.size(1) * b_i] = -vdops[vdops.size(1) * b_i + 2];
      vdops[vdops.size(1) * b_i + 1] = b_vdops;
      vdops[vdops.size(1) * b_i + 2] = b_vdops;
      vdops[vdops.size(1) * b_i + 3] = -c_vdops;
    }
  } else if (dim == 3) {
    i = b_wls->nrows;
    for (b_i = 0; b_i < i; b_i++) {
      real_T b_vdops;
      real_T c_vdops;
      real_T d;
      real_T d1;
      real_T d_vdops;
      real_T e_vdops;
      b_vdops = vdops[vdops.size(1) * b_i + 2];
      c_vdops = vdops[vdops.size(1) * b_i + 5];
      d_vdops = vdops[vdops.size(1) * b_i + 1];
      e_vdops = vdops[vdops.size(1) * b_i + 3];
      d = vdops[vdops.size(1) * b_i];
      d1 = vdops[vdops.size(1) * b_i + 4];
      vdops[vdops.size(1) * b_i] = -b_vdops - c_vdops;
      vdops[vdops.size(1) * b_i + 1] = d_vdops;
      vdops[vdops.size(1) * b_i + 2] = e_vdops;
      vdops[vdops.size(1) * b_i + 3] = d_vdops;
      vdops[vdops.size(1) * b_i + 4] = -d - c_vdops;
      vdops[vdops.size(1) * b_i + 5] = d1;
      vdops[vdops.size(1) * b_i + 6] = e_vdops;
      vdops[vdops.size(1) * b_i + 7] = d1;
      vdops[vdops.size(1) * b_i + 8] = -d - b_vdops;
    }
  }
  //  compute output value
}

//  wls_var_curl_curl  Variational curl-curl operators as weighted sum at
void wls_var_curl_curl(WlsObject *b_wls,
                       const ::coder::array<real_T, 2U> &eval_pnts,
                       const ::coder::array<real_T, 2U> &ws,
                       ::coder::array<real_T, 2U> &vdops)
{
  coder::SizeType dim;
  dim = b_wls->us.size(1);
  //  compute and reorganize vdops
  if (ws.size(1) <= 1) {
    coder::SizeType b_i;
    coder::SizeType hess_size;
    coder::SizeType i;
    coder::SizeType j;
    coder::SizeType loop_ub;
    coder::SizeType nDiff;
    coder::SizeType nDims;
    coder::SizeType nRhs;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType u0;
    coder::SizeType u1;
    int8_T hess_data[9];
    //  All components share the same weight, we need to compute Hessian
    switch (b_wls->us.size(1)) {
    case 1:
      hess_size = 1;
      hess_data[0] = 0;
      break;
    case 2:
      hess_size = 4;
      hess_data[0] = 4;
      hess_data[1] = 5;
      hess_data[2] = 6;
      hess_data[3] = 0;
      break;
    default:
      hess_size = 9;
      for (i = 0; i < 9; i++) {
        hess_data[i] = iv4[i];
      }
      break;
    }
    nevpnts = eval_pnts.size(0);
    //  Step 1: Tabulate monomial basis functions at evaluation points
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = eval_pnts.size(0);
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
          b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[b_dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[b_dim]) *
              b_wls->hs_inv.data[b_dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
          b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[b_dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[b_dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    c_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree,
                 b_wls->hs_inv.data, b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    nDiff = hess_size;
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(hess_size, u0);
    loop_ub = u0 * hess_size;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    b_i = hess_size;
    while ((b_i > 0) && (b_i <= hess_size) && (hess_data[b_i - 1] == 0)) {
      nDiff--;
      b_i--;
    }
    //  Summing up rows in the differential operator
    for (coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > hess_size) || (hess_data[iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > hess_size) {
          offset = 0;
        } else {
          offset = (hess_data[iOp] - 1) * b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[ws.size(1) * iEval] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    nRhs = b_wls->rhs.size(0);
    //  Multiply by generalized inverse of Vandermonde matrix
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (hess_size = 0; hess_size < u0; hess_size++) {
          b_wls->QRt[hess_size + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * hess_size];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    }
    vdops.set_size(u1, nRhs);
    //  Transpose the operator for row-major
    i = u1 - b_wls->interp0;
    for (b_i = 0; b_i < i; b_i++) {
      for (j = 0; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < nRhs; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  In interp0 mode, set the first entry based on partition of unity
      i = b_wls->nstpnts;
      for (j = 0; j < nRhs; j++) {
        real_T s;
        real_T totalw;
        s = 0.0;
        for (b_i = 2; b_i <= i; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        if (hess_data[j] > 1) {
          totalw = 0.0;
        } else {
          hess_size = ws.size(0);
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            totalw = nevpnts;
            //  Unit weights summed together
          } else {
            //  All weights summed together
            totalw = 0.0;
            for (b_i = 0; b_i < hess_size; b_i++) {
              totalw += ws[ws.size(1) * b_i];
            }
          }
        }
        vdops[j] = totalw - s;
      }
    }
    if (dim == 2) {
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        real_T b_vdops;
        real_T c_vdops;
        b_vdops = vdops[vdops.size(1) * b_i + 1];
        c_vdops = vdops[vdops.size(1) * b_i];
        vdops[vdops.size(1) * b_i] = -vdops[vdops.size(1) * b_i + 2];
        vdops[vdops.size(1) * b_i + 1] = b_vdops;
        vdops[vdops.size(1) * b_i + 2] = b_vdops;
        vdops[vdops.size(1) * b_i + 3] = -c_vdops;
      }
    } else if (dim == 3) {
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        real_T b_vdops;
        real_T c_vdops;
        real_T d;
        real_T d1;
        real_T d_vdops;
        real_T e_vdops;
        b_vdops = vdops[vdops.size(1) * b_i + 2];
        c_vdops = vdops[vdops.size(1) * b_i + 5];
        d_vdops = vdops[vdops.size(1) * b_i + 1];
        e_vdops = vdops[vdops.size(1) * b_i + 3];
        d = vdops[vdops.size(1) * b_i];
        d1 = vdops[vdops.size(1) * b_i + 4];
        vdops[vdops.size(1) * b_i] = -b_vdops - c_vdops;
        vdops[vdops.size(1) * b_i + 1] = d_vdops;
        vdops[vdops.size(1) * b_i + 2] = e_vdops;
        vdops[vdops.size(1) * b_i + 3] = d_vdops;
        vdops[vdops.size(1) * b_i + 4] = -d - c_vdops;
        vdops[vdops.size(1) * b_i + 5] = d1;
        vdops[vdops.size(1) * b_i + 6] = e_vdops;
        vdops[vdops.size(1) * b_i + 7] = d1;
        vdops[vdops.size(1) * b_i + 8] = -d - b_vdops;
      }
    }
  } else {
    coder::SizeType b_i;
    coder::SizeType grad_div_size_idx_0;
    coder::SizeType grad_div_size_idx_1;
    coder::SizeType hess_size;
    coder::SizeType i;
    coder::SizeType iWeight;
    coder::SizeType j;
    coder::SizeType lenWs;
    coder::SizeType loop_ub;
    coder::SizeType nDiff;
    coder::SizeType nDims;
    coder::SizeType nRhs;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType nrows_vdops;
    coder::SizeType u0;
    coder::SizeType u1;
    int8_T grad_div_data[18];
    //  Each component has its own weight, so we need to compute all components
    switch (b_wls->us.size(1)) {
    case 1:
      grad_div_size_idx_1 = 1;
      grad_div_size_idx_0 = 1;
      grad_div_data[0] = 0;
      break;
    case 2:
      grad_div_size_idx_1 = 1;
      grad_div_size_idx_0 = 4;
      grad_div_data[0] = 6;
      grad_div_data[1] = 5;
      grad_div_data[2] = 5;
      grad_div_data[3] = 4;
      break;
    default:
      grad_div_size_idx_1 = 2;
      grad_div_size_idx_0 = 9;
      for (i = 0; i < 18; i++) {
        grad_div_data[i] = iv5[i];
      }
      break;
    }
    nevpnts = eval_pnts.size(0);
    //  Step 1: Tabulate monomial basis functions at evaluation points
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = eval_pnts.size(0);
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
          b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[b_dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[b_dim]) *
              b_wls->hs_inv.data[b_dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
          b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[b_dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[b_dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    c_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree,
                 b_wls->hs_inv.data, b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    nDiff = grad_div_size_idx_0;
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(grad_div_size_idx_0, u0);
    loop_ub = u0 * grad_div_size_idx_0;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    b_i = grad_div_size_idx_0;
    while ((b_i > 0) && (b_i <= grad_div_size_idx_0) &&
           (grad_div_data[grad_div_size_idx_1 * (b_i - 1)] == 0)) {
      nDiff--;
      b_i--;
    }
    if (ws.size(0) == 0) {
      lenWs = 1;
    } else {
      lenWs = ws.size(1);
    }
    //  Summing up rows in the differential operator
    for (coder::SizeType jDiff{0}; jDiff < grad_div_size_idx_1; jDiff++) {
      iWeight = 1;
      //  Loop through the operators
      for (coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
        //  Skip padded zeros in the differential operator
        if ((iOp + 1 > grad_div_size_idx_0) ||
            (grad_div_data[jDiff + grad_div_size_idx_1 * iOp] > 0)) {
          coder::SizeType offset;
          if (iOp + 1 > grad_div_size_idx_0) {
            offset = 0;
          } else {
            offset = (grad_div_data[jDiff + grad_div_size_idx_1 * iOp] - 1) *
                     b_wls->us.size(0);
          }
          //  Sum up monomials weighted by weights for each component
          i = b_wls->ncols - b_wls->interp0;
          for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
            j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
            if (ws.size(0) == 0) {
              for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                    b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                    b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
              }
            } else {
              for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                    b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                    ws[(iWeight + ws.size(1) * iEval) - 1] *
                        b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
              }
            }
          }
        }
        if (iWeight == lenWs) {
          iWeight = 1;
        } else {
          iWeight++;
        }
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    nRhs = b_wls->rhs.size(0);
    //  Multiply by generalized inverse of Vandermonde matrix
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (hess_size = 0; hess_size < u0; hess_size++) {
          b_wls->QRt[hess_size + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * hess_size];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    }
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      nrows_vdops = u0;
    } else {
      nrows_vdops = u1;
    }
    vdops.set_size(nrows_vdops, nRhs);
    //  Transpose the operator for row-major
    i = nrows_vdops - b_wls->interp0;
    for (b_i = 0; b_i < i; b_i++) {
      for (j = 0; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < nRhs; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      boolean_T b;
      //  In interp0 mode, set the first entry based on partition of unity
      iWeight = 1;
      b = true;
      i = grad_div_size_idx_0 * grad_div_size_idx_1;
      hess_size = 0;
      u0 = b_wls->nstpnts;
      for (j = 0; j < nRhs; j++) {
        real_T s;
        real_T totalw;
        if (j >= i) {
          hess_size = 0;
          b = true;
        } else if (b) {
          b = false;
          hess_size = j % grad_div_size_idx_0 * grad_div_size_idx_1 +
                      j / grad_div_size_idx_0;
        } else if (hess_size > MAX_int32_T - grad_div_size_idx_1) {
          hess_size = j % grad_div_size_idx_0 * grad_div_size_idx_1 +
                      j / grad_div_size_idx_0;
        } else {
          hess_size += grad_div_size_idx_1;
          if (hess_size > i - 1) {
            hess_size = (hess_size - i) + 1;
          }
        }
        s = 0.0;
        for (b_i = 2; b_i <= u0; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        if (grad_div_data[hess_size] > 1) {
          totalw = 0.0;
        } else {
          loop_ub = ws.size(0);
          if (ws.size(0) == 0) {
            totalw = nevpnts;
            //  Unit weights summed together
          } else {
            //  All weights summed together
            totalw = 0.0;
            for (b_i = 0; b_i < loop_ub; b_i++) {
              totalw += ws[(iWeight + ws.size(1) * b_i) - 1];
            }
            iWeight += iWeight < ws.size(1);
          }
        }
        vdops[j] = totalw - s;
      }
    }
    //  Flip the signs of diagonal entries
    if (dim == 2) {
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        vdops[vdops.size(1) * b_i] = -vdops[vdops.size(1) * b_i];
        vdops[vdops.size(1) * b_i + 3] = -vdops[vdops.size(1) * b_i + 3];
      }
    } else if (dim == 3) {
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        vdops[vdops.size(1) * b_i] = -vdops[vdops.size(1) * b_i];
        vdops[vdops.size(1) * b_i + 4] = -vdops[vdops.size(1) * b_i + 4];
        vdops[vdops.size(1) * b_i + 8] = -vdops[vdops.size(1) * b_i + 8];
      }
    }
  }
  //  compute output value
}

//  wls_var_div  Compute variational divergence operators as weighted sum at
void wls_var_div(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                 const ::coder::array<real_T, 2U> &varargin_1,
                 const ::coder::array<real_T, 2U> &varargin_2,
                 coder::SizeType varargin_3,
                 ::coder::array<real_T, 2U> &varargout_1,
                 ::coder::array<real_T, 2U> &varargout_2)
{
  coder::SizeType grad_size;
  coder::SizeType i;
  coder::SizeType iOp;
  coder::SizeType iWeight;
  coder::SizeType j;
  coder::SizeType lenWs;
  coder::SizeType loop_ub;
  coder::SizeType nDims;
  coder::SizeType nOps;
  coder::SizeType nRhs;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T grad_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size = 1;
    grad_data[0] = 2;
    break;
  case 2:
    grad_size = 2;
    grad_data[0] = 2;
    grad_data[1] = 3;
    break;
  default:
    grad_size = 3;
    grad_data[0] = 2;
    grad_data[1] = 3;
    grad_data[2] = 4;
    break;
  }
  nevpnts = varargin_3;
  if (varargin_3 == 0) {
    nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  d_gen_vander(b_wls->us, nevpnts, b_wls->degree, b_wls->hs_inv.data,
               b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(grad_size, u0);
  loop_ub = u0 * grad_size;
  for (i = 0; i < loop_ub; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
    lenWs = 1;
  } else {
    lenWs = varargin_1.size(1);
  }
  //  Summing up rows in the differential operator
  iWeight = 1;
  //  Loop through the operators
  for (iOp = 0; iOp < grad_size; iOp++) {
    coder::SizeType offset;
    //  Skip padded zeros in the differential operator
    if (iOp + 1 > grad_size) {
      offset = 0;
    } else {
      offset = (grad_data[iOp] - 1) * b_wls->us.size(0);
    }
    //  Sum up monomials weighted by weights for each component
    i = b_wls->ncols - b_wls->interp0;
    for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
      if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
        for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      } else {
        for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              varargin_1[(iWeight + varargin_1.size(1) * iEval) - 1] *
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      }
    }
    if (iWeight == lenWs) {
      iWeight = 1;
    } else {
      iWeight++;
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (grad_size = 0; grad_size < u0; grad_size++) {
        b_wls->QRt[grad_size + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * grad_size];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  varargout_1.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      varargout_1[j + varargout_1.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        varargout_1[k + varargout_1.size(1) * iRow] =
            varargout_1[k + varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    for (j = 0; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += varargout_1[j + varargout_1.size(1) * (b_i - 1)];
      }
      varargout_1[j] = 0.0 - s;
    }
  }
  //  Step 4: Optionally, evaluate the operator
  nOps = varargout_1.size(1);
  if ((varargin_2.size(0) == 0) || (varargin_2.size(1) == 0)) {
    varargout_2.set_size(0, 1);
  } else {
    coder::SizeType iFunc;
    u0 = varargout_1.size(1) / b_wls->us.size(1);
    varargout_2.set_size(u0, 1);
    for (i = 0; i < u0; i++) {
      varargout_2[i] = 0.0;
    }
    //  Compute solution
    iFunc = 1;
    iOp = 0;
    for (coder::SizeType iDiff{0}; iDiff < nOps; iDiff++) {
      i = b_wls->nrows;
      for (coder::SizeType iRow{0}; iRow < i; iRow++) {
        varargout_2[iOp % varargout_2.size(0) + iOp / varargout_2.size(0)] =
            varargout_2[iOp % varargout_2.size(0) + iOp / varargout_2.size(0)] +
            varargin_2[(iFunc + varargin_2.size(1) * iRow) - 1] *
                varargout_1[iDiff + varargout_1.size(1) * iRow];
      }
      if (iOp + 1 == varargout_2.size(0)) {
        iOp = 0;
      } else {
        iOp++;
      }
      if (iFunc == varargin_2.size(1)) {
        iFunc = 1;
      } else {
        iFunc++;
      }
    }
  }
}

//  wls_var_div  Compute variational divergence operators as weighted sum at
void wls_var_div(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                 const ::coder::array<real_T, 2U> &varargin_1,
                 const ::coder::array<real_T, 2U> &varargin_2,
                 ::coder::array<real_T, 2U> &varargout_1,
                 ::coder::array<real_T, 2U> &varargout_2)
{
  coder::SizeType grad_size;
  coder::SizeType i;
  coder::SizeType iOp;
  coder::SizeType iWeight;
  coder::SizeType j;
  coder::SizeType lenWs;
  coder::SizeType loop_ub;
  coder::SizeType nDims;
  coder::SizeType nOps;
  coder::SizeType nRhs;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T grad_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size = 1;
    grad_data[0] = 2;
    break;
  case 2:
    grad_size = 2;
    grad_data[0] = 2;
    grad_data[1] = 3;
    break;
  default:
    grad_size = 3;
    grad_data[0] = 2;
    grad_data[1] = 3;
    grad_data[2] = 4;
    break;
  }
  nevpnts = eval_pnts.size(0) - 1;
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  d_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv.data,
               b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(grad_size, u0);
  loop_ub = u0 * grad_size;
  for (i = 0; i < loop_ub; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
    lenWs = 1;
  } else {
    lenWs = varargin_1.size(1);
  }
  //  Summing up rows in the differential operator
  iWeight = 1;
  //  Loop through the operators
  for (iOp = 0; iOp < grad_size; iOp++) {
    coder::SizeType offset;
    //  Skip padded zeros in the differential operator
    if (iOp + 1 > grad_size) {
      offset = 0;
    } else {
      offset = (grad_data[iOp] - 1) * b_wls->us.size(0);
    }
    //  Sum up monomials weighted by weights for each component
    i = b_wls->ncols - b_wls->interp0;
    for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
      if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
        for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      } else {
        for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              varargin_1[(iWeight + varargin_1.size(1) * iEval) - 1] *
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      }
    }
    if (iWeight == lenWs) {
      iWeight = 1;
    } else {
      iWeight++;
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (grad_size = 0; grad_size < u0; grad_size++) {
        b_wls->QRt[grad_size + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * grad_size];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  varargout_1.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      varargout_1[j + varargout_1.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        varargout_1[k + varargout_1.size(1) * iRow] =
            varargout_1[k + varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    for (j = 0; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += varargout_1[j + varargout_1.size(1) * (b_i - 1)];
      }
      varargout_1[j] = 0.0 - s;
    }
  }
  //  Step 4: Optionally, evaluate the operator
  nOps = varargout_1.size(1);
  if ((varargin_2.size(0) == 0) || (varargin_2.size(1) == 0)) {
    varargout_2.set_size(0, 1);
  } else {
    coder::SizeType iFunc;
    u0 = varargout_1.size(1) / b_wls->us.size(1);
    varargout_2.set_size(u0, 1);
    for (i = 0; i < u0; i++) {
      varargout_2[i] = 0.0;
    }
    //  Compute solution
    iFunc = 1;
    iOp = 0;
    for (coder::SizeType iDiff{0}; iDiff < nOps; iDiff++) {
      i = b_wls->nrows;
      for (coder::SizeType iRow{0}; iRow < i; iRow++) {
        varargout_2[iOp % varargout_2.size(0) + iOp / varargout_2.size(0)] =
            varargout_2[iOp % varargout_2.size(0) + iOp / varargout_2.size(0)] +
            varargin_2[(iFunc + varargin_2.size(1) * iRow) - 1] *
                varargout_1[iDiff + varargout_1.size(1) * iRow];
      }
      if (iOp + 1 == varargout_2.size(0)) {
        iOp = 0;
      } else {
        iOp++;
      }
      if (iFunc == varargin_2.size(1)) {
        iFunc = 1;
      } else {
        iFunc++;
      }
    }
  }
}

//  wls_var_div  Compute variational divergence operators as weighted sum at
void wls_var_div(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                 ::coder::array<real_T, 2U> &varargout_1)
{
  coder::SizeType grad_size;
  coder::SizeType i;
  coder::SizeType j;
  coder::SizeType loop_ub;
  coder::SizeType nDims;
  coder::SizeType nRhs;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T grad_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size = 1;
    grad_data[0] = 2;
    break;
  case 2:
    grad_size = 2;
    grad_data[0] = 2;
    grad_data[1] = 3;
    break;
  default:
    grad_size = 3;
    grad_data[0] = 2;
    grad_data[1] = 3;
    grad_data[2] = 4;
    break;
  }
  nevpnts = eval_pnts.size(0);
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  d_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv.data,
               b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(grad_size, u0);
  loop_ub = u0 * grad_size;
  for (i = 0; i < loop_ub; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  for (coder::SizeType iOp{0}; iOp < grad_size; iOp++) {
    coder::SizeType offset;
    //  Skip padded zeros in the differential operator
    if (iOp + 1 > grad_size) {
      offset = 0;
    } else {
      offset = (grad_data[iOp] - 1) * b_wls->us.size(0);
    }
    //  Sum up monomials weighted by weights for each component
    i = b_wls->ncols - b_wls->interp0;
    for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      j = b_wls->jpvt[iMonomial] + b_wls->interp0;
      for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
        b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
            b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (grad_size = 0; grad_size < u0; grad_size++) {
        b_wls->QRt[grad_size + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * grad_size];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  varargout_1.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      varargout_1[j + varargout_1.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        varargout_1[k + varargout_1.size(1) * iRow] =
            varargout_1[k + varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    for (j = 0; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += varargout_1[j + varargout_1.size(1) * (b_i - 1)];
      }
      varargout_1[j] = 0.0 - s;
    }
  }
}

//  wls_var_div  Compute variational divergence operators as weighted sum at
void wls_var_div(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                 const ::coder::array<real_T, 2U> &varargin_1,
                 ::coder::array<real_T, 2U> &varargout_1)
{
  coder::SizeType grad_size;
  coder::SizeType i;
  coder::SizeType iWeight;
  coder::SizeType j;
  coder::SizeType lenWs;
  coder::SizeType loop_ub;
  coder::SizeType nDims;
  coder::SizeType nRhs;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T grad_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size = 1;
    grad_data[0] = 2;
    break;
  case 2:
    grad_size = 2;
    grad_data[0] = 2;
    grad_data[1] = 3;
    break;
  default:
    grad_size = 3;
    grad_data[0] = 2;
    grad_data[1] = 3;
    grad_data[2] = 4;
    break;
  }
  nevpnts = eval_pnts.size(0) - 1;
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  d_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv.data,
               b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(grad_size, u0);
  loop_ub = u0 * grad_size;
  for (i = 0; i < loop_ub; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
    lenWs = 1;
  } else {
    lenWs = varargin_1.size(1);
  }
  //  Summing up rows in the differential operator
  iWeight = 1;
  //  Loop through the operators
  for (coder::SizeType iOp{0}; iOp < grad_size; iOp++) {
    coder::SizeType offset;
    //  Skip padded zeros in the differential operator
    if (iOp + 1 > grad_size) {
      offset = 0;
    } else {
      offset = (grad_data[iOp] - 1) * b_wls->us.size(0);
    }
    //  Sum up monomials weighted by weights for each component
    i = b_wls->ncols - b_wls->interp0;
    for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
      if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
        for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      } else {
        for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              varargin_1[(iWeight + varargin_1.size(1) * iEval) - 1] *
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      }
    }
    if (iWeight == lenWs) {
      iWeight = 1;
    } else {
      iWeight++;
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (grad_size = 0; grad_size < u0; grad_size++) {
        b_wls->QRt[grad_size + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * grad_size];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  varargout_1.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      varargout_1[j + varargout_1.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        varargout_1[k + varargout_1.size(1) * iRow] =
            varargout_1[k + varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    for (j = 0; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += varargout_1[j + varargout_1.size(1) * (b_i - 1)];
      }
      varargout_1[j] = 0.0 - s;
    }
  }
}

//  wls_var_func  Compute variational WLS-fitting as weighted sum at
void wls_var_func(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  const ::coder::array<real_T, 2U> &varargin_1,
                  const ::coder::array<real_T, 2U> &varargin_2,
                  coder::SizeType varargin_3,
                  ::coder::array<real_T, 2U> &varargout_1,
                  ::coder::array<real_T, 2U> &varargout_2)
{
  coder::SizeType i;
  coder::SizeType i1;
  coder::SizeType nDims;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  nevpnts = varargin_3;
  if (varargin_3 == 0) {
    nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, nevpnts, b_wls->degree, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(1, u0);
  for (i = 0; i < u0; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  i = b_wls->ncols - b_wls->interp0;
  for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
    coder::SizeType j;
    j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
    if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
      for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
        b_wls->rhs[iMonomial] =
            b_wls->rhs[iMonomial] + b_wls->V[iEval + b_wls->V.size(1) * j];
      }
    } else {
      for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
        b_wls->rhs[iMonomial] =
            b_wls->rhs[iMonomial] + varargin_1[varargin_1.size(1) * iEval] *
                                        b_wls->V[iEval + b_wls->V.size(1) * j];
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    u0 = b_wls->QR.size(1);
    for (i = 0; i < u0; i++) {
      coder::SizeType loop_ub;
      loop_ub = b_wls->QR.size(0);
      for (i1 = 0; i1 < loop_ub; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  }
  varargout_1.set_size(u1, 1);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    varargout_1[varargout_1.size(1) * (b_i + b_wls->interp0)] = b_wls->rhs[b_i];
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
      varargout_1[varargout_1.size(1) * iRow] =
          varargout_1[varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
    }
  }
  if (b_wls->interp0 != 0) {
    real_T s;
    real_T totalw;
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    s = 0.0;
    for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
      s += varargout_1[varargout_1.size(1) * (b_i - 1)];
    }
    i = varargin_1.size(0);
    if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
      totalw = nevpnts;
      //  Unit weights summed together
    } else {
      //  All weights summed together
      totalw = 0.0;
      for (coder::SizeType b_i{0}; b_i < i; b_i++) {
        totalw += varargin_1[varargin_1.size(1) * b_i];
      }
    }
    varargout_1[0] = totalw - s;
  }
  //  Step 4: Optionally, evaluate the operator
  if ((varargin_2.size(0) == 0) || (varargin_2.size(1) == 0)) {
    varargout_2.set_size(0, 1);
  } else {
    varargout_2.set_size(1, varargin_2.size(1));
    u0 = varargin_2.size(1);
    for (i = 0; i < u0; i++) {
      varargout_2[i] = 0.0;
    }
    //  Compute solution
    i = varargin_2.size(1);
    i1 = b_wls->nrows;
    for (coder::SizeType iFunc{0}; iFunc < i; iFunc++) {
      for (coder::SizeType iRow{0}; iRow < i1; iRow++) {
        varargout_2[iFunc] =
            varargout_2[iFunc] + varargin_2[iFunc + varargin_2.size(1) * iRow] *
                                     varargout_1[varargout_1.size(1) * iRow];
      }
    }
  }
}

//  wls_var_func  Compute variational WLS-fitting as weighted sum at
void wls_var_func(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  const ::coder::array<real_T, 2U> &varargin_1,
                  const ::coder::array<real_T, 2U> &varargin_2,
                  ::coder::array<real_T, 2U> &varargout_1,
                  ::coder::array<real_T, 2U> &varargout_2)
{
  coder::SizeType i;
  coder::SizeType i1;
  coder::SizeType nDims;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  nevpnts = eval_pnts.size(0);
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(1, u0);
  for (i = 0; i < u0; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  i = b_wls->ncols - b_wls->interp0;
  for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
    coder::SizeType j;
    j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
    if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
      for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
        b_wls->rhs[iMonomial] =
            b_wls->rhs[iMonomial] + b_wls->V[iEval + b_wls->V.size(1) * j];
      }
    } else {
      for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
        b_wls->rhs[iMonomial] =
            b_wls->rhs[iMonomial] + varargin_1[varargin_1.size(1) * iEval] *
                                        b_wls->V[iEval + b_wls->V.size(1) * j];
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    u0 = b_wls->QR.size(1);
    for (i = 0; i < u0; i++) {
      coder::SizeType loop_ub;
      loop_ub = b_wls->QR.size(0);
      for (i1 = 0; i1 < loop_ub; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  }
  varargout_1.set_size(u1, 1);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    varargout_1[varargout_1.size(1) * (b_i + b_wls->interp0)] = b_wls->rhs[b_i];
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
      varargout_1[varargout_1.size(1) * iRow] =
          varargout_1[varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
    }
  }
  if (b_wls->interp0 != 0) {
    real_T s;
    real_T totalw;
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    s = 0.0;
    for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
      s += varargout_1[varargout_1.size(1) * (b_i - 1)];
    }
    i = varargin_1.size(0);
    if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
      totalw = eval_pnts.size(0);
      //  Unit weights summed together
    } else {
      //  All weights summed together
      totalw = 0.0;
      for (coder::SizeType b_i{0}; b_i < i; b_i++) {
        totalw += varargin_1[varargin_1.size(1) * b_i];
      }
    }
    varargout_1[0] = totalw - s;
  }
  //  Step 4: Optionally, evaluate the operator
  if ((varargin_2.size(0) == 0) || (varargin_2.size(1) == 0)) {
    varargout_2.set_size(0, 1);
  } else {
    varargout_2.set_size(1, varargin_2.size(1));
    u0 = varargin_2.size(1);
    for (i = 0; i < u0; i++) {
      varargout_2[i] = 0.0;
    }
    //  Compute solution
    i = varargin_2.size(1);
    i1 = b_wls->nrows;
    for (coder::SizeType iFunc{0}; iFunc < i; iFunc++) {
      for (coder::SizeType iRow{0}; iRow < i1; iRow++) {
        varargout_2[iFunc] =
            varargout_2[iFunc] + varargin_2[iFunc + varargin_2.size(1) * iRow] *
                                     varargout_1[varargout_1.size(1) * iRow];
      }
    }
  }
}

//  wls_var_func  Compute variational WLS-fitting as weighted sum at
void wls_var_func(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  ::coder::array<real_T, 2U> &varargout_1)
{
  coder::SizeType i;
  coder::SizeType nDims;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  nevpnts = eval_pnts.size(0);
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(1, u0);
  for (i = 0; i < u0; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  i = b_wls->ncols - b_wls->interp0;
  for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
    coder::SizeType j;
    j = b_wls->jpvt[iMonomial] + b_wls->interp0;
    for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
      b_wls->rhs[iMonomial] =
          b_wls->rhs[iMonomial] + b_wls->V[iEval + b_wls->V.size(1) * (j - 1)];
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    u0 = b_wls->QR.size(1);
    for (i = 0; i < u0; i++) {
      coder::SizeType loop_ub;
      loop_ub = b_wls->QR.size(0);
      for (coder::SizeType i1{0}; i1 < loop_ub; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  }
  varargout_1.set_size(u1, 1);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    varargout_1[varargout_1.size(1) * (b_i + b_wls->interp0)] = b_wls->rhs[b_i];
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
      varargout_1[varargout_1.size(1) * iRow] =
          varargout_1[varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
    }
  }
  if (b_wls->interp0 != 0) {
    real_T s;
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    s = 0.0;
    for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
      s += varargout_1[varargout_1.size(1) * (b_i - 1)];
    }
    //  Unit weights summed together
    varargout_1[0] = static_cast<real_T>(eval_pnts.size(0)) - s;
  }
}

//  wls_var_func  Compute variational WLS-fitting as weighted sum at
void wls_var_func(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  const ::coder::array<real_T, 2U> &varargin_1,
                  ::coder::array<real_T, 2U> &varargout_1)
{
  coder::SizeType i;
  coder::SizeType nDims;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  nevpnts = eval_pnts.size(0);
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(1, u0);
  for (i = 0; i < u0; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  i = b_wls->ncols - b_wls->interp0;
  for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
    coder::SizeType j;
    j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
    if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
      for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
        b_wls->rhs[iMonomial] =
            b_wls->rhs[iMonomial] + b_wls->V[iEval + b_wls->V.size(1) * j];
      }
    } else {
      for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
        b_wls->rhs[iMonomial] =
            b_wls->rhs[iMonomial] + varargin_1[varargin_1.size(1) * iEval] *
                                        b_wls->V[iEval + b_wls->V.size(1) * j];
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    u0 = b_wls->QR.size(1);
    for (i = 0; i < u0; i++) {
      coder::SizeType loop_ub;
      loop_ub = b_wls->QR.size(0);
      for (coder::SizeType i1{0}; i1 < loop_ub; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  }
  varargout_1.set_size(u1, 1);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    varargout_1[varargout_1.size(1) * (b_i + b_wls->interp0)] = b_wls->rhs[b_i];
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
      varargout_1[varargout_1.size(1) * iRow] =
          varargout_1[varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
    }
  }
  if (b_wls->interp0 != 0) {
    real_T s;
    real_T totalw;
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    s = 0.0;
    for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
      s += varargout_1[varargout_1.size(1) * (b_i - 1)];
    }
    i = varargin_1.size(0);
    if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
      totalw = eval_pnts.size(0);
      //  Unit weights summed together
    } else {
      //  All weights summed together
      totalw = 0.0;
      for (coder::SizeType b_i{0}; b_i < i; b_i++) {
        totalw += varargin_1[varargin_1.size(1) * b_i];
      }
    }
    varargout_1[0] = totalw - s;
  }
}

//  wls_var_grad  Compute variational gradient operators as weighted sum at
void wls_var_grad(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  const ::coder::array<real_T, 2U> &varargin_1,
                  const ::coder::array<real_T, 2U> &varargin_2,
                  coder::SizeType varargin_3,
                  ::coder::array<real_T, 2U> &varargout_1,
                  ::coder::array<real_T, 2U> &varargout_2)
{
  coder::SizeType grad_size;
  coder::SizeType i;
  coder::SizeType iOp;
  coder::SizeType iWeight;
  coder::SizeType j;
  coder::SizeType lenWs;
  coder::SizeType loop_ub;
  coder::SizeType nDims;
  coder::SizeType nOps;
  coder::SizeType nRhs;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T grad_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size = 1;
    grad_data[0] = 2;
    break;
  case 2:
    grad_size = 2;
    grad_data[0] = 2;
    grad_data[1] = 3;
    break;
  default:
    grad_size = 3;
    grad_data[0] = 2;
    grad_data[1] = 3;
    grad_data[2] = 4;
    break;
  }
  nevpnts = varargin_3;
  if (varargin_3 == 0) {
    nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  b_gen_vander(b_wls->us, nevpnts, b_wls->degree, b_wls->hs_inv.data,
               b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(grad_size, u0);
  loop_ub = u0 * grad_size;
  for (i = 0; i < loop_ub; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
    lenWs = 1;
  } else {
    lenWs = varargin_1.size(1);
  }
  //  Summing up rows in the differential operator
  iWeight = 1;
  //  Loop through the operators
  for (iOp = 0; iOp < grad_size; iOp++) {
    coder::SizeType offset;
    //  Skip padded zeros in the differential operator
    if (iOp + 1 > grad_size) {
      offset = 0;
    } else {
      offset = (grad_data[iOp] - 1) * b_wls->us.size(0);
    }
    //  Sum up monomials weighted by weights for each component
    i = b_wls->ncols - b_wls->interp0;
    for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
      if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
        for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      } else {
        for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              varargin_1[(iWeight + varargin_1.size(1) * iEval) - 1] *
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      }
    }
    if (iWeight == lenWs) {
      iWeight = 1;
    } else {
      iWeight++;
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (grad_size = 0; grad_size < u0; grad_size++) {
        b_wls->QRt[grad_size + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * grad_size];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  varargout_1.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      varargout_1[j + varargout_1.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        varargout_1[k + varargout_1.size(1) * iRow] =
            varargout_1[k + varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    for (j = 0; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += varargout_1[j + varargout_1.size(1) * (b_i - 1)];
      }
      varargout_1[j] = 0.0 - s;
    }
  }
  //  Step 4: Optionally, evaluate the operator
  nOps = varargout_1.size(1);
  if ((varargin_2.size(0) == 0) || (varargin_2.size(1) == 0)) {
    varargout_2.set_size(0, 1);
  } else {
    varargout_2.set_size(varargout_1.size(1), varargin_2.size(1));
    loop_ub = varargin_2.size(1) * varargout_1.size(1);
    for (i = 0; i < loop_ub; i++) {
      varargout_2[i] = 0.0;
    }
    //  Compute solution
    i = varargin_2.size(1);
    for (coder::SizeType iFunc{0}; iFunc < i; iFunc++) {
      iOp = 0;
      for (coder::SizeType iDiff{0}; iDiff < nOps; iDiff++) {
        grad_size = b_wls->nrows;
        for (coder::SizeType iRow{0}; iRow < grad_size; iRow++) {
          varargout_2[iFunc + varargout_2.size(1) * iOp] =
              varargout_2[iFunc + varargout_2.size(1) * iOp] +
              varargin_2[iFunc + varargin_2.size(1) * iRow] *
                  varargout_1[iDiff + varargout_1.size(1) * iRow];
        }
        if (iOp + 1 == varargout_2.size(0)) {
          iOp = 0;
        } else {
          iOp++;
        }
      }
    }
  }
}

//  wls_var_grad  Compute variational gradient operators as weighted sum at
void wls_var_grad(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  const ::coder::array<real_T, 2U> &varargin_1,
                  const ::coder::array<real_T, 2U> &varargin_2,
                  ::coder::array<real_T, 2U> &varargout_1,
                  ::coder::array<real_T, 2U> &varargout_2)
{
  coder::SizeType grad_size;
  coder::SizeType i;
  coder::SizeType iOp;
  coder::SizeType iWeight;
  coder::SizeType j;
  coder::SizeType lenWs;
  coder::SizeType loop_ub;
  coder::SizeType nDims;
  coder::SizeType nOps;
  coder::SizeType nRhs;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T grad_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size = 1;
    grad_data[0] = 2;
    break;
  case 2:
    grad_size = 2;
    grad_data[0] = 2;
    grad_data[1] = 3;
    break;
  default:
    grad_size = 3;
    grad_data[0] = 2;
    grad_data[1] = 3;
    grad_data[2] = 4;
    break;
  }
  nevpnts = eval_pnts.size(0) - 1;
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  b_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv.data,
               b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(grad_size, u0);
  loop_ub = u0 * grad_size;
  for (i = 0; i < loop_ub; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
    lenWs = 1;
  } else {
    lenWs = varargin_1.size(1);
  }
  //  Summing up rows in the differential operator
  iWeight = 1;
  //  Loop through the operators
  for (iOp = 0; iOp < grad_size; iOp++) {
    coder::SizeType offset;
    //  Skip padded zeros in the differential operator
    if (iOp + 1 > grad_size) {
      offset = 0;
    } else {
      offset = (grad_data[iOp] - 1) * b_wls->us.size(0);
    }
    //  Sum up monomials weighted by weights for each component
    i = b_wls->ncols - b_wls->interp0;
    for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
      if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
        for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      } else {
        for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              varargin_1[(iWeight + varargin_1.size(1) * iEval) - 1] *
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      }
    }
    if (iWeight == lenWs) {
      iWeight = 1;
    } else {
      iWeight++;
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (grad_size = 0; grad_size < u0; grad_size++) {
        b_wls->QRt[grad_size + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * grad_size];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  varargout_1.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      varargout_1[j + varargout_1.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        varargout_1[k + varargout_1.size(1) * iRow] =
            varargout_1[k + varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    for (j = 0; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += varargout_1[j + varargout_1.size(1) * (b_i - 1)];
      }
      varargout_1[j] = 0.0 - s;
    }
  }
  //  Step 4: Optionally, evaluate the operator
  nOps = varargout_1.size(1);
  if ((varargin_2.size(0) == 0) || (varargin_2.size(1) == 0)) {
    varargout_2.set_size(0, 1);
  } else {
    varargout_2.set_size(varargout_1.size(1), varargin_2.size(1));
    loop_ub = varargin_2.size(1) * varargout_1.size(1);
    for (i = 0; i < loop_ub; i++) {
      varargout_2[i] = 0.0;
    }
    //  Compute solution
    i = varargin_2.size(1);
    for (coder::SizeType iFunc{0}; iFunc < i; iFunc++) {
      iOp = 0;
      for (coder::SizeType iDiff{0}; iDiff < nOps; iDiff++) {
        grad_size = b_wls->nrows;
        for (coder::SizeType iRow{0}; iRow < grad_size; iRow++) {
          varargout_2[iFunc + varargout_2.size(1) * iOp] =
              varargout_2[iFunc + varargout_2.size(1) * iOp] +
              varargin_2[iFunc + varargin_2.size(1) * iRow] *
                  varargout_1[iDiff + varargout_1.size(1) * iRow];
        }
        if (iOp + 1 == varargout_2.size(0)) {
          iOp = 0;
        } else {
          iOp++;
        }
      }
    }
  }
}

//  wls_var_grad  Compute variational gradient operators as weighted sum at
void wls_var_grad(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  ::coder::array<real_T, 2U> &varargout_1)
{
  coder::SizeType grad_size;
  coder::SizeType i;
  coder::SizeType j;
  coder::SizeType loop_ub;
  coder::SizeType nDims;
  coder::SizeType nRhs;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T grad_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size = 1;
    grad_data[0] = 2;
    break;
  case 2:
    grad_size = 2;
    grad_data[0] = 2;
    grad_data[1] = 3;
    break;
  default:
    grad_size = 3;
    grad_data[0] = 2;
    grad_data[1] = 3;
    grad_data[2] = 4;
    break;
  }
  nevpnts = eval_pnts.size(0);
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  b_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv.data,
               b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(grad_size, u0);
  loop_ub = u0 * grad_size;
  for (i = 0; i < loop_ub; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  for (coder::SizeType iOp{0}; iOp < grad_size; iOp++) {
    coder::SizeType offset;
    //  Skip padded zeros in the differential operator
    if (iOp + 1 > grad_size) {
      offset = 0;
    } else {
      offset = (grad_data[iOp] - 1) * b_wls->us.size(0);
    }
    //  Sum up monomials weighted by weights for each component
    i = b_wls->ncols - b_wls->interp0;
    for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      j = b_wls->jpvt[iMonomial] + b_wls->interp0;
      for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
        b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
            b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (grad_size = 0; grad_size < u0; grad_size++) {
        b_wls->QRt[grad_size + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * grad_size];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  varargout_1.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      varargout_1[j + varargout_1.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        varargout_1[k + varargout_1.size(1) * iRow] =
            varargout_1[k + varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    for (j = 0; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += varargout_1[j + varargout_1.size(1) * (b_i - 1)];
      }
      varargout_1[j] = 0.0 - s;
    }
  }
}

//  wls_var_grad  Compute variational gradient operators as weighted sum at
void wls_var_grad(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  const ::coder::array<real_T, 2U> &varargin_1,
                  ::coder::array<real_T, 2U> &varargout_1)
{
  coder::SizeType grad_size;
  coder::SizeType i;
  coder::SizeType iWeight;
  coder::SizeType j;
  coder::SizeType lenWs;
  coder::SizeType loop_ub;
  coder::SizeType nDims;
  coder::SizeType nRhs;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T grad_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    grad_size = 1;
    grad_data[0] = 2;
    break;
  case 2:
    grad_size = 2;
    grad_data[0] = 2;
    grad_data[1] = 3;
    break;
  default:
    grad_size = 3;
    grad_data[0] = 2;
    grad_data[1] = 3;
    grad_data[2] = 4;
    break;
  }
  nevpnts = eval_pnts.size(0) - 1;
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  b_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv.data,
               b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(grad_size, u0);
  loop_ub = u0 * grad_size;
  for (i = 0; i < loop_ub; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
    lenWs = 1;
  } else {
    lenWs = varargin_1.size(1);
  }
  //  Summing up rows in the differential operator
  iWeight = 1;
  //  Loop through the operators
  for (coder::SizeType iOp{0}; iOp < grad_size; iOp++) {
    coder::SizeType offset;
    //  Skip padded zeros in the differential operator
    if (iOp + 1 > grad_size) {
      offset = 0;
    } else {
      offset = (grad_data[iOp] - 1) * b_wls->us.size(0);
    }
    //  Sum up monomials weighted by weights for each component
    i = b_wls->ncols - b_wls->interp0;
    for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
      if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
        for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      } else {
        for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              varargin_1[(iWeight + varargin_1.size(1) * iEval) - 1] *
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      }
    }
    if (iWeight == lenWs) {
      iWeight = 1;
    } else {
      iWeight++;
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (grad_size = 0; grad_size < u0; grad_size++) {
        b_wls->QRt[grad_size + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * grad_size];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  varargout_1.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      varargout_1[j + varargout_1.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        varargout_1[k + varargout_1.size(1) * iRow] =
            varargout_1[k + varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    for (j = 0; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += varargout_1[j + varargout_1.size(1) * (b_i - 1)];
      }
      varargout_1[j] = 0.0 - s;
    }
  }
}

//  wls_var_grad_div  Variational grad-div operators as weighted sum at
void wls_var_grad_div(WlsObject *b_wls,
                      const ::coder::array<real_T, 2U> &eval_pnts,
                      const ::coder::array<real_T, 2U> &ws,
                      const ::coder::array<real_T, 2U> &,
                      coder::SizeType varargin_1,
                      ::coder::array<real_T, 2U> &vdops, const real_T[],
                      coder::SizeType result_size[2])
{
  coder::SizeType dim;
  dim = b_wls->us.size(1);
  //  compute and reorganize vdops
  if (ws.size(1) <= 1) {
    coder::SizeType b_i;
    coder::SizeType grad_div_size;
    coder::SizeType i;
    coder::SizeType j;
    coder::SizeType loop_ub;
    coder::SizeType nDiff;
    coder::SizeType nDims;
    coder::SizeType nRhs;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType nrows_vdops;
    coder::SizeType u0;
    coder::SizeType u1;
    int8_T hess_data[9];
    //  All components share the same weight, we need to compute Hessian
    switch (b_wls->us.size(1)) {
    case 1:
      grad_div_size = 1;
      hess_data[0] = 3;
      break;
    case 2:
      grad_div_size = 4;
      hess_data[0] = 4;
      hess_data[1] = 5;
      hess_data[2] = 6;
      hess_data[3] = 0;
      break;
    default:
      grad_div_size = 9;
      for (i = 0; i < 9; i++) {
        hess_data[i] = iv4[i];
      }
      break;
    }
    nevpnts = varargin_1;
    if (varargin_1 == 0) {
      nevpnts = eval_pnts.size(0);
    }
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = nevpnts;
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((nevpnts + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
          b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[b_dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[b_dim]) *
              b_wls->hs_inv.data[b_dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
          b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[b_dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[b_dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    c_gen_vander(b_wls->us, nevpnts, b_wls->degree, b_wls->hs_inv.data,
                 b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    nDiff = grad_div_size;
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(grad_div_size, u0);
    loop_ub = u0 * grad_div_size;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    b_i = grad_div_size;
    while ((b_i > 0) && (b_i <= grad_div_size) && (hess_data[b_i - 1] == 0)) {
      nDiff--;
      b_i--;
    }
    //  Summing up rows in the differential operator
    for (coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > grad_div_size) || (hess_data[iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > grad_div_size) {
          offset = 0;
        } else {
          offset = (hess_data[iOp] - 1) * b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[ws.size(1) * iEval] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    nRhs = b_wls->rhs.size(0);
    //  Multiply by generalized inverse of Vandermonde matrix
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (grad_div_size = 0; grad_div_size < u0; grad_div_size++) {
          b_wls->QRt[grad_div_size + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * grad_div_size];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    }
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      nrows_vdops = u0;
    } else {
      nrows_vdops = u1;
    }
    vdops.set_size(nrows_vdops, nRhs);
    //  Transpose the operator for row-major
    i = nrows_vdops - b_wls->interp0;
    for (b_i = 0; b_i < i; b_i++) {
      for (j = 0; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < nRhs; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  In interp0 mode, set the first entry based on partition of unity
      i = b_wls->nstpnts;
      for (j = 0; j < nRhs; j++) {
        real_T s;
        real_T totalw;
        s = 0.0;
        for (b_i = 2; b_i <= i; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        if (hess_data[j] > 1) {
          totalw = 0.0;
        } else {
          grad_div_size = ws.size(0);
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            totalw = nevpnts;
            //  Unit weights summed together
          } else {
            //  All weights summed together
            totalw = 0.0;
            for (b_i = 0; b_i < grad_div_size; b_i++) {
              totalw += ws[ws.size(1) * b_i];
            }
          }
        }
        vdops[j] = totalw - s;
      }
    }
    if (dim == 2) {
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        real_T b_vdops;
        real_T c_vdops;
        b_vdops = vdops[vdops.size(1) * b_i + 1];
        c_vdops = vdops[vdops.size(1) * b_i + 2];
        vdops[vdops.size(1) * b_i + 1] = b_vdops;
        vdops[vdops.size(1) * b_i + 2] = b_vdops;
        vdops[vdops.size(1) * b_i + 3] = c_vdops;
      }
    } else if (dim == 3) {
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        real_T b_vdops;
        real_T c_vdops;
        real_T d;
        real_T d_vdops;
        real_T e_vdops;
        b_vdops = vdops[vdops.size(1) * b_i + 1];
        c_vdops = vdops[vdops.size(1) * b_i + 3];
        d_vdops = vdops[vdops.size(1) * b_i + 2];
        d = vdops[vdops.size(1) * b_i + 4];
        e_vdops = vdops[vdops.size(1) * b_i + 5];
        vdops[vdops.size(1) * b_i + 1] = b_vdops;
        vdops[vdops.size(1) * b_i + 2] = c_vdops;
        vdops[vdops.size(1) * b_i + 3] = b_vdops;
        vdops[vdops.size(1) * b_i + 4] = d_vdops;
        vdops[vdops.size(1) * b_i + 5] = d;
        vdops[vdops.size(1) * b_i + 6] = c_vdops;
        vdops[vdops.size(1) * b_i + 7] = d;
        vdops[vdops.size(1) * b_i + 8] = e_vdops;
      }
    }
  } else {
    coder::SizeType grad_div_size;
    coder::SizeType i;
    coder::SizeType iWeight;
    coder::SizeType j;
    coder::SizeType lenWs;
    coder::SizeType loop_ub;
    coder::SizeType nDims;
    coder::SizeType nRhs;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType u0;
    coder::SizeType u1;
    int8_T grad_div_data[9];
    //  Each component has its own weight, we need to compute all components
    switch (b_wls->us.size(1)) {
    case 1:
      grad_div_size = 1;
      grad_div_data[0] = 3;
      break;
    case 2:
      grad_div_size = 4;
      grad_div_data[0] = 4;
      grad_div_data[1] = 5;
      grad_div_data[2] = 5;
      grad_div_data[3] = 6;
      break;
    default:
      grad_div_size = 9;
      for (i = 0; i < 9; i++) {
        grad_div_data[i] = iv6[i];
      }
      break;
    }
    nevpnts = varargin_1;
    if (varargin_1 == 0) {
      nevpnts = eval_pnts.size(0);
    }
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = nevpnts;
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((nevpnts + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (dim = 0; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[dim]) *
              b_wls->hs_inv.data[dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (dim = 0; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    c_gen_vander(b_wls->us, nevpnts, b_wls->degree, b_wls->hs_inv.data,
                 b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(grad_div_size, u0);
    loop_ub = u0 * grad_div_size;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    if (ws.size(0) == 0) {
      lenWs = 1;
    } else {
      lenWs = ws.size(1);
    }
    //  Summing up rows in the differential operator
    iWeight = 1;
    //  Loop through the operators
    for (coder::SizeType iOp{0}; iOp < grad_div_size; iOp++) {
      coder::SizeType offset;
      //  Skip padded zeros in the differential operator
      if (iOp + 1 > grad_div_size) {
        offset = 0;
      } else {
        offset = (grad_div_data[iOp] - 1) * b_wls->us.size(0);
      }
      //  Sum up monomials weighted by weights for each component
      i = b_wls->ncols - b_wls->interp0;
      for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
        j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
        if (ws.size(0) == 0) {
          for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
          }
        } else {
          for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                ws[(iWeight + ws.size(1) * iEval) - 1] *
                    b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
          }
        }
      }
      if (iWeight == lenWs) {
        iWeight = 1;
      } else {
        iWeight++;
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    nRhs = b_wls->rhs.size(0);
    //  Multiply by generalized inverse of Vandermonde matrix
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (grad_div_size = 0; grad_div_size < u0; grad_div_size++) {
          b_wls->QRt[grad_div_size + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * grad_div_size];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    }
    vdops.set_size(u1, nRhs);
    //  Transpose the operator for row-major
    i = u1 - b_wls->interp0;
    for (coder::SizeType b_i{0}; b_i < i; b_i++) {
      for (j = 0; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < nRhs; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  In interp0 mode, set the first entry based on partition of unity
      i = b_wls->nstpnts;
      for (j = 0; j < nRhs; j++) {
        real_T s;
        s = 0.0;
        for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        vdops[j] = 0.0 - s;
      }
    }
  }
  //  compute output value
  result_size[1] = 0;
  result_size[0] = 3;
}

//  wls_var_grad_div  Variational grad-div operators as weighted sum at
void wls_var_grad_div(WlsObject *b_wls,
                      const ::coder::array<real_T, 2U> &eval_pnts,
                      const ::coder::array<real_T, 2U> &ws,
                      const ::coder::array<real_T, 2U> &fs,
                      ::coder::array<real_T, 2U> &vdops, real_T result_data[],
                      coder::SizeType result_size[2])
{
  real_T b_vdops;
  real_T c_vdops;
  real_T d;
  coder::SizeType b_i;
  coder::SizeType dim;
  coder::SizeType i;
  dim = b_wls->us.size(1);
  //  compute and reorganize vdops
  if (ws.size(1) <= 1) {
    coder::SizeType grad_div_size;
    coder::SizeType j;
    coder::SizeType loop_ub;
    coder::SizeType nDiff;
    coder::SizeType nDims;
    coder::SizeType nRhs;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType u0;
    coder::SizeType u1;
    int8_T hess_data[9];
    //  All components share the same weight, we need to compute Hessian
    switch (b_wls->us.size(1)) {
    case 1:
      grad_div_size = 1;
      hess_data[0] = 3;
      break;
    case 2:
      grad_div_size = 4;
      hess_data[0] = 4;
      hess_data[1] = 5;
      hess_data[2] = 6;
      hess_data[3] = 0;
      break;
    default:
      grad_div_size = 9;
      for (i = 0; i < 9; i++) {
        hess_data[i] = iv4[i];
      }
      break;
    }
    nevpnts = eval_pnts.size(0);
    //  Step 1: Tabulate monomial basis functions at evaluation points
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = eval_pnts.size(0);
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
          b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[b_dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[b_dim]) *
              b_wls->hs_inv.data[b_dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
          b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[b_dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[b_dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    c_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree,
                 b_wls->hs_inv.data, b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    nDiff = grad_div_size;
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(grad_div_size, u0);
    loop_ub = u0 * grad_div_size;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    b_i = grad_div_size;
    while ((b_i > 0) && (b_i <= grad_div_size) && (hess_data[b_i - 1] == 0)) {
      nDiff--;
      b_i--;
    }
    //  Summing up rows in the differential operator
    for (coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > grad_div_size) || (hess_data[iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > grad_div_size) {
          offset = 0;
        } else {
          offset = (hess_data[iOp] - 1) * b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[ws.size(1) * iEval] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    nRhs = b_wls->rhs.size(0);
    //  Multiply by generalized inverse of Vandermonde matrix
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (grad_div_size = 0; grad_div_size < u0; grad_div_size++) {
          b_wls->QRt[grad_div_size + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * grad_div_size];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    }
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    vdops.set_size(u1, nRhs);
    //  Transpose the operator for row-major
    i = u1 - b_wls->interp0;
    for (b_i = 0; b_i < i; b_i++) {
      for (j = 0; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < nRhs; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  In interp0 mode, set the first entry based on partition of unity
      i = b_wls->nstpnts;
      for (j = 0; j < nRhs; j++) {
        real_T s;
        real_T totalw;
        s = 0.0;
        for (b_i = 2; b_i <= i; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        if (hess_data[j] > 1) {
          totalw = 0.0;
        } else {
          grad_div_size = ws.size(0);
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            totalw = nevpnts;
            //  Unit weights summed together
          } else {
            //  All weights summed together
            totalw = 0.0;
            for (b_i = 0; b_i < grad_div_size; b_i++) {
              totalw += ws[ws.size(1) * b_i];
            }
          }
        }
        vdops[j] = totalw - s;
      }
    }
    if (dim == 2) {
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        b_vdops = vdops[vdops.size(1) * b_i + 1];
        c_vdops = vdops[vdops.size(1) * b_i + 2];
        vdops[vdops.size(1) * b_i + 1] = b_vdops;
        vdops[vdops.size(1) * b_i + 2] = b_vdops;
        vdops[vdops.size(1) * b_i + 3] = c_vdops;
      }
    } else if (dim == 3) {
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        real_T d_vdops;
        real_T e_vdops;
        b_vdops = vdops[vdops.size(1) * b_i + 1];
        c_vdops = vdops[vdops.size(1) * b_i + 3];
        d_vdops = vdops[vdops.size(1) * b_i + 2];
        d = vdops[vdops.size(1) * b_i + 4];
        e_vdops = vdops[vdops.size(1) * b_i + 5];
        vdops[vdops.size(1) * b_i + 1] = b_vdops;
        vdops[vdops.size(1) * b_i + 2] = c_vdops;
        vdops[vdops.size(1) * b_i + 3] = b_vdops;
        vdops[vdops.size(1) * b_i + 4] = d_vdops;
        vdops[vdops.size(1) * b_i + 5] = d;
        vdops[vdops.size(1) * b_i + 6] = c_vdops;
        vdops[vdops.size(1) * b_i + 7] = d;
        vdops[vdops.size(1) * b_i + 8] = e_vdops;
      }
    }
  } else {
    coder::SizeType grad_div_size;
    coder::SizeType iWeight;
    coder::SizeType j;
    coder::SizeType lenWs;
    coder::SizeType loop_ub;
    coder::SizeType nDims;
    coder::SizeType nRhs;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType u0;
    coder::SizeType u1;
    int8_T grad_div_data[9];
    //  Each component has its own weight, we need to compute all components
    switch (b_wls->us.size(1)) {
    case 1:
      grad_div_size = 1;
      grad_div_data[0] = 3;
      break;
    case 2:
      grad_div_size = 4;
      grad_div_data[0] = 4;
      grad_div_data[1] = 5;
      grad_div_data[2] = 5;
      grad_div_data[3] = 6;
      break;
    default:
      grad_div_size = 9;
      for (i = 0; i < 9; i++) {
        grad_div_data[i] = iv6[i];
      }
      break;
    }
    nevpnts = eval_pnts.size(0) - 1;
    //  Step 1: Tabulate monomial basis functions at evaluation points
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = eval_pnts.size(0);
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
        for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
          b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[b_dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[b_dim]) *
              b_wls->hs_inv.data[b_dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
        for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
          b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[b_dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[b_dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    c_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree,
                 b_wls->hs_inv.data, b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(grad_div_size, u0);
    loop_ub = u0 * grad_div_size;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    if (ws.size(0) == 0) {
      lenWs = 1;
    } else {
      lenWs = ws.size(1);
    }
    //  Summing up rows in the differential operator
    iWeight = 1;
    //  Loop through the operators
    for (coder::SizeType iOp{0}; iOp < grad_div_size; iOp++) {
      coder::SizeType offset;
      //  Skip padded zeros in the differential operator
      if (iOp + 1 > grad_div_size) {
        offset = 0;
      } else {
        offset = (grad_div_data[iOp] - 1) * b_wls->us.size(0);
      }
      //  Sum up monomials weighted by weights for each component
      i = b_wls->ncols - b_wls->interp0;
      for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
        j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
        if (ws.size(0) == 0) {
          for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
          }
        } else {
          for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                ws[(iWeight + ws.size(1) * iEval) - 1] *
                    b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
          }
        }
      }
      if (iWeight == lenWs) {
        iWeight = 1;
      } else {
        iWeight++;
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    nRhs = b_wls->rhs.size(0);
    //  Multiply by generalized inverse of Vandermonde matrix
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (grad_div_size = 0; grad_div_size < u0; grad_div_size++) {
          b_wls->QRt[grad_div_size + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * grad_div_size];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    }
    vdops.set_size(u1, nRhs);
    //  Transpose the operator for row-major
    i = u1 - b_wls->interp0;
    for (b_i = 0; b_i < i; b_i++) {
      for (j = 0; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < nRhs; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  In interp0 mode, set the first entry based on partition of unity
      i = b_wls->nstpnts;
      for (j = 0; j < nRhs; j++) {
        real_T s;
        s = 0.0;
        for (b_i = 2; b_i <= i; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        vdops[j] = 0.0 - s;
      }
    }
  }
  //  compute output value
  if ((fs.size(0) != 0) && (fs.size(1) != 0)) {
    result_size[1] = 1;
    result_size[0] = 3;
    if (dim - 1 >= 0) {
      std::memset(&result_data[0], 0, dim * sizeof(real_T));
    }
    switch (dim) {
    case 1:
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        result_data[0] += vdops[vdops.size(1) * b_i] * fs[fs.size(1) * b_i];
      }
      break;
    case 2:
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        d = fs[fs.size(1) * b_i];
        b_vdops = fs[fs.size(1) * b_i + 1];
        result_data[0] = (result_data[0] + vdops[vdops.size(1) * b_i] * d) +
                         vdops[vdops.size(1) * b_i + 1] * b_vdops;
        result_data[1] = (result_data[1] + d * vdops[vdops.size(1) * b_i + 2]) +
                         b_vdops * vdops[vdops.size(1) * b_i + 3];
      }
      break;
    case 3:
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        d = fs[fs.size(1) * b_i];
        b_vdops = fs[fs.size(1) * b_i + 1];
        c_vdops = fs[fs.size(1) * b_i + 2];
        result_data[0] = ((result_data[0] + vdops[vdops.size(1) * b_i] * d) +
                          vdops[vdops.size(1) * b_i + 1] * b_vdops) +
                         vdops[vdops.size(1) * b_i + 2] * c_vdops;
        result_data[1] =
            ((result_data[1] + d * vdops[vdops.size(1) * b_i + 3]) +
             b_vdops * vdops[vdops.size(1) * b_i + 4]) +
            c_vdops * vdops[vdops.size(1) * b_i + 5];
        result_data[2] =
            ((result_data[2] + d * vdops[vdops.size(1) * b_i + 6]) +
             b_vdops * vdops[vdops.size(1) * b_i + 7]) +
            c_vdops * vdops[vdops.size(1) * b_i + 8];
      }
      break;
    }
  } else {
    result_size[1] = 0;
    result_size[0] = 3;
  }
}

//  wls_var_grad_div  Variational grad-div operators as weighted sum at
void wls_var_grad_div(WlsObject *b_wls,
                      const ::coder::array<real_T, 2U> &eval_pnts,
                      ::coder::array<real_T, 2U> &vdops)
{
  coder::SizeType b_i;
  coder::SizeType dim;
  coder::SizeType hess_size;
  coder::SizeType i;
  coder::SizeType j;
  coder::SizeType loop_ub;
  coder::SizeType nDiff;
  coder::SizeType nDims;
  coder::SizeType nRhs;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T hess_data[9];
  dim = b_wls->us.size(1);
  //  compute and reorganize vdops
  switch (b_wls->us.size(1)) {
  case 1:
    hess_size = 1;
    hess_data[0] = 3;
    break;
  case 2:
    hess_size = 4;
    hess_data[0] = 4;
    hess_data[1] = 5;
    hess_data[2] = 6;
    hess_data[3] = 0;
    break;
  default:
    hess_size = 9;
    for (i = 0; i < 9; i++) {
      hess_data[i] = iv4[i];
    }
    break;
  }
  nevpnts = eval_pnts.size(0);
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
        b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[b_dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[b_dim]) *
            b_wls->hs_inv.data[b_dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
        b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[b_dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[b_dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  c_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv.data,
               b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  nDiff = hess_size;
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(hess_size, u0);
  loop_ub = u0 * hess_size;
  for (i = 0; i < loop_ub; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  b_i = hess_size;
  while ((b_i > 0) && (b_i <= hess_size) && (hess_data[b_i - 1] == 0)) {
    nDiff--;
    b_i--;
  }
  //  Summing up rows in the differential operator
  for (coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
    //  Skip padded zeros in the differential operator
    if ((iOp + 1 > hess_size) || (hess_data[iOp] > 0)) {
      coder::SizeType offset;
      if (iOp + 1 > hess_size) {
        offset = 0;
      } else {
        offset = (hess_data[iOp] - 1) * b_wls->us.size(0);
      }
      //  Sum up monomials weighted by weights for each component
      i = b_wls->ncols - b_wls->interp0;
      for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
        j = b_wls->jpvt[iMonomial] + b_wls->interp0;
        for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
        }
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (hess_size = 0; hess_size < u0; hess_size++) {
        b_wls->QRt[hess_size + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * hess_size];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  vdops.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (b_i = 0; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    for (j = 0; j < nRhs; j++) {
      real_T s;
      coder::SizeType totalw;
      s = 0.0;
      for (b_i = 2; b_i <= i; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      if (hess_data[j] > 1) {
        totalw = 0;
      } else {
        totalw = nevpnts;
        //  Unit weights summed together
      }
      vdops[j] = static_cast<real_T>(totalw) - s;
    }
  }
  if (dim == 2) {
    i = b_wls->nrows;
    for (b_i = 0; b_i < i; b_i++) {
      real_T b_vdops;
      real_T c_vdops;
      b_vdops = vdops[vdops.size(1) * b_i + 1];
      c_vdops = vdops[vdops.size(1) * b_i + 2];
      vdops[vdops.size(1) * b_i + 1] = b_vdops;
      vdops[vdops.size(1) * b_i + 2] = b_vdops;
      vdops[vdops.size(1) * b_i + 3] = c_vdops;
    }
  } else if (dim == 3) {
    i = b_wls->nrows;
    for (b_i = 0; b_i < i; b_i++) {
      real_T b_vdops;
      real_T c_vdops;
      real_T d;
      real_T d_vdops;
      real_T e_vdops;
      b_vdops = vdops[vdops.size(1) * b_i + 1];
      c_vdops = vdops[vdops.size(1) * b_i + 3];
      d_vdops = vdops[vdops.size(1) * b_i + 2];
      d = vdops[vdops.size(1) * b_i + 4];
      e_vdops = vdops[vdops.size(1) * b_i + 5];
      vdops[vdops.size(1) * b_i + 1] = b_vdops;
      vdops[vdops.size(1) * b_i + 2] = c_vdops;
      vdops[vdops.size(1) * b_i + 3] = b_vdops;
      vdops[vdops.size(1) * b_i + 4] = d_vdops;
      vdops[vdops.size(1) * b_i + 5] = d;
      vdops[vdops.size(1) * b_i + 6] = c_vdops;
      vdops[vdops.size(1) * b_i + 7] = d;
      vdops[vdops.size(1) * b_i + 8] = e_vdops;
    }
  }
  //  compute output value
}

//  wls_var_grad_div  Variational grad-div operators as weighted sum at
void wls_var_grad_div(WlsObject *b_wls,
                      const ::coder::array<real_T, 2U> &eval_pnts,
                      const ::coder::array<real_T, 2U> &ws,
                      ::coder::array<real_T, 2U> &vdops)
{
  coder::SizeType dim;
  dim = b_wls->us.size(1);
  //  compute and reorganize vdops
  if (ws.size(1) <= 1) {
    coder::SizeType b_i;
    coder::SizeType grad_div_size;
    coder::SizeType i;
    coder::SizeType j;
    coder::SizeType loop_ub;
    coder::SizeType nDiff;
    coder::SizeType nDims;
    coder::SizeType nRhs;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType u0;
    coder::SizeType u1;
    int8_T hess_data[9];
    //  All components share the same weight, we need to compute Hessian
    switch (b_wls->us.size(1)) {
    case 1:
      grad_div_size = 1;
      hess_data[0] = 3;
      break;
    case 2:
      grad_div_size = 4;
      hess_data[0] = 4;
      hess_data[1] = 5;
      hess_data[2] = 6;
      hess_data[3] = 0;
      break;
    default:
      grad_div_size = 9;
      for (i = 0; i < 9; i++) {
        hess_data[i] = iv4[i];
      }
      break;
    }
    nevpnts = eval_pnts.size(0);
    //  Step 1: Tabulate monomial basis functions at evaluation points
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = eval_pnts.size(0);
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
          b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[b_dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[b_dim]) *
              b_wls->hs_inv.data[b_dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType b_dim{0}; b_dim <= nDims; b_dim++) {
          b_wls->us[b_dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[b_dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[b_dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    c_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree,
                 b_wls->hs_inv.data, b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    nDiff = grad_div_size;
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(grad_div_size, u0);
    loop_ub = u0 * grad_div_size;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    b_i = grad_div_size;
    while ((b_i > 0) && (b_i <= grad_div_size) && (hess_data[b_i - 1] == 0)) {
      nDiff--;
      b_i--;
    }
    //  Summing up rows in the differential operator
    for (coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > grad_div_size) || (hess_data[iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > grad_div_size) {
          offset = 0;
        } else {
          offset = (hess_data[iOp] - 1) * b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[ws.size(1) * iEval] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    nRhs = b_wls->rhs.size(0);
    //  Multiply by generalized inverse of Vandermonde matrix
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (grad_div_size = 0; grad_div_size < u0; grad_div_size++) {
          b_wls->QRt[grad_div_size + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * grad_div_size];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    }
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    vdops.set_size(u1, nRhs);
    //  Transpose the operator for row-major
    i = u1 - b_wls->interp0;
    for (b_i = 0; b_i < i; b_i++) {
      for (j = 0; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < nRhs; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  In interp0 mode, set the first entry based on partition of unity
      i = b_wls->nstpnts;
      for (j = 0; j < nRhs; j++) {
        real_T s;
        real_T totalw;
        s = 0.0;
        for (b_i = 2; b_i <= i; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        if (hess_data[j] > 1) {
          totalw = 0.0;
        } else {
          grad_div_size = ws.size(0);
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            totalw = nevpnts;
            //  Unit weights summed together
          } else {
            //  All weights summed together
            totalw = 0.0;
            for (b_i = 0; b_i < grad_div_size; b_i++) {
              totalw += ws[ws.size(1) * b_i];
            }
          }
        }
        vdops[j] = totalw - s;
      }
    }
    if (dim == 2) {
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        real_T b_vdops;
        real_T c_vdops;
        b_vdops = vdops[vdops.size(1) * b_i + 1];
        c_vdops = vdops[vdops.size(1) * b_i + 2];
        vdops[vdops.size(1) * b_i + 1] = b_vdops;
        vdops[vdops.size(1) * b_i + 2] = b_vdops;
        vdops[vdops.size(1) * b_i + 3] = c_vdops;
      }
    } else if (dim == 3) {
      i = b_wls->nrows;
      for (b_i = 0; b_i < i; b_i++) {
        real_T b_vdops;
        real_T c_vdops;
        real_T d;
        real_T d_vdops;
        real_T e_vdops;
        b_vdops = vdops[vdops.size(1) * b_i + 1];
        c_vdops = vdops[vdops.size(1) * b_i + 3];
        d_vdops = vdops[vdops.size(1) * b_i + 2];
        d = vdops[vdops.size(1) * b_i + 4];
        e_vdops = vdops[vdops.size(1) * b_i + 5];
        vdops[vdops.size(1) * b_i + 1] = b_vdops;
        vdops[vdops.size(1) * b_i + 2] = c_vdops;
        vdops[vdops.size(1) * b_i + 3] = b_vdops;
        vdops[vdops.size(1) * b_i + 4] = d_vdops;
        vdops[vdops.size(1) * b_i + 5] = d;
        vdops[vdops.size(1) * b_i + 6] = c_vdops;
        vdops[vdops.size(1) * b_i + 7] = d;
        vdops[vdops.size(1) * b_i + 8] = e_vdops;
      }
    }
  } else {
    coder::SizeType grad_div_size;
    coder::SizeType i;
    coder::SizeType iWeight;
    coder::SizeType j;
    coder::SizeType lenWs;
    coder::SizeType loop_ub;
    coder::SizeType nDims;
    coder::SizeType nRhs;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType u0;
    coder::SizeType u1;
    int8_T grad_div_data[9];
    //  Each component has its own weight, we need to compute all components
    switch (b_wls->us.size(1)) {
    case 1:
      grad_div_size = 1;
      grad_div_data[0] = 3;
      break;
    case 2:
      grad_div_size = 4;
      grad_div_data[0] = 4;
      grad_div_data[1] = 5;
      grad_div_data[2] = 5;
      grad_div_data[3] = 6;
      break;
    default:
      grad_div_size = 9;
      for (i = 0; i < 9; i++) {
        grad_div_data[i] = iv6[i];
      }
      break;
    }
    nevpnts = eval_pnts.size(0) - 1;
    //  Step 1: Tabulate monomial basis functions at evaluation points
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = eval_pnts.size(0);
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
        for (dim = 0; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[dim]) *
              b_wls->hs_inv.data[dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
        for (dim = 0; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    c_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree,
                 b_wls->hs_inv.data, b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(grad_div_size, u0);
    loop_ub = u0 * grad_div_size;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    if (ws.size(0) == 0) {
      lenWs = 1;
    } else {
      lenWs = ws.size(1);
    }
    //  Summing up rows in the differential operator
    iWeight = 1;
    //  Loop through the operators
    for (coder::SizeType iOp{0}; iOp < grad_div_size; iOp++) {
      coder::SizeType offset;
      //  Skip padded zeros in the differential operator
      if (iOp + 1 > grad_div_size) {
        offset = 0;
      } else {
        offset = (grad_div_data[iOp] - 1) * b_wls->us.size(0);
      }
      //  Sum up monomials weighted by weights for each component
      i = b_wls->ncols - b_wls->interp0;
      for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
        j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
        if (ws.size(0) == 0) {
          for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
          }
        } else {
          for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                ws[(iWeight + ws.size(1) * iEval) - 1] *
                    b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
          }
        }
      }
      if (iWeight == lenWs) {
        iWeight = 1;
      } else {
        iWeight++;
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    nRhs = b_wls->rhs.size(0);
    //  Multiply by generalized inverse of Vandermonde matrix
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (grad_div_size = 0; grad_div_size < u0; grad_div_size++) {
          b_wls->QRt[grad_div_size + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * grad_div_size];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, b_wls->rhs.size(0));
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                  b_wls->work);
    }
    vdops.set_size(u1, nRhs);
    //  Transpose the operator for row-major
    i = u1 - b_wls->interp0;
    for (coder::SizeType b_i{0}; b_i < i; b_i++) {
      for (j = 0; j < nRhs; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < nRhs; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  In interp0 mode, set the first entry based on partition of unity
      i = b_wls->nstpnts;
      for (j = 0; j < nRhs; j++) {
        real_T s;
        s = 0.0;
        for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        vdops[j] = 0.0 - s;
      }
    }
  }
  //  compute output value
}

//  wls_var_hess  Compute variational Hessian operators as weighted sum at
void wls_var_hess(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  const ::coder::array<real_T, 2U> &varargin_1,
                  const ::coder::array<real_T, 2U> &varargin_2,
                  coder::SizeType varargin_3,
                  ::coder::array<real_T, 2U> &varargout_1,
                  ::coder::array<real_T, 2U> &varargout_2)
{
  coder::SizeType hess_size;
  coder::SizeType i;
  coder::SizeType iOp;
  coder::SizeType iWeight;
  coder::SizeType j;
  coder::SizeType lenWs;
  coder::SizeType loop_ub;
  coder::SizeType nDims;
  coder::SizeType nOps;
  coder::SizeType nRhs;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T hess_data[6];
  switch (b_wls->us.size(1)) {
  case 1:
    hess_size = 1;
    hess_data[0] = 3;
    break;
  case 2:
    hess_size = 3;
    hess_data[0] = 4;
    hess_data[1] = 5;
    hess_data[2] = 6;
    break;
  default:
    hess_size = 6;
    for (i = 0; i < 6; i++) {
      hess_data[i] = static_cast<int8_T>(i + 5);
    }
    break;
  }
  nevpnts = varargin_3;
  if (varargin_3 == 0) {
    nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  c_gen_vander(b_wls->us, nevpnts, b_wls->degree, b_wls->hs_inv.data,
               b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(hess_size, u0);
  loop_ub = u0 * hess_size;
  for (i = 0; i < loop_ub; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
    lenWs = 1;
  } else {
    lenWs = varargin_1.size(1);
  }
  //  Summing up rows in the differential operator
  iWeight = 1;
  //  Loop through the operators
  for (iOp = 0; iOp < hess_size; iOp++) {
    coder::SizeType offset;
    //  Skip padded zeros in the differential operator
    if (iOp + 1 > hess_size) {
      offset = 0;
    } else {
      offset = (hess_data[iOp] - 1) * b_wls->us.size(0);
    }
    //  Sum up monomials weighted by weights for each component
    i = b_wls->ncols - b_wls->interp0;
    for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
      if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
        for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      } else {
        for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              varargin_1[(iWeight + varargin_1.size(1) * iEval) - 1] *
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      }
    }
    if (iWeight == lenWs) {
      iWeight = 1;
    } else {
      iWeight++;
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (hess_size = 0; hess_size < u0; hess_size++) {
        b_wls->QRt[hess_size + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * hess_size];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  varargout_1.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      varargout_1[j + varargout_1.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        varargout_1[k + varargout_1.size(1) * iRow] =
            varargout_1[k + varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    for (j = 0; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += varargout_1[j + varargout_1.size(1) * (b_i - 1)];
      }
      varargout_1[j] = 0.0 - s;
    }
  }
  //  Step 4: Optionally, evaluate the operator
  nOps = varargout_1.size(1);
  if ((varargin_2.size(0) == 0) || (varargin_2.size(1) == 0)) {
    varargout_2.set_size(0, 1);
  } else {
    varargout_2.set_size(varargout_1.size(1), varargin_2.size(1));
    loop_ub = varargin_2.size(1) * varargout_1.size(1);
    for (i = 0; i < loop_ub; i++) {
      varargout_2[i] = 0.0;
    }
    //  Compute solution
    i = varargin_2.size(1);
    for (coder::SizeType iFunc{0}; iFunc < i; iFunc++) {
      iOp = 0;
      for (coder::SizeType iDiff{0}; iDiff < nOps; iDiff++) {
        hess_size = b_wls->nrows;
        for (coder::SizeType iRow{0}; iRow < hess_size; iRow++) {
          varargout_2[iFunc + varargout_2.size(1) * iOp] =
              varargout_2[iFunc + varargout_2.size(1) * iOp] +
              varargin_2[iFunc + varargin_2.size(1) * iRow] *
                  varargout_1[iDiff + varargout_1.size(1) * iRow];
        }
        if (iOp + 1 == varargout_2.size(0)) {
          iOp = 0;
        } else {
          iOp++;
        }
      }
    }
  }
}

//  wls_var_hess  Compute variational Hessian operators as weighted sum at
void wls_var_hess(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  const ::coder::array<real_T, 2U> &varargin_1,
                  const ::coder::array<real_T, 2U> &varargin_2,
                  ::coder::array<real_T, 2U> &varargout_1,
                  ::coder::array<real_T, 2U> &varargout_2)
{
  coder::SizeType hess_size;
  coder::SizeType i;
  coder::SizeType iOp;
  coder::SizeType iWeight;
  coder::SizeType j;
  coder::SizeType lenWs;
  coder::SizeType loop_ub;
  coder::SizeType nDims;
  coder::SizeType nOps;
  coder::SizeType nRhs;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T hess_data[6];
  switch (b_wls->us.size(1)) {
  case 1:
    hess_size = 1;
    hess_data[0] = 3;
    break;
  case 2:
    hess_size = 3;
    hess_data[0] = 4;
    hess_data[1] = 5;
    hess_data[2] = 6;
    break;
  default:
    hess_size = 6;
    for (i = 0; i < 6; i++) {
      hess_data[i] = static_cast<int8_T>(i + 5);
    }
    break;
  }
  nevpnts = eval_pnts.size(0) - 1;
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  c_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv.data,
               b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(hess_size, u0);
  loop_ub = u0 * hess_size;
  for (i = 0; i < loop_ub; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
    lenWs = 1;
  } else {
    lenWs = varargin_1.size(1);
  }
  //  Summing up rows in the differential operator
  iWeight = 1;
  //  Loop through the operators
  for (iOp = 0; iOp < hess_size; iOp++) {
    coder::SizeType offset;
    //  Skip padded zeros in the differential operator
    if (iOp + 1 > hess_size) {
      offset = 0;
    } else {
      offset = (hess_data[iOp] - 1) * b_wls->us.size(0);
    }
    //  Sum up monomials weighted by weights for each component
    i = b_wls->ncols - b_wls->interp0;
    for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
      if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
        for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      } else {
        for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              varargin_1[(iWeight + varargin_1.size(1) * iEval) - 1] *
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      }
    }
    if (iWeight == lenWs) {
      iWeight = 1;
    } else {
      iWeight++;
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (hess_size = 0; hess_size < u0; hess_size++) {
        b_wls->QRt[hess_size + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * hess_size];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  varargout_1.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      varargout_1[j + varargout_1.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        varargout_1[k + varargout_1.size(1) * iRow] =
            varargout_1[k + varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    for (j = 0; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += varargout_1[j + varargout_1.size(1) * (b_i - 1)];
      }
      varargout_1[j] = 0.0 - s;
    }
  }
  //  Step 4: Optionally, evaluate the operator
  nOps = varargout_1.size(1);
  if ((varargin_2.size(0) == 0) || (varargin_2.size(1) == 0)) {
    varargout_2.set_size(0, 1);
  } else {
    varargout_2.set_size(varargout_1.size(1), varargin_2.size(1));
    loop_ub = varargin_2.size(1) * varargout_1.size(1);
    for (i = 0; i < loop_ub; i++) {
      varargout_2[i] = 0.0;
    }
    //  Compute solution
    i = varargin_2.size(1);
    for (coder::SizeType iFunc{0}; iFunc < i; iFunc++) {
      iOp = 0;
      for (coder::SizeType iDiff{0}; iDiff < nOps; iDiff++) {
        hess_size = b_wls->nrows;
        for (coder::SizeType iRow{0}; iRow < hess_size; iRow++) {
          varargout_2[iFunc + varargout_2.size(1) * iOp] =
              varargout_2[iFunc + varargout_2.size(1) * iOp] +
              varargin_2[iFunc + varargin_2.size(1) * iRow] *
                  varargout_1[iDiff + varargout_1.size(1) * iRow];
        }
        if (iOp + 1 == varargout_2.size(0)) {
          iOp = 0;
        } else {
          iOp++;
        }
      }
    }
  }
}

//  wls_var_hess  Compute variational Hessian operators as weighted sum at
void wls_var_hess(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  ::coder::array<real_T, 2U> &varargout_1)
{
  coder::SizeType hess_size;
  coder::SizeType i;
  coder::SizeType j;
  coder::SizeType loop_ub;
  coder::SizeType nDims;
  coder::SizeType nRhs;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T hess_data[6];
  switch (b_wls->us.size(1)) {
  case 1:
    hess_size = 1;
    hess_data[0] = 3;
    break;
  case 2:
    hess_size = 3;
    hess_data[0] = 4;
    hess_data[1] = 5;
    hess_data[2] = 6;
    break;
  default:
    hess_size = 6;
    for (i = 0; i < 6; i++) {
      hess_data[i] = static_cast<int8_T>(i + 5);
    }
    break;
  }
  nevpnts = eval_pnts.size(0);
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  c_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv.data,
               b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(hess_size, u0);
  loop_ub = u0 * hess_size;
  for (i = 0; i < loop_ub; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  for (coder::SizeType iOp{0}; iOp < hess_size; iOp++) {
    coder::SizeType offset;
    //  Skip padded zeros in the differential operator
    if (iOp + 1 > hess_size) {
      offset = 0;
    } else {
      offset = (hess_data[iOp] - 1) * b_wls->us.size(0);
    }
    //  Sum up monomials weighted by weights for each component
    i = b_wls->ncols - b_wls->interp0;
    for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      j = b_wls->jpvt[iMonomial] + b_wls->interp0;
      for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
        b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
            b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (hess_size = 0; hess_size < u0; hess_size++) {
        b_wls->QRt[hess_size + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * hess_size];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  varargout_1.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      varargout_1[j + varargout_1.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        varargout_1[k + varargout_1.size(1) * iRow] =
            varargout_1[k + varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    for (j = 0; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += varargout_1[j + varargout_1.size(1) * (b_i - 1)];
      }
      varargout_1[j] = 0.0 - s;
    }
  }
}

//  wls_var_hess  Compute variational Hessian operators as weighted sum at
void wls_var_hess(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                  const ::coder::array<real_T, 2U> &varargin_1,
                  ::coder::array<real_T, 2U> &varargout_1)
{
  coder::SizeType hess_size;
  coder::SizeType i;
  coder::SizeType iWeight;
  coder::SizeType j;
  coder::SizeType lenWs;
  coder::SizeType loop_ub;
  coder::SizeType nDims;
  coder::SizeType nRhs;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T hess_data[6];
  switch (b_wls->us.size(1)) {
  case 1:
    hess_size = 1;
    hess_data[0] = 3;
    break;
  case 2:
    hess_size = 3;
    hess_data[0] = 4;
    hess_data[1] = 5;
    hess_data[2] = 6;
    break;
  default:
    hess_size = 6;
    for (i = 0; i < 6; i++) {
      hess_data[i] = static_cast<int8_T>(i + 5);
    }
    break;
  }
  nevpnts = eval_pnts.size(0) - 1;
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  c_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv.data,
               b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(hess_size, u0);
  loop_ub = u0 * hess_size;
  for (i = 0; i < loop_ub; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
    lenWs = 1;
  } else {
    lenWs = varargin_1.size(1);
  }
  //  Summing up rows in the differential operator
  iWeight = 1;
  //  Loop through the operators
  for (coder::SizeType iOp{0}; iOp < hess_size; iOp++) {
    coder::SizeType offset;
    //  Skip padded zeros in the differential operator
    if (iOp + 1 > hess_size) {
      offset = 0;
    } else {
      offset = (hess_data[iOp] - 1) * b_wls->us.size(0);
    }
    //  Sum up monomials weighted by weights for each component
    i = b_wls->ncols - b_wls->interp0;
    for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
      if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
        for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      } else {
        for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              varargin_1[(iWeight + varargin_1.size(1) * iEval) - 1] *
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      }
    }
    if (iWeight == lenWs) {
      iWeight = 1;
    } else {
      iWeight++;
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (hess_size = 0; hess_size < u0; hess_size++) {
        b_wls->QRt[hess_size + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * hess_size];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  varargout_1.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      varargout_1[j + varargout_1.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        varargout_1[k + varargout_1.size(1) * iRow] =
            varargout_1[k + varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    for (j = 0; j < nRhs; j++) {
      real_T s;
      s = 0.0;
      for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
        s += varargout_1[j + varargout_1.size(1) * (b_i - 1)];
      }
      varargout_1[j] = 0.0 - s;
    }
  }
}

//  wls_var_kernel  Kernel function for compute variational differential
void wls_var_kernel(WlsObject *b_wls,
                    const ::coder::array<real_T, 2U> &eval_pnts,
                    coder::SizeType order,
                    const ::coder::array<int8_T, 2U> &diff_idx,
                    const ::coder::array<real_T, 2U> &ws,
                    const ::coder::array<real_T, 2U> &fs,
                    coder::SizeType nevpnts, ::coder::array<real_T, 2U> &vdops,
                    ::coder::array<real_T, 2U> &result)
{
  coder::SizeType b_i;
  coder::SizeType b_nevpnts;
  coder::SizeType i;
  coder::SizeType i1;
  coder::SizeType iOp;
  coder::SizeType iWeight;
  coder::SizeType j;
  coder::SizeType lenWs;
  coder::SizeType loop_ub;
  coder::SizeType nDiff;
  coder::SizeType nDims;
  coder::SizeType nOps;
  coder::SizeType nRhs;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  b_nevpnts = nevpnts;
  if (nevpnts == 0) {
    b_nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = b_nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((b_nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < b_nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, b_nevpnts, b_wls->degree, order, b_wls->hs_inv.data,
             b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  nDiff = diff_idx.size(0);
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(diff_idx.size(0), u0);
  loop_ub = u0 * diff_idx.size(0);
  for (i = 0; i < loop_ub; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  b_i = diff_idx.size(0);
  while ((b_i > 0) && (b_i <= diff_idx.size(0)) &&
         (diff_idx[diff_idx.size(1) * (b_i - 1)] == 0)) {
    nDiff--;
    b_i--;
  }
  if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
    lenWs = 1;
  } else {
    lenWs = ws.size(1);
  }
  //  Summing up rows in the differential operator
  i = diff_idx.size(1);
  for (coder::SizeType jDiff{0}; jDiff < i; jDiff++) {
    iWeight = 1;
    //  Loop through the operators
    for (iOp = 0; iOp < nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > diff_idx.size(0)) ||
          (diff_idx[jDiff + diff_idx.size(1) * iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > diff_idx.size(0)) {
          offset = 0;
        } else {
          offset = (diff_idx[jDiff + diff_idx.size(1) * iOp] - 1) *
                   b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i1 = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i1; iMonomial++) {
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            for (coder::SizeType iEval{0}; iEval < b_nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval < b_nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[(iWeight + ws.size(1) * iEval) - 1] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
      if (iWeight == lenWs) {
        iWeight = 1;
      } else {
        iWeight++;
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (i1 = 0; i1 < u0; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  vdops.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (b_i = 0; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    boolean_T b;
    boolean_T b1;
    //  In interp0 mode, set the first entry based on partition of unity
    iWeight = 1;
    b = true;
    b1 = ((diff_idx.size(1) <= 0) || (diff_idx.size(0) <= 0));
    i = diff_idx.size(1) * diff_idx.size(0);
    i1 = 0;
    for (j = 0; j < nRhs; j++) {
      real_T s;
      real_T totalw;
      if (b1 || (j >= i)) {
        i1 = 0;
        b = true;
      } else if (b) {
        b = false;
        i1 = j % diff_idx.size(0) * diff_idx.size(1) + j / diff_idx.size(0);
      } else {
        u0 = diff_idx.size(1) * diff_idx.size(0) - 1;
        if (i1 > MAX_int32_T - diff_idx.size(1)) {
          i1 = j % diff_idx.size(0) * diff_idx.size(1) + j / diff_idx.size(0);
        } else {
          i1 += diff_idx.size(1);
          if (i1 > u0) {
            i1 -= u0;
          }
        }
      }
      s = 0.0;
      u0 = b_wls->nstpnts;
      for (b_i = 2; b_i <= u0; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      if (diff_idx[i1] > 1) {
        totalw = 0.0;
      } else {
        u0 = ws.size(0);
        if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
          totalw = b_nevpnts;
          //  Unit weights summed together
        } else {
          //  All weights summed together
          totalw = 0.0;
          for (b_i = 0; b_i < u0; b_i++) {
            totalw += ws[(iWeight + ws.size(1) * b_i) - 1];
          }
          iWeight += iWeight < ws.size(1);
        }
      }
      vdops[j] = totalw - s;
    }
  }
  //  Step 4: Optionally, evaluate the operator
  nOps = vdops.size(1) - 1;
  if ((fs.size(0) == 0) || (fs.size(1) == 0)) {
    result.set_size(0, 1);
  } else if (order == -1) {
    coder::SizeType iFunc;
    u0 = vdops.size(1) / b_wls->us.size(1);
    result.set_size(u0, 1);
    for (i = 0; i < u0; i++) {
      result[i] = 0.0;
    }
    //  Compute solution
    iFunc = 1;
    iOp = 0;
    for (coder::SizeType iDiff{0}; iDiff <= nOps; iDiff++) {
      i = b_wls->nrows;
      for (coder::SizeType iRow{0}; iRow < i; iRow++) {
        result[iOp % result.size(0) + iOp / result.size(0)] =
            result[iOp % result.size(0) + iOp / result.size(0)] +
            fs[(iFunc + fs.size(1) * iRow) - 1] *
                vdops[iDiff + vdops.size(1) * iRow];
      }
      if (iOp + 1 == result.size(0)) {
        iOp = 0;
      } else {
        iOp++;
      }
      if (iFunc == fs.size(1)) {
        iFunc = 1;
      } else {
        iFunc++;
      }
    }
  } else {
    result.set_size(vdops.size(1), fs.size(1));
    loop_ub = fs.size(1) * vdops.size(1);
    for (i = 0; i < loop_ub; i++) {
      result[i] = 0.0;
    }
    //  Compute solution
    i = fs.size(1);
    for (coder::SizeType iFunc{0}; iFunc < i; iFunc++) {
      iOp = 0;
      for (coder::SizeType iDiff{0}; iDiff <= nOps; iDiff++) {
        i1 = b_wls->nrows;
        for (coder::SizeType iRow{0}; iRow < i1; iRow++) {
          result[iFunc + result.size(1) * iOp] =
              result[iFunc + result.size(1) * iOp] +
              fs[iFunc + fs.size(1) * iRow] *
                  vdops[iDiff + vdops.size(1) * iRow];
        }
        if (iOp + 1 == result.size(0)) {
          iOp = 0;
        } else {
          iOp++;
        }
      }
    }
  }
}

//  wls_var_kernel  Kernel function for compute variational differential
void wls_var_kernel(
    WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
    coder::SizeType order, const ::coder::array<int8_T, 2U> &diff_idx,
    const ::coder::array<real_T, 2U> &ws, const ::coder::array<real_T, 2U> &fs,
    ::coder::array<real_T, 2U> &vdops, ::coder::array<real_T, 2U> &result)
{
  coder::SizeType b_i;
  coder::SizeType i;
  coder::SizeType i1;
  coder::SizeType iOp;
  coder::SizeType iWeight;
  coder::SizeType j;
  coder::SizeType lenWs;
  coder::SizeType loop_ub;
  coder::SizeType nDiff;
  coder::SizeType nDims;
  coder::SizeType nOps;
  coder::SizeType nRhs;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  nevpnts = eval_pnts.size(0);
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, order,
             b_wls->hs_inv.data, b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  nDiff = diff_idx.size(0);
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(diff_idx.size(0), u0);
  loop_ub = u0 * diff_idx.size(0);
  for (i = 0; i < loop_ub; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  b_i = diff_idx.size(0);
  while ((b_i > 0) && (b_i <= diff_idx.size(0)) &&
         (diff_idx[diff_idx.size(1) * (b_i - 1)] == 0)) {
    nDiff--;
    b_i--;
  }
  if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
    lenWs = 1;
  } else {
    lenWs = ws.size(1);
  }
  //  Summing up rows in the differential operator
  i = diff_idx.size(1);
  for (coder::SizeType jDiff{0}; jDiff < i; jDiff++) {
    iWeight = 1;
    //  Loop through the operators
    for (iOp = 0; iOp < nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > diff_idx.size(0)) ||
          (diff_idx[jDiff + diff_idx.size(1) * iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > diff_idx.size(0)) {
          offset = 0;
        } else {
          offset = (diff_idx[jDiff + diff_idx.size(1) * iOp] - 1) *
                   b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i1 = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i1; iMonomial++) {
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[(iWeight + ws.size(1) * iEval) - 1] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
      if (iWeight == lenWs) {
        iWeight = 1;
      } else {
        iWeight++;
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (i1 = 0; i1 < u0; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  vdops.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (b_i = 0; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    boolean_T b;
    boolean_T b1;
    //  In interp0 mode, set the first entry based on partition of unity
    iWeight = 1;
    b = true;
    b1 = ((diff_idx.size(1) <= 0) || (diff_idx.size(0) <= 0));
    i = diff_idx.size(1) * diff_idx.size(0);
    i1 = 0;
    for (j = 0; j < nRhs; j++) {
      real_T s;
      real_T totalw;
      if (b1 || (j >= i)) {
        i1 = 0;
        b = true;
      } else if (b) {
        b = false;
        i1 = j % diff_idx.size(0) * diff_idx.size(1) + j / diff_idx.size(0);
      } else {
        u0 = diff_idx.size(1) * diff_idx.size(0) - 1;
        if (i1 > MAX_int32_T - diff_idx.size(1)) {
          i1 = j % diff_idx.size(0) * diff_idx.size(1) + j / diff_idx.size(0);
        } else {
          i1 += diff_idx.size(1);
          if (i1 > u0) {
            i1 -= u0;
          }
        }
      }
      s = 0.0;
      u0 = b_wls->nstpnts;
      for (b_i = 2; b_i <= u0; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      if (diff_idx[i1] > 1) {
        totalw = 0.0;
      } else {
        u0 = ws.size(0);
        if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
          totalw = nevpnts;
          //  Unit weights summed together
        } else {
          //  All weights summed together
          totalw = 0.0;
          for (b_i = 0; b_i < u0; b_i++) {
            totalw += ws[(iWeight + ws.size(1) * b_i) - 1];
          }
          iWeight += iWeight < ws.size(1);
        }
      }
      vdops[j] = totalw - s;
    }
  }
  //  Step 4: Optionally, evaluate the operator
  nOps = vdops.size(1) - 1;
  if ((fs.size(0) == 0) || (fs.size(1) == 0)) {
    result.set_size(0, 1);
  } else if (order == -1) {
    coder::SizeType iFunc;
    u0 = vdops.size(1) / b_wls->us.size(1);
    result.set_size(u0, 1);
    for (i = 0; i < u0; i++) {
      result[i] = 0.0;
    }
    //  Compute solution
    iFunc = 1;
    iOp = 0;
    for (coder::SizeType iDiff{0}; iDiff <= nOps; iDiff++) {
      i = b_wls->nrows;
      for (coder::SizeType iRow{0}; iRow < i; iRow++) {
        result[iOp % result.size(0) + iOp / result.size(0)] =
            result[iOp % result.size(0) + iOp / result.size(0)] +
            fs[(iFunc + fs.size(1) * iRow) - 1] *
                vdops[iDiff + vdops.size(1) * iRow];
      }
      if (iOp + 1 == result.size(0)) {
        iOp = 0;
      } else {
        iOp++;
      }
      if (iFunc == fs.size(1)) {
        iFunc = 1;
      } else {
        iFunc++;
      }
    }
  } else {
    result.set_size(vdops.size(1), fs.size(1));
    loop_ub = fs.size(1) * vdops.size(1);
    for (i = 0; i < loop_ub; i++) {
      result[i] = 0.0;
    }
    //  Compute solution
    i = fs.size(1);
    for (coder::SizeType iFunc{0}; iFunc < i; iFunc++) {
      iOp = 0;
      for (coder::SizeType iDiff{0}; iDiff <= nOps; iDiff++) {
        i1 = b_wls->nrows;
        for (coder::SizeType iRow{0}; iRow < i1; iRow++) {
          result[iFunc + result.size(1) * iOp] =
              result[iFunc + result.size(1) * iOp] +
              fs[iFunc + fs.size(1) * iRow] *
                  vdops[iDiff + vdops.size(1) * iRow];
        }
        if (iOp + 1 == result.size(0)) {
          iOp = 0;
        } else {
          iOp++;
        }
      }
    }
  }
}

//  wls_var_kernel  Kernel function for compute variational differential
void wls_var_kernel(WlsObject *b_wls,
                    const ::coder::array<real_T, 2U> &eval_pnts,
                    coder::SizeType order,
                    const ::coder::array<int8_T, 2U> &diff_idx,
                    ::coder::array<real_T, 2U> &vdops,
                    ::coder::array<real_T, 2U> &result)
{
  coder::SizeType b_i;
  coder::SizeType i;
  coder::SizeType i1;
  coder::SizeType j;
  coder::SizeType loop_ub;
  coder::SizeType nDiff;
  coder::SizeType nDims;
  coder::SizeType nRhs;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  nevpnts = eval_pnts.size(0);
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, order,
             b_wls->hs_inv.data, b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  nDiff = diff_idx.size(0);
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(diff_idx.size(0), u0);
  loop_ub = u0 * diff_idx.size(0);
  for (i = 0; i < loop_ub; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  b_i = diff_idx.size(0);
  while ((b_i > 0) && (b_i <= diff_idx.size(0)) &&
         (diff_idx[diff_idx.size(1) * (b_i - 1)] == 0)) {
    nDiff--;
    b_i--;
  }
  //  Summing up rows in the differential operator
  i = diff_idx.size(1);
  for (coder::SizeType jDiff{0}; jDiff < i; jDiff++) {
    //  Loop through the operators
    for (coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > diff_idx.size(0)) ||
          (diff_idx[jDiff + diff_idx.size(1) * iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > diff_idx.size(0)) {
          offset = 0;
        } else {
          offset = (diff_idx[jDiff + diff_idx.size(1) * iOp] - 1) *
                   b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i1 = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i1; iMonomial++) {
          j = b_wls->jpvt[iMonomial] + b_wls->interp0;
          for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
            b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
          }
        }
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (i1 = 0; i1 < u0; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  vdops.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (b_i = 0; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    boolean_T b;
    boolean_T b1;
    //  In interp0 mode, set the first entry based on partition of unity
    b = true;
    b1 = ((diff_idx.size(1) <= 0) || (diff_idx.size(0) <= 0));
    i = diff_idx.size(1) * diff_idx.size(0);
    i1 = 0;
    for (j = 0; j < nRhs; j++) {
      real_T s;
      coder::SizeType totalw;
      if (b1 || (j >= i)) {
        i1 = 0;
        b = true;
      } else if (b) {
        b = false;
        i1 = j % diff_idx.size(0) * diff_idx.size(1) + j / diff_idx.size(0);
      } else {
        u0 = diff_idx.size(1) * diff_idx.size(0) - 1;
        if (i1 > MAX_int32_T - diff_idx.size(1)) {
          i1 = j % diff_idx.size(0) * diff_idx.size(1) + j / diff_idx.size(0);
        } else {
          i1 += diff_idx.size(1);
          if (i1 > u0) {
            i1 -= u0;
          }
        }
      }
      s = 0.0;
      u0 = b_wls->nstpnts;
      for (b_i = 2; b_i <= u0; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      if (diff_idx[i1] > 1) {
        totalw = 0;
      } else {
        totalw = nevpnts;
        //  Unit weights summed together
      }
      vdops[j] = static_cast<real_T>(totalw) - s;
    }
  }
  //  Step 4: Optionally, evaluate the operator
  result.set_size(0, 1);
}

//  wls_var_kernel  Kernel function for compute variational differential
void wls_var_kernel(WlsObject *b_wls,
                    const ::coder::array<real_T, 2U> &eval_pnts,
                    coder::SizeType order,
                    const ::coder::array<int8_T, 2U> &diff_idx,
                    const ::coder::array<real_T, 2U> &ws,
                    ::coder::array<real_T, 2U> &vdops,
                    ::coder::array<real_T, 2U> &result)
{
  coder::SizeType b_i;
  coder::SizeType i;
  coder::SizeType i1;
  coder::SizeType iWeight;
  coder::SizeType j;
  coder::SizeType lenWs;
  coder::SizeType loop_ub;
  coder::SizeType nDiff;
  coder::SizeType nDims;
  coder::SizeType nRhs;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  nevpnts = eval_pnts.size(0);
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, order,
             b_wls->hs_inv.data, b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  nDiff = diff_idx.size(0);
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(diff_idx.size(0), u0);
  loop_ub = u0 * diff_idx.size(0);
  for (i = 0; i < loop_ub; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  b_i = diff_idx.size(0);
  while ((b_i > 0) && (b_i <= diff_idx.size(0)) &&
         (diff_idx[diff_idx.size(1) * (b_i - 1)] == 0)) {
    nDiff--;
    b_i--;
  }
  if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
    lenWs = 1;
  } else {
    lenWs = ws.size(1);
  }
  //  Summing up rows in the differential operator
  i = diff_idx.size(1);
  for (coder::SizeType jDiff{0}; jDiff < i; jDiff++) {
    iWeight = 1;
    //  Loop through the operators
    for (coder::SizeType iOp{0}; iOp < nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > diff_idx.size(0)) ||
          (diff_idx[jDiff + diff_idx.size(1) * iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > diff_idx.size(0)) {
          offset = 0;
        } else {
          offset = (diff_idx[jDiff + diff_idx.size(1) * iOp] - 1) *
                   b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i1 = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i1; iMonomial++) {
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[(iWeight + ws.size(1) * iEval) - 1] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
      if (iWeight == lenWs) {
        iWeight = 1;
      } else {
        iWeight++;
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  nRhs = b_wls->rhs.size(0);
  //  Multiply by generalized inverse of Vandermonde matrix
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (i1 = 0; i1 < u0; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, b_wls->rhs.size(0));
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, nRhs,
                b_wls->work);
  }
  vdops.set_size(u1, nRhs);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (b_i = 0; b_i < i; b_i++) {
    for (j = 0; j < nRhs; j++) {
      vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < nRhs; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    boolean_T b;
    boolean_T b1;
    //  In interp0 mode, set the first entry based on partition of unity
    iWeight = 1;
    b = true;
    b1 = ((diff_idx.size(1) <= 0) || (diff_idx.size(0) <= 0));
    i = diff_idx.size(1) * diff_idx.size(0);
    i1 = 0;
    for (j = 0; j < nRhs; j++) {
      real_T s;
      real_T totalw;
      if (b1 || (j >= i)) {
        i1 = 0;
        b = true;
      } else if (b) {
        b = false;
        i1 = j % diff_idx.size(0) * diff_idx.size(1) + j / diff_idx.size(0);
      } else {
        u0 = diff_idx.size(1) * diff_idx.size(0) - 1;
        if (i1 > MAX_int32_T - diff_idx.size(1)) {
          i1 = j % diff_idx.size(0) * diff_idx.size(1) + j / diff_idx.size(0);
        } else {
          i1 += diff_idx.size(1);
          if (i1 > u0) {
            i1 -= u0;
          }
        }
      }
      s = 0.0;
      u0 = b_wls->nstpnts;
      for (b_i = 2; b_i <= u0; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      if (diff_idx[i1] > 1) {
        totalw = 0.0;
      } else {
        u0 = ws.size(0);
        if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
          totalw = nevpnts;
          //  Unit weights summed together
        } else {
          //  All weights summed together
          totalw = 0.0;
          for (b_i = 0; b_i < u0; b_i++) {
            totalw += ws[(iWeight + ws.size(1) * b_i) - 1];
          }
          iWeight += iWeight < ws.size(1);
        }
      }
      vdops[j] = totalw - s;
    }
  }
  //  Step 4: Optionally, evaluate the operator
  result.set_size(0, 1);
}

//  wls_var_lap  Compute variational Laplacian as weighted sum at evaluation
void wls_var_lap(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                 const ::coder::array<real_T, 2U> &varargin_1,
                 const ::coder::array<real_T, 2U> &varargin_2,
                 coder::SizeType varargin_3,
                 ::coder::array<real_T, 2U> &varargout_1,
                 ::coder::array<real_T, 2U> &varargout_2)
{
  coder::SizeType i;
  coder::SizeType i1;
  coder::SizeType lap_size_idx_1;
  coder::SizeType nDims;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T lap_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    lap_size_idx_1 = 1;
    lap_data[0] = 3;
    break;
  case 2:
    lap_size_idx_1 = 2;
    lap_data[0] = 4;
    lap_data[1] = 5;
    break;
  default:
    lap_size_idx_1 = 3;
    lap_data[0] = 5;
    lap_data[1] = 6;
    lap_data[2] = 7;
    break;
  }
  nevpnts = varargin_3;
  if (varargin_3 == 0) {
    nevpnts = eval_pnts.size(0);
  }
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = nevpnts;
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((nevpnts + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  e_gen_vander(b_wls->us, nevpnts, b_wls->degree, b_wls->hs_inv.data,
               b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(1, u0);
  for (i = 0; i < u0; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  for (coder::SizeType jDiff{0}; jDiff < lap_size_idx_1; jDiff++) {
    coder::SizeType offset;
    //  Loop through the operators
    offset = (lap_data[jDiff] - 1) * b_wls->us.size(0);
    //  Sum up monomials weighted by weights for each component
    i = b_wls->ncols - b_wls->interp0;
    for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      coder::SizeType j;
      j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
      if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
        for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
          b_wls->rhs[iMonomial] =
              b_wls->rhs[iMonomial] +
              b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      } else {
        for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
          b_wls->rhs[iMonomial] =
              b_wls->rhs[iMonomial] +
              varargin_1[varargin_1.size(1) * iEval] *
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    u0 = b_wls->QR.size(1);
    for (i = 0; i < u0; i++) {
      lap_size_idx_1 = b_wls->QR.size(0);
      for (i1 = 0; i1 < lap_size_idx_1; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  }
  varargout_1.set_size(u1, 1);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    varargout_1[varargout_1.size(1) * (b_i + b_wls->interp0)] = b_wls->rhs[b_i];
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
      varargout_1[varargout_1.size(1) * iRow] =
          varargout_1[varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
    }
  }
  if (b_wls->interp0 != 0) {
    real_T s;
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    s = 0.0;
    for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
      s += varargout_1[varargout_1.size(1) * (b_i - 1)];
    }
    varargout_1[0] = 0.0 - s;
  }
  //  Step 4: Optionally, evaluate the operator
  if ((varargin_2.size(0) == 0) || (varargin_2.size(1) == 0)) {
    varargout_2.set_size(0, 1);
  } else {
    varargout_2.set_size(1, varargin_2.size(1));
    u0 = varargin_2.size(1);
    for (i = 0; i < u0; i++) {
      varargout_2[i] = 0.0;
    }
    //  Compute solution
    i = varargin_2.size(1);
    i1 = b_wls->nrows;
    for (coder::SizeType iFunc{0}; iFunc < i; iFunc++) {
      for (coder::SizeType iRow{0}; iRow < i1; iRow++) {
        varargout_2[iFunc] =
            varargout_2[iFunc] + varargin_2[iFunc + varargin_2.size(1) * iRow] *
                                     varargout_1[varargout_1.size(1) * iRow];
      }
    }
  }
}

//  wls_var_lap  Compute variational Laplacian as weighted sum at evaluation
void wls_var_lap(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                 const ::coder::array<real_T, 2U> &varargin_1,
                 const ::coder::array<real_T, 2U> &varargin_2,
                 ::coder::array<real_T, 2U> &varargout_1,
                 ::coder::array<real_T, 2U> &varargout_2)
{
  coder::SizeType i;
  coder::SizeType i1;
  coder::SizeType lap_size_idx_1;
  coder::SizeType nDims;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T lap_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    lap_size_idx_1 = 1;
    lap_data[0] = 3;
    break;
  case 2:
    lap_size_idx_1 = 2;
    lap_data[0] = 4;
    lap_data[1] = 5;
    break;
  default:
    lap_size_idx_1 = 3;
    lap_data[0] = 5;
    lap_data[1] = 6;
    lap_data[2] = 7;
    break;
  }
  nevpnts = eval_pnts.size(0) - 1;
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  e_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv.data,
               b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(1, u0);
  for (i = 0; i < u0; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  for (coder::SizeType jDiff{0}; jDiff < lap_size_idx_1; jDiff++) {
    coder::SizeType offset;
    //  Loop through the operators
    offset = (lap_data[jDiff] - 1) * b_wls->us.size(0);
    //  Sum up monomials weighted by weights for each component
    i = b_wls->ncols - b_wls->interp0;
    for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      coder::SizeType j;
      j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
      if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
        for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial] =
              b_wls->rhs[iMonomial] +
              b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      } else {
        for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial] =
              b_wls->rhs[iMonomial] +
              varargin_1[varargin_1.size(1) * iEval] *
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    u0 = b_wls->QR.size(1);
    for (i = 0; i < u0; i++) {
      lap_size_idx_1 = b_wls->QR.size(0);
      for (i1 = 0; i1 < lap_size_idx_1; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  }
  varargout_1.set_size(u1, 1);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    varargout_1[varargout_1.size(1) * (b_i + b_wls->interp0)] = b_wls->rhs[b_i];
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
      varargout_1[varargout_1.size(1) * iRow] =
          varargout_1[varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
    }
  }
  if (b_wls->interp0 != 0) {
    real_T s;
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    s = 0.0;
    for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
      s += varargout_1[varargout_1.size(1) * (b_i - 1)];
    }
    varargout_1[0] = 0.0 - s;
  }
  //  Step 4: Optionally, evaluate the operator
  if ((varargin_2.size(0) == 0) || (varargin_2.size(1) == 0)) {
    varargout_2.set_size(0, 1);
  } else {
    varargout_2.set_size(1, varargin_2.size(1));
    u0 = varargin_2.size(1);
    for (i = 0; i < u0; i++) {
      varargout_2[i] = 0.0;
    }
    //  Compute solution
    i = varargin_2.size(1);
    i1 = b_wls->nrows;
    for (coder::SizeType iFunc{0}; iFunc < i; iFunc++) {
      for (coder::SizeType iRow{0}; iRow < i1; iRow++) {
        varargout_2[iFunc] =
            varargout_2[iFunc] + varargin_2[iFunc + varargin_2.size(1) * iRow] *
                                     varargout_1[varargout_1.size(1) * iRow];
      }
    }
  }
}

//  wls_var_lap  Compute variational Laplacian as weighted sum at evaluation
void wls_var_lap(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                 ::coder::array<real_T, 2U> &varargout_1)
{
  coder::SizeType i;
  coder::SizeType lap_size_idx_1;
  coder::SizeType nDims;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T lap_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    lap_size_idx_1 = 1;
    lap_data[0] = 3;
    break;
  case 2:
    lap_size_idx_1 = 2;
    lap_data[0] = 4;
    lap_data[1] = 5;
    break;
  default:
    lap_size_idx_1 = 3;
    lap_data[0] = 5;
    lap_data[1] = 6;
    lap_data[2] = 7;
    break;
  }
  nevpnts = eval_pnts.size(0);
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  e_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv.data,
               b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(1, u0);
  for (i = 0; i < u0; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  for (coder::SizeType jDiff{0}; jDiff < lap_size_idx_1; jDiff++) {
    coder::SizeType offset;
    //  Loop through the operators
    offset = (lap_data[jDiff] - 1) * b_wls->us.size(0);
    //  Sum up monomials weighted by weights for each component
    i = b_wls->ncols - b_wls->interp0;
    for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      coder::SizeType j;
      j = b_wls->jpvt[iMonomial] + b_wls->interp0;
      for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
        b_wls->rhs[iMonomial] =
            b_wls->rhs[iMonomial] +
            b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    u0 = b_wls->QR.size(1);
    for (i = 0; i < u0; i++) {
      lap_size_idx_1 = b_wls->QR.size(0);
      for (coder::SizeType i1{0}; i1 < lap_size_idx_1; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  }
  varargout_1.set_size(u1, 1);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    varargout_1[varargout_1.size(1) * (b_i + b_wls->interp0)] = b_wls->rhs[b_i];
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
      varargout_1[varargout_1.size(1) * iRow] =
          varargout_1[varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
    }
  }
  if (b_wls->interp0 != 0) {
    real_T s;
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    s = 0.0;
    for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
      s += varargout_1[varargout_1.size(1) * (b_i - 1)];
    }
    varargout_1[0] = 0.0 - s;
  }
}

//  wls_var_lap  Compute variational Laplacian as weighted sum at evaluation
void wls_var_lap(WlsObject *b_wls, const ::coder::array<real_T, 2U> &eval_pnts,
                 const ::coder::array<real_T, 2U> &varargin_1,
                 ::coder::array<real_T, 2U> &varargout_1)
{
  coder::SizeType i;
  coder::SizeType lap_size_idx_1;
  coder::SizeType nDims;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  int8_T lap_data[3];
  switch (b_wls->us.size(1)) {
  case 1:
    lap_size_idx_1 = 1;
    lap_data[0] = 3;
    break;
  case 2:
    lap_size_idx_1 = 2;
    lap_data[0] = 4;
    lap_data[1] = 5;
    break;
  default:
    lap_size_idx_1 = 3;
    lap_data[0] = 5;
    lap_data[1] = 6;
    lap_data[2] = 7;
    break;
  }
  nevpnts = eval_pnts.size(0) - 1;
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint <= nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  e_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv.data,
               b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(1, u0);
  for (i = 0; i < u0; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  for (coder::SizeType jDiff{0}; jDiff < lap_size_idx_1; jDiff++) {
    coder::SizeType offset;
    //  Loop through the operators
    offset = (lap_data[jDiff] - 1) * b_wls->us.size(0);
    //  Sum up monomials weighted by weights for each component
    i = b_wls->ncols - b_wls->interp0;
    for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
      coder::SizeType j;
      j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
      if ((varargin_1.size(0) == 0) || (varargin_1.size(1) == 0)) {
        for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial] =
              b_wls->rhs[iMonomial] +
              b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      } else {
        for (coder::SizeType iEval{0}; iEval <= nevpnts; iEval++) {
          b_wls->rhs[iMonomial] =
              b_wls->rhs[iMonomial] +
              varargin_1[varargin_1.size(1) * iEval] *
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
        }
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    u0 = b_wls->QR.size(1);
    for (i = 0; i < u0; i++) {
      lap_size_idx_1 = b_wls->QR.size(0);
      for (coder::SizeType i1{0}; i1 < lap_size_idx_1; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 1);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 1,
                b_wls->work);
  }
  varargout_1.set_size(u1, 1);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (coder::SizeType b_i{0}; b_i < i; b_i++) {
    varargout_1[varargout_1.size(1) * (b_i + b_wls->interp0)] = b_wls->rhs[b_i];
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
      varargout_1[varargout_1.size(1) * iRow] =
          varargout_1[varargout_1.size(1) * iRow] * b_wls->rweights[iRow];
    }
  }
  if (b_wls->interp0 != 0) {
    real_T s;
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    s = 0.0;
    for (coder::SizeType b_i{2}; b_i <= i; b_i++) {
      s += varargout_1[varargout_1.size(1) * (b_i - 1)];
    }
    varargout_1[0] = 0.0 - s;
  }
}

//  wls_var_sym_grad  Variational symmetric-gradient operators as weighted sum
void wls_var_sym_grad(WlsObject *b_wls,
                      const ::coder::array<real_T, 2U> &eval_pnts,
                      const ::coder::array<real_T, 2U> &ws,
                      const ::coder::array<real_T, 2U> &fs,
                      ::coder::array<real_T, 2U> &vdops, real_T result_data[],
                      coder::SizeType result_size[2])
{
  real_T d_vdops;
  real_T e_vdops;
  real_T f_vdops;
  coder::SizeType b_i;
  coder::SizeType i;
  if (ws.size(1) <= 1) {
    coder::SizeType i1;
    coder::SizeType j;
    coder::SizeType loop_ub;
    coder::SizeType nDiff;
    coder::SizeType nDims;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType nrows_vdops;
    coder::SizeType u0;
    coder::SizeType u1;
    nevpnts = eval_pnts.size(0);
    //  Step 1: Tabulate monomial basis functions at evaluation points
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = eval_pnts.size(0);
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType dim{0}; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[dim]) *
              b_wls->hs_inv.data[dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType dim{0}; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    b_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree,
                 b_wls->hs_inv.data, b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    nDiff = 8;
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(9, u0);
    loop_ub = u0 * 9;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    b_i = 9;
    while ((b_i > 0) && (iv2[b_i - 1] == 0)) {
      nDiff--;
      b_i--;
    }
    //  Summing up rows in the differential operator
    for (coder::SizeType iOp{0}; iOp <= nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > 9) || (iv2[iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > 9) {
          offset = 0;
        } else {
          offset = (iv2[iOp] - 1) * b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[ws.size(1) * iEval] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, 9);
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (i1 = 0; i1 < u0; i1++) {
          b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * i1];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, 9);
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                  b_wls->work);
    }
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      nrows_vdops = u0;
    } else {
      nrows_vdops = u1;
    }
    vdops.set_size(nrows_vdops, 9);
    //  Transpose the operator for row-major
    i = nrows_vdops - b_wls->interp0;
    for (b_i = 0; b_i < i; b_i++) {
      for (j = 0; j < 9; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < 9; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  In interp0 mode, set the first entry based on partition of unity
      i = b_wls->nstpnts;
      for (j = 0; j < 9; j++) {
        real_T s;
        real_T totalw;
        s = 0.0;
        for (b_i = 2; b_i <= i; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        if (iv2[j] > 1) {
          totalw = 0.0;
        } else {
          i1 = ws.size(0);
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            totalw = nevpnts;
            //  Unit weights summed together
          } else {
            //  All weights summed together
            totalw = 0.0;
            for (b_i = 0; b_i < i1; b_i++) {
              totalw += ws[ws.size(1) * b_i];
            }
          }
        }
        vdops[j] = totalw - s;
      }
    }
    i = b_wls->nrows;
    for (b_i = 0; b_i < i; b_i++) {
      real_T b_vdops;
      real_T c_vdops;
      b_vdops = vdops[vdops.size(1) * b_i + 2];
      e_vdops = vdops[vdops.size(1) * b_i + 1];
      c_vdops = vdops[vdops.size(1) * b_i];
      vdops[vdops.size(1) * b_i] = 0.0;
      vdops[vdops.size(1) * b_i + 1] = -b_vdops;
      vdops[vdops.size(1) * b_i + 2] = e_vdops;
      vdops[vdops.size(1) * b_i + 3] = b_vdops;
      vdops[vdops.size(1) * b_i + 4] = 0.0;
      vdops[vdops.size(1) * b_i + 5] = -c_vdops;
      vdops[vdops.size(1) * b_i + 6] = -e_vdops;
      vdops[vdops.size(1) * b_i + 7] = c_vdops;
      vdops[vdops.size(1) * b_i + 8] = 0.0;
    }
  } else {
    coder::SizeType i1;
    coder::SizeType iWeight;
    coder::SizeType j;
    coder::SizeType lenWs;
    coder::SizeType loop_ub;
    coder::SizeType nDiff;
    coder::SizeType nDims;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType u0;
    coder::SizeType u1;
    nevpnts = eval_pnts.size(0);
    //  Step 1: Tabulate monomial basis functions at evaluation points
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = eval_pnts.size(0);
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType dim{0}; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[dim]) *
              b_wls->hs_inv.data[dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType dim{0}; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    b_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree,
                 b_wls->hs_inv.data, b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    nDiff = 8;
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(9, u0);
    loop_ub = u0 * 9;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    b_i = 9;
    while ((b_i > 0) && (iv3[b_i - 1] == 0)) {
      nDiff--;
      b_i--;
    }
    if (ws.size(0) == 0) {
      lenWs = 1;
    } else {
      lenWs = ws.size(1);
    }
    //  Summing up rows in the differential operator
    iWeight = 1;
    //  Loop through the operators
    for (coder::SizeType iOp{0}; iOp <= nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > 9) || (iv3[iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > 9) {
          offset = 0;
        } else {
          offset = (iv3[iOp] - 1) * b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if (ws.size(0) == 0) {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[(iWeight + ws.size(1) * iEval) - 1] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
      if (iWeight == lenWs) {
        iWeight = 1;
      } else {
        iWeight++;
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, 9);
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (i1 = 0; i1 < u0; i1++) {
          b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * i1];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, 9);
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                  b_wls->work);
    }
    vdops.set_size(u1, 9);
    //  Transpose the operator for row-major
    i = u1 - b_wls->interp0;
    for (b_i = 0; b_i < i; b_i++) {
      for (j = 0; j < 9; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < 9; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  In interp0 mode, set the first entry based on partition of unity
      iWeight = 1;
      i = b_wls->nstpnts;
      for (j = 0; j < 9; j++) {
        real_T s;
        real_T totalw;
        s = 0.0;
        for (b_i = 2; b_i <= i; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        if (iv3[j] > 1) {
          totalw = 0.0;
        } else {
          i1 = ws.size(0);
          if (ws.size(0) == 0) {
            totalw = nevpnts;
            //  Unit weights summed together
          } else {
            //  All weights summed together
            totalw = 0.0;
            for (b_i = 0; b_i < i1; b_i++) {
              totalw += ws[(iWeight + ws.size(1) * b_i) - 1];
            }
            iWeight += iWeight < ws.size(1);
          }
        }
        vdops[j] = totalw - s;
      }
    }
    i = b_wls->nrows;
    for (b_i = 0; b_i < i; b_i++) {
      real_T b_vdops;
      real_T c_vdops;
      real_T g_vdops;
      b_vdops = vdops[vdops.size(1) * b_i + 3];
      c_vdops = vdops[vdops.size(1) * b_i];
      d_vdops = vdops[vdops.size(1) * b_i + 1];
      f_vdops = vdops[vdops.size(1) * b_i + 4];
      e_vdops = vdops[vdops.size(1) * b_i + 5];
      g_vdops = vdops[vdops.size(1) * b_i + 2];
      vdops[vdops.size(1) * b_i] = 0.0;
      vdops[vdops.size(1) * b_i + 1] = -b_vdops;
      vdops[vdops.size(1) * b_i + 2] = c_vdops;
      vdops[vdops.size(1) * b_i + 3] = d_vdops;
      vdops[vdops.size(1) * b_i + 4] = 0.0;
      vdops[vdops.size(1) * b_i + 5] = -f_vdops;
      vdops[vdops.size(1) * b_i + 6] = -e_vdops;
      vdops[vdops.size(1) * b_i + 7] = g_vdops;
      vdops[vdops.size(1) * b_i + 8] = 0.0;
    }
  }
  //  compute output value
  if ((fs.size(0) != 0) && (fs.size(1) != 0)) {
    result_size[1] = 1;
    result_size[0] = 3;
    result_data[0] = 0.0;
    result_data[1] = 0.0;
    result_data[2] = 0.0;
    i = b_wls->nrows;
    for (b_i = 0; b_i < i; b_i++) {
      e_vdops = fs[fs.size(1) * b_i + 1];
      d_vdops = fs[fs.size(1) * b_i + 2];
      result_data[0] =
          (result_data[0] + vdops[vdops.size(1) * b_i + 1] * e_vdops) +
          vdops[vdops.size(1) * b_i + 2] * d_vdops;
      f_vdops = fs[fs.size(1) * b_i];
      result_data[1] =
          (result_data[1] + f_vdops * vdops[vdops.size(1) * b_i + 3]) +
          d_vdops * vdops[vdops.size(1) * b_i + 5];
      result_data[2] =
          (result_data[2] + f_vdops * vdops[vdops.size(1) * b_i + 6]) +
          e_vdops * vdops[vdops.size(1) * b_i + 7];
    }
  } else {
    result_size[1] = 0;
    result_size[0] = 3;
  }
}

//  wls_var_sym_grad  Variational symmetric-gradient operators as weighted sum
void wls_var_sym_grad(WlsObject *b_wls,
                      const ::coder::array<real_T, 2U> &eval_pnts,
                      ::coder::array<real_T, 2U> &vdops, const real_T[],
                      coder::SizeType result_size[2])
{
  coder::SizeType b_i;
  coder::SizeType i;
  coder::SizeType j;
  coder::SizeType loop_ub;
  coder::SizeType nDiff;
  coder::SizeType nDims;
  coder::SizeType nevpnts;
  coder::SizeType nrows;
  coder::SizeType u0;
  coder::SizeType u1;
  nevpnts = eval_pnts.size(0);
  //  Step 1: Tabulate monomial basis functions at evaluation points
  nDims = eval_pnts.size(1) - 1;
  b_wls->nevpnts = eval_pnts.size(0);
  //  scale the coordinates; use wls.us as buffer
  b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
  if (b_wls->interp0 != 0) {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
             b_wls->origin.data[dim]) *
            b_wls->hs_inv.data[dim];
      }
    }
  } else {
    for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
      for (coder::SizeType dim{0}; dim <= nDims; dim++) {
        b_wls->us[dim + b_wls->us.size(1) * iPoint] =
            eval_pnts[dim + eval_pnts.size(1) * iPoint] *
            b_wls->hs_inv.data[dim];
      }
    }
  }
  //  compute the weighted Vandermonde matrix
  b_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree, b_wls->hs_inv.data,
               b_wls->hs_inv.size, b_wls->V);
  //  Step 2: Update the RHS of WLS from Vandermonde matrix
  nDiff = 8;
  u0 = b_wls->ncols;
  u1 = b_wls->nrows;
  if (u0 >= u1) {
    u1 = u0;
  }
  u0 = u1 - b_wls->interp0;
  b_wls->rhs.set_size(9, u0);
  loop_ub = u0 * 9;
  for (i = 0; i < loop_ub; i++) {
    b_wls->rhs[i] = 0.0;
  }
  //  Omit zeros in the diff operators
  b_i = 9;
  while ((b_i > 0) && (iv2[b_i - 1] == 0)) {
    nDiff--;
    b_i--;
  }
  //  Summing up rows in the differential operator
  for (coder::SizeType iOp{0}; iOp <= nDiff; iOp++) {
    //  Skip padded zeros in the differential operator
    if ((iOp + 1 > 9) || (iv2[iOp] > 0)) {
      coder::SizeType offset;
      if (iOp + 1 > 9) {
        offset = 0;
      } else {
        offset = (iv2[iOp] - 1) * b_wls->us.size(0);
      }
      //  Sum up monomials weighted by weights for each component
      i = b_wls->ncols - b_wls->interp0;
      for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
        j = b_wls->jpvt[iMonomial] + b_wls->interp0;
        for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
          b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
              b_wls->V[(offset + iEval) + b_wls->V.size(1) * (j - 1)];
        }
      }
    }
  }
  //  Step 3: Solve the Vandermonde system to build the operator
  if (b_wls->rowmajor) {
    rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 9);
    rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                b_wls->work);
  } else {
    b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
    loop_ub = b_wls->QR.size(1);
    for (i = 0; i < loop_ub; i++) {
      u0 = b_wls->QR.size(0);
      for (coder::SizeType i1{0}; i1 < u0; i1++) {
        b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
            b_wls->QR[i + b_wls->QR.size(1) * i1];
      }
    }
    rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                 b_wls->rhs, 9);
    rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                b_wls->work);
  }
  vdops.set_size(u1, 9);
  //  Transpose the operator for row-major
  i = u1 - b_wls->interp0;
  for (b_i = 0; b_i < i; b_i++) {
    for (j = 0; j < 9; j++) {
      vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
          b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
    }
  }
  nrows = b_wls->nrows;
  if (b_wls->rweights.size(0) != 0) {
    for (coder::SizeType k{0}; k < 9; k++) {
      for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
        vdops[k + vdops.size(1) * iRow] =
            vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
      }
    }
  }
  if (b_wls->interp0 != 0) {
    //  In interp0 mode, set the first entry based on partition of unity
    i = b_wls->nstpnts;
    for (j = 0; j < 9; j++) {
      real_T s;
      coder::SizeType totalw;
      s = 0.0;
      for (b_i = 2; b_i <= i; b_i++) {
        s += vdops[j + vdops.size(1) * (b_i - 1)];
      }
      if (iv2[j] > 1) {
        totalw = 0;
      } else {
        totalw = nevpnts;
        //  Unit weights summed together
      }
      vdops[j] = static_cast<real_T>(totalw) - s;
    }
  }
  i = b_wls->nrows;
  for (b_i = 0; b_i < i; b_i++) {
    real_T b_vdops;
    real_T c_vdops;
    real_T d;
    b_vdops = vdops[vdops.size(1) * b_i + 2];
    d = vdops[vdops.size(1) * b_i + 1];
    c_vdops = vdops[vdops.size(1) * b_i];
    vdops[vdops.size(1) * b_i] = 0.0;
    vdops[vdops.size(1) * b_i + 1] = -b_vdops;
    vdops[vdops.size(1) * b_i + 2] = d;
    vdops[vdops.size(1) * b_i + 3] = b_vdops;
    vdops[vdops.size(1) * b_i + 4] = 0.0;
    vdops[vdops.size(1) * b_i + 5] = -c_vdops;
    vdops[vdops.size(1) * b_i + 6] = -d;
    vdops[vdops.size(1) * b_i + 7] = c_vdops;
    vdops[vdops.size(1) * b_i + 8] = 0.0;
  }
  //  compute output value
  result_size[1] = 0;
  result_size[0] = 3;
}

//  wls_var_sym_grad  Variational symmetric-gradient operators as weighted sum
void wls_var_sym_grad(WlsObject *b_wls,
                      const ::coder::array<real_T, 2U> &eval_pnts,
                      const ::coder::array<real_T, 2U> &ws,
                      ::coder::array<real_T, 2U> &vdops, const real_T[],
                      coder::SizeType result_size[2])
{
  if (ws.size(1) <= 1) {
    coder::SizeType b_i;
    coder::SizeType i;
    coder::SizeType i1;
    coder::SizeType j;
    coder::SizeType loop_ub;
    coder::SizeType nDiff;
    coder::SizeType nDims;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType nrows_vdops;
    coder::SizeType u0;
    coder::SizeType u1;
    nevpnts = eval_pnts.size(0);
    //  Step 1: Tabulate monomial basis functions at evaluation points
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = eval_pnts.size(0);
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType dim{0}; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[dim]) *
              b_wls->hs_inv.data[dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType dim{0}; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    b_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree,
                 b_wls->hs_inv.data, b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    nDiff = 8;
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(9, u0);
    loop_ub = u0 * 9;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    b_i = 9;
    while ((b_i > 0) && (iv2[b_i - 1] == 0)) {
      nDiff--;
      b_i--;
    }
    //  Summing up rows in the differential operator
    for (coder::SizeType iOp{0}; iOp <= nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > 9) || (iv2[iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > 9) {
          offset = 0;
        } else {
          offset = (iv2[iOp] - 1) * b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[ws.size(1) * iEval] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, 9);
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (i1 = 0; i1 < u0; i1++) {
          b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * i1];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, 9);
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                  b_wls->work);
    }
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      nrows_vdops = u0;
    } else {
      nrows_vdops = u1;
    }
    vdops.set_size(nrows_vdops, 9);
    //  Transpose the operator for row-major
    i = nrows_vdops - b_wls->interp0;
    for (b_i = 0; b_i < i; b_i++) {
      for (j = 0; j < 9; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < 9; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  In interp0 mode, set the first entry based on partition of unity
      i = b_wls->nstpnts;
      for (j = 0; j < 9; j++) {
        real_T s;
        real_T totalw;
        s = 0.0;
        for (b_i = 2; b_i <= i; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        if (iv2[j] > 1) {
          totalw = 0.0;
        } else {
          i1 = ws.size(0);
          if ((ws.size(0) == 0) || (ws.size(1) == 0)) {
            totalw = nevpnts;
            //  Unit weights summed together
          } else {
            //  All weights summed together
            totalw = 0.0;
            for (b_i = 0; b_i < i1; b_i++) {
              totalw += ws[ws.size(1) * b_i];
            }
          }
        }
        vdops[j] = totalw - s;
      }
    }
    i = b_wls->nrows;
    for (b_i = 0; b_i < i; b_i++) {
      real_T b_vdops;
      real_T c_vdops;
      real_T d_vdops;
      b_vdops = vdops[vdops.size(1) * b_i + 2];
      d_vdops = vdops[vdops.size(1) * b_i + 1];
      c_vdops = vdops[vdops.size(1) * b_i];
      vdops[vdops.size(1) * b_i] = 0.0;
      vdops[vdops.size(1) * b_i + 1] = -b_vdops;
      vdops[vdops.size(1) * b_i + 2] = d_vdops;
      vdops[vdops.size(1) * b_i + 3] = b_vdops;
      vdops[vdops.size(1) * b_i + 4] = 0.0;
      vdops[vdops.size(1) * b_i + 5] = -c_vdops;
      vdops[vdops.size(1) * b_i + 6] = -d_vdops;
      vdops[vdops.size(1) * b_i + 7] = c_vdops;
      vdops[vdops.size(1) * b_i + 8] = 0.0;
    }
  } else {
    coder::SizeType b_i;
    coder::SizeType i;
    coder::SizeType i1;
    coder::SizeType iWeight;
    coder::SizeType j;
    coder::SizeType lenWs;
    coder::SizeType loop_ub;
    coder::SizeType nDiff;
    coder::SizeType nDims;
    coder::SizeType nevpnts;
    coder::SizeType nrows;
    coder::SizeType u0;
    coder::SizeType u1;
    nevpnts = eval_pnts.size(0);
    //  Step 1: Tabulate monomial basis functions at evaluation points
    nDims = eval_pnts.size(1) - 1;
    b_wls->nevpnts = eval_pnts.size(0);
    //  scale the coordinates; use wls.us as buffer
    b_wls->us.set_size(((eval_pnts.size(0) + 3) / 4) << 2, eval_pnts.size(1));
    if (b_wls->interp0 != 0) {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType dim{0}; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              (eval_pnts[dim + eval_pnts.size(1) * iPoint] -
               b_wls->origin.data[dim]) *
              b_wls->hs_inv.data[dim];
        }
      }
    } else {
      for (coder::SizeType iPoint{0}; iPoint < nevpnts; iPoint++) {
        for (coder::SizeType dim{0}; dim <= nDims; dim++) {
          b_wls->us[dim + b_wls->us.size(1) * iPoint] =
              eval_pnts[dim + eval_pnts.size(1) * iPoint] *
              b_wls->hs_inv.data[dim];
        }
      }
    }
    //  compute the weighted Vandermonde matrix
    b_gen_vander(b_wls->us, eval_pnts.size(0), b_wls->degree,
                 b_wls->hs_inv.data, b_wls->hs_inv.size, b_wls->V);
    //  Step 2: Update the RHS of WLS from Vandermonde matrix
    nDiff = 8;
    u0 = b_wls->ncols;
    u1 = b_wls->nrows;
    if (u0 >= u1) {
      u1 = u0;
    }
    u0 = u1 - b_wls->interp0;
    b_wls->rhs.set_size(9, u0);
    loop_ub = u0 * 9;
    for (i = 0; i < loop_ub; i++) {
      b_wls->rhs[i] = 0.0;
    }
    //  Omit zeros in the diff operators
    b_i = 9;
    while ((b_i > 0) && (iv3[b_i - 1] == 0)) {
      nDiff--;
      b_i--;
    }
    if (ws.size(0) == 0) {
      lenWs = 1;
    } else {
      lenWs = ws.size(1);
    }
    //  Summing up rows in the differential operator
    iWeight = 1;
    //  Loop through the operators
    for (coder::SizeType iOp{0}; iOp <= nDiff; iOp++) {
      //  Skip padded zeros in the differential operator
      if ((iOp + 1 > 9) || (iv3[iOp] > 0)) {
        coder::SizeType offset;
        if (iOp + 1 > 9) {
          offset = 0;
        } else {
          offset = (iv3[iOp] - 1) * b_wls->us.size(0);
        }
        //  Sum up monomials weighted by weights for each component
        i = b_wls->ncols - b_wls->interp0;
        for (coder::SizeType iMonomial{0}; iMonomial < i; iMonomial++) {
          j = (b_wls->jpvt[iMonomial] + b_wls->interp0) - 1;
          if (ws.size(0) == 0) {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          } else {
            for (coder::SizeType iEval{0}; iEval < nevpnts; iEval++) {
              b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] =
                  b_wls->rhs[iMonomial + b_wls->rhs.size(1) * iOp] +
                  ws[(iWeight + ws.size(1) * iEval) - 1] *
                      b_wls->V[(offset + iEval) + b_wls->V.size(1) * j];
            }
          }
        }
      }
      if (iWeight == lenWs) {
        iWeight = 1;
      } else {
        iWeight++;
      }
    }
    //  Step 3: Solve the Vandermonde system to build the operator
    if (b_wls->rowmajor) {
      rrqr_rtsolve(b_wls->QR, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, 9);
      rrqr_qmulti(b_wls->QR, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                  b_wls->work);
    } else {
      b_wls->QRt.set_size(b_wls->QR.size(1), b_wls->QR.size(0));
      loop_ub = b_wls->QR.size(1);
      for (i = 0; i < loop_ub; i++) {
        u0 = b_wls->QR.size(0);
        for (i1 = 0; i1 < u0; i1++) {
          b_wls->QRt[i1 + b_wls->QRt.size(1) * i] =
              b_wls->QR[i + b_wls->QR.size(1) * i1];
        }
      }
      rrqr_rtsolve(b_wls->QRt, b_wls->ncols - b_wls->interp0, b_wls->rank,
                   b_wls->rhs, 9);
      rrqr_qmulti(b_wls->QRt, b_wls->nrows - b_wls->interp0,
                  b_wls->ncols - b_wls->interp0, b_wls->rank, b_wls->rhs, 9,
                  b_wls->work);
    }
    vdops.set_size(u1, 9);
    //  Transpose the operator for row-major
    i = u1 - b_wls->interp0;
    for (b_i = 0; b_i < i; b_i++) {
      for (j = 0; j < 9; j++) {
        vdops[j + vdops.size(1) * (b_i + b_wls->interp0)] =
            b_wls->rhs[b_i + b_wls->rhs.size(1) * j];
      }
    }
    nrows = b_wls->nrows;
    if (b_wls->rweights.size(0) != 0) {
      for (coder::SizeType k{0}; k < 9; k++) {
        for (coder::SizeType iRow{0}; iRow < nrows; iRow++) {
          vdops[k + vdops.size(1) * iRow] =
              vdops[k + vdops.size(1) * iRow] * b_wls->rweights[iRow];
        }
      }
    }
    if (b_wls->interp0 != 0) {
      //  In interp0 mode, set the first entry based on partition of unity
      iWeight = 1;
      i = b_wls->nstpnts;
      for (j = 0; j < 9; j++) {
        real_T s;
        real_T totalw;
        s = 0.0;
        for (b_i = 2; b_i <= i; b_i++) {
          s += vdops[j + vdops.size(1) * (b_i - 1)];
        }
        if (iv3[j] > 1) {
          totalw = 0.0;
        } else {
          i1 = ws.size(0);
          if (ws.size(0) == 0) {
            totalw = nevpnts;
            //  Unit weights summed together
          } else {
            //  All weights summed together
            totalw = 0.0;
            for (b_i = 0; b_i < i1; b_i++) {
              totalw += ws[(iWeight + ws.size(1) * b_i) - 1];
            }
            iWeight += iWeight < ws.size(1);
          }
        }
        vdops[j] = totalw - s;
      }
    }
    i = b_wls->nrows;
    for (b_i = 0; b_i < i; b_i++) {
      real_T b_vdops;
      real_T c_vdops;
      real_T d_vdops;
      real_T e_vdops;
      real_T f_vdops;
      real_T g_vdops;
      b_vdops = vdops[vdops.size(1) * b_i + 3];
      c_vdops = vdops[vdops.size(1) * b_i];
      d_vdops = vdops[vdops.size(1) * b_i + 1];
      e_vdops = vdops[vdops.size(1) * b_i + 4];
      f_vdops = vdops[vdops.size(1) * b_i + 5];
      g_vdops = vdops[vdops.size(1) * b_i + 2];
      vdops[vdops.size(1) * b_i] = 0.0;
      vdops[vdops.size(1) * b_i + 1] = -b_vdops;
      vdops[vdops.size(1) * b_i + 2] = c_vdops;
      vdops[vdops.size(1) * b_i + 3] = d_vdops;
      vdops[vdops.size(1) * b_i + 4] = 0.0;
      vdops[vdops.size(1) * b_i + 5] = -e_vdops;
      vdops[vdops.size(1) * b_i + 6] = -f_vdops;
      vdops[vdops.size(1) * b_i + 7] = g_vdops;
      vdops[vdops.size(1) * b_i + 8] = 0.0;
    }
  }
  //  compute output value
  result_size[1] = 0;
  result_size[0] = 3;
}

} // namespace wls

// End of code generation (wls_internal.cpp)
